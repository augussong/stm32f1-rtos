; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\rvmdk\stm32f10x_i2c.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime --diag_suppress=9931 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I.\RTE\_Flash -I"C:\Program Files\0Software\Keil_v5\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"C:\Program Files\0Software\Keil_v5\ARM\CMSIS\Include" -I"C:\Program Files\0Software\Keil_v5\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0" -D__MICROLIB -D__UVISION_VERSION=528 -DSTM32F10X_MD --omf_browse=.\rvmdk\stm32f10x_i2c.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;110    *******************************************************************************/
;;;111    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113      /* Check the parameters */
;;;114      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;115    
;;;116      switch (*(u32*)&I2Cx)
000002  f1a04080          SUB      r0,r0,#0x40000000
000006  f5b040a8          SUBS     r0,r0,#0x5400
00000a  d00d              BEQ      |L1.40|
00000c  f5b06f80          CMP      r0,#0x400
000010  d115              BNE      |L1.62|
;;;117      {
;;;118        case I2C1_BASE:
;;;119          /* Enable I2C1 reset state */
;;;120          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
;;;121          /* Release I2C1 from reset state */
;;;122          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
;;;123          break;
;;;124    
;;;125        case I2C2_BASE:
;;;126          /* Enable I2C2 reset state */
;;;127          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000012  2101              MOVS     r1,#1
000014  0588              LSLS     r0,r1,#22
000016  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;128          /* Release I2C2 from reset state */
;;;129          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
00001a  e8bd4010          POP      {r4,lr}
00001e  2100              MOVS     r1,#0
000020  f44f0080          MOV      r0,#0x400000
000024  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.40|
000028  2101              MOVS     r1,#1                 ;120
00002a  0548              LSLS     r0,r1,#21             ;120
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000030  e8bd4010          POP      {r4,lr}               ;122
000034  2100              MOVS     r1,#0                 ;122
000036  f44f1000          MOV      r0,#0x200000          ;122
00003a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.62|
;;;130          break;
;;;131    
;;;132        default:
;;;133          break;
;;;134      }
;;;135    }
00003e  bd10              POP      {r4,pc}
;;;136    
                          ENDP

                  I2C_Init PROC
;;;147    ******************************************************************************/
;;;148    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000040  b570              PUSH     {r4-r6,lr}
;;;149    {
000042  b086              SUB      sp,sp,#0x18
000044  4604              MOV      r4,r0
000046  460d              MOV      r5,r1
;;;150      u16 tmpreg = 0, freqrange = 0;
;;;151      u16 result = 0x04;
;;;152      u32 pclk1 = 8000000;
;;;153      RCC_ClocksTypeDef  rcc_clocks;
;;;154    
;;;155      /* Check the parameters */
;;;156      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;157      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;158      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;159      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;160      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;161      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;162      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;163    
;;;164    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;165      /* Get the I2Cx CR2 value */
;;;166      tmpreg = I2Cx->CR2;
000048  88a0              LDRH     r0,[r4,#4]
;;;167      /* Clear frequency FREQ[5:0] bits */
;;;168      tmpreg &= CR2_FREQ_Reset;
00004a  f020063f          BIC      r6,r0,#0x3f
;;;169      /* Get pclk1 frequency value */
;;;170      RCC_GetClocksFreq(&rcc_clocks);
00004e  a801              ADD      r0,sp,#4
000050  f7fffffe          BL       RCC_GetClocksFreq
;;;171      pclk1 = rcc_clocks.PCLK1_Frequency;
000054  9803              LDR      r0,[sp,#0xc]
;;;172      /* Set frequency bits depending on pclk1 value */
;;;173      freqrange = (u16)(pclk1 / 1000000);
000056  49d2              LDR      r1,|L1.928|
000058  fbb0f1f1          UDIV     r1,r0,r1
00005c  b289              UXTH     r1,r1
;;;174      tmpreg |= freqrange;
00005e  ea460201          ORR      r2,r6,r1
;;;175      /* Write to I2Cx CR2 */
;;;176      I2Cx->CR2 = tmpreg;
000062  80a2              STRH     r2,[r4,#4]
;;;177    
;;;178    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;179      /* Disable the selected I2C peripheral to configure TRISE */
;;;180      I2Cx->CR1 &= CR1_PE_Reset;
000064  8822              LDRH     r2,[r4,#0]
000066  f0220201          BIC      r2,r2,#1
00006a  8022              STRH     r2,[r4,#0]
;;;181    
;;;182      /* Reset tmpreg value */
;;;183      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;184      tmpreg = 0;
;;;185    
;;;186      /* Configure speed in standard mode */
;;;187      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
00006c  4bcd              LDR      r3,|L1.932|
00006e  68ea              LDR      r2,[r5,#0xc]
000070  429a              CMP      r2,r3
000072  d809              BHI      |L1.136|
;;;188      {
;;;189        /* Standard mode speed calculate */
;;;190        result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
000074  0052              LSLS     r2,r2,#1
000076  fbb0f0f2          UDIV     r0,r0,r2
00007a  b280              UXTH     r0,r0
;;;191        /* Test if CCR value is under 0x4*/
;;;192        if (result < 0x04)
00007c  2804              CMP      r0,#4
00007e  d200              BCS      |L1.130|
;;;193        {
;;;194          /* Set minimum allowed value */
;;;195          result = 0x04;  
000080  2004              MOVS     r0,#4
                  |L1.130|
;;;196        }
;;;197        /* Set speed value for standard mode */
;;;198        tmpreg |= result;	  
;;;199        /* Set Maximum Rise Time for standard mode */
;;;200        I2Cx->TRISE = freqrange + 1; 
000082  1c49              ADDS     r1,r1,#1
000084  8421              STRH     r1,[r4,#0x20]
000086  e025              B        |L1.212|
                  |L1.136|
;;;201      }
;;;202      /* Configure speed in fast mode */
;;;203      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;204      {
;;;205        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
000088  886b              LDRH     r3,[r5,#2]
00008a  f5a34c3f          SUB      r12,r3,#0xbf00
00008e  f1bc0cff          SUBS     r12,r12,#0xff
000092  d00c              BEQ      |L1.174|
;;;206        {
;;;207          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;208          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
;;;209        }
;;;210        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;211        {
;;;212          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;213          result = (u16)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
000094  eb0203c2          ADD      r3,r2,r2,LSL #3
000098  eb031202          ADD      r2,r3,r2,LSL #4
00009c  fbb0f0f2          UDIV     r0,r0,r2
0000a0  b280              UXTH     r0,r0
;;;214          /* Set DUTY bit */
;;;215          result |= I2C_DutyCycle_16_9;
0000a2  f4404080          ORR      r0,r0,#0x4000
                  |L1.166|
;;;216        }
;;;217        /* Test if CCR value is under 0x1*/
;;;218        if ((result & CCR_CCR_Set) == 0)
0000a6  0502              LSLS     r2,r0,#20
0000a8  0d12              LSRS     r2,r2,#20
0000aa  d006              BEQ      |L1.186|
0000ac  e007              B        |L1.190|
                  |L1.174|
0000ae  eb020242          ADD      r2,r2,r2,LSL #1       ;208
0000b2  fbb0f0f2          UDIV     r0,r0,r2              ;208
0000b6  b280              UXTH     r0,r0                 ;208
0000b8  e7f5              B        |L1.166|
                  |L1.186|
;;;219        {
;;;220          /* Set minimum allowed value */
;;;221          result |= (u16)0x0001;  
0000ba  f0400001          ORR      r0,r0,#1
                  |L1.190|
;;;222        }
;;;223        /* Set speed value and set F/S bit for fast mode */
;;;224        tmpreg |= result | CCR_FS_Set;
0000be  f4404000          ORR      r0,r0,#0x8000
;;;225        /* Set Maximum Rise Time for fast mode */
;;;226        I2Cx->TRISE = (u16)(((freqrange * 300) / 1000) + 1);  
0000c2  f44f7296          MOV      r2,#0x12c
0000c6  4351              MULS     r1,r2,r1
0000c8  f44f727a          MOV      r2,#0x3e8
0000cc  fbb1f1f2          UDIV     r1,r1,r2
0000d0  1c49              ADDS     r1,r1,#1
0000d2  8421              STRH     r1,[r4,#0x20]
                  |L1.212|
;;;227      }
;;;228      /* Write to I2Cx CCR */
;;;229      I2Cx->CCR = tmpreg;
0000d4  83a0              STRH     r0,[r4,#0x1c]
;;;230    
;;;231      /* Enable the selected I2C peripheral */
;;;232      I2Cx->CR1 |= CR1_PE_Set;
0000d6  8820              LDRH     r0,[r4,#0]
0000d8  f0400001          ORR      r0,r0,#1
0000dc  8020              STRH     r0,[r4,#0]
;;;233    
;;;234    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;235      /* Get the I2Cx CR1 value */
;;;236      tmpreg = I2Cx->CR1;
0000de  8820              LDRH     r0,[r4,#0]
;;;237      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;238      tmpreg &= CR1_CLEAR_Mask;
0000e0  f020000a          BIC      r0,r0,#0xa
0000e4  f4206080          BIC      r0,r0,#0x400
;;;239      /* Configure I2Cx: mode and acknowledgement */
;;;240      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;241      /* Set ACK bit according to I2C_Ack value */
;;;242      tmpreg |= (u16)((u32)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
0000e8  8829              LDRH     r1,[r5,#0]
0000ea  88ea              LDRH     r2,[r5,#6]
0000ec  4311              ORRS     r1,r1,r2
0000ee  4308              ORRS     r0,r0,r1
;;;243      /* Write to I2Cx CR1 */
;;;244      I2Cx->CR1 = tmpreg;
0000f0  8020              STRH     r0,[r4,#0]
;;;245    
;;;246    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;247      /* Set I2Cx Own Address1 and acknowledged address */
;;;248      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
0000f2  8928              LDRH     r0,[r5,#8]
0000f4  88a9              LDRH     r1,[r5,#4]
0000f6  4308              ORRS     r0,r0,r1
0000f8  8120              STRH     r0,[r4,#8]
;;;249    }
0000fa  b006              ADD      sp,sp,#0x18
0000fc  bd70              POP      {r4-r6,pc}
;;;250    
                          ENDP

                  I2C_StructInit PROC
;;;258    *******************************************************************************/
;;;259    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
0000fe  2100              MOVS     r1,#0
;;;260    {
;;;261    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;262      /* Initialize the I2C_Mode member */
;;;263      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000100  8001              STRH     r1,[r0,#0]
;;;264    
;;;265      /* Initialize the I2C_DutyCycle member */
;;;266      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
000102  f64b72ff          MOV      r2,#0xbfff
000106  8042              STRH     r2,[r0,#2]
;;;267    
;;;268      /* Initialize the I2C_OwnAddress1 member */
;;;269      I2C_InitStruct->I2C_OwnAddress1 = 0;
000108  8081              STRH     r1,[r0,#4]
;;;270    
;;;271      /* Initialize the I2C_Ack member */
;;;272      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
00010a  80c1              STRH     r1,[r0,#6]
;;;273    
;;;274      /* Initialize the I2C_AcknowledgedAddress member */
;;;275      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00010c  f44f4180          MOV      r1,#0x4000
000110  8101              STRH     r1,[r0,#8]
;;;276    
;;;277      /* initialize the I2C_ClockSpeed member */
;;;278      I2C_InitStruct->I2C_ClockSpeed = 5000;
000112  f2413188          MOV      r1,#0x1388
000116  60c1              STR      r1,[r0,#0xc]
;;;279    }
000118  4770              BX       lr
;;;280    
                          ENDP

                  I2C_Cmd PROC
;;;289    *******************************************************************************/
;;;290    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00011a  2900              CMP      r1,#0
;;;291    {
00011c  d004              BEQ      |L1.296|
;;;292      /* Check the parameters */
;;;293      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;294      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;295    
;;;296      if (NewState != DISABLE)
;;;297      {
;;;298        /* Enable the selected I2C peripheral */
;;;299        I2Cx->CR1 |= CR1_PE_Set;
00011e  8801              LDRH     r1,[r0,#0]
000120  f0410101          ORR      r1,r1,#1
000124  8001              STRH     r1,[r0,#0]
;;;300      }
;;;301      else
;;;302      {
;;;303        /* Disable the selected I2C peripheral */
;;;304        I2Cx->CR1 &= CR1_PE_Reset;
;;;305      }
;;;306    }
000126  4770              BX       lr
                  |L1.296|
000128  8801              LDRH     r1,[r0,#0]            ;304
00012a  f0210101          BIC      r1,r1,#1              ;304
00012e  8001              STRH     r1,[r0,#0]            ;304
000130  4770              BX       lr
;;;307    
                          ENDP

                  I2C_DMACmd PROC
;;;316    *******************************************************************************/
;;;317    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000132  2900              CMP      r1,#0
;;;318    {
000134  d004              BEQ      |L1.320|
;;;319      /* Check the parameters */
;;;320      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;321      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;322    
;;;323      if (NewState != DISABLE)
;;;324      {
;;;325        /* Enable the selected I2C DMA requests */
;;;326        I2Cx->CR2 |= CR2_DMAEN_Set;
000136  8881              LDRH     r1,[r0,#4]
000138  f4416100          ORR      r1,r1,#0x800
00013c  8081              STRH     r1,[r0,#4]
;;;327      }
;;;328      else
;;;329      {
;;;330        /* Disable the selected I2C DMA requests */
;;;331        I2Cx->CR2 &= CR2_DMAEN_Reset;
;;;332      }
;;;333    }
00013e  4770              BX       lr
                  |L1.320|
000140  8881              LDRH     r1,[r0,#4]            ;331
000142  f4216100          BIC      r1,r1,#0x800          ;331
000146  8081              STRH     r1,[r0,#4]            ;331
000148  4770              BX       lr
;;;334    
                          ENDP

                  I2C_DMALastTransferCmd PROC
;;;343    *******************************************************************************/
;;;344    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00014a  2900              CMP      r1,#0
;;;345    {
00014c  d004              BEQ      |L1.344|
;;;346      /* Check the parameters */
;;;347      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;348      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;349    
;;;350      if (NewState != DISABLE)
;;;351      {
;;;352        /* Next DMA transfer is the last transfer */
;;;353        I2Cx->CR2 |= CR2_LAST_Set;
00014e  8881              LDRH     r1,[r0,#4]
000150  f4415180          ORR      r1,r1,#0x1000
000154  8081              STRH     r1,[r0,#4]
;;;354      }
;;;355      else
;;;356      {
;;;357        /* Next DMA transfer is not the last transfer */
;;;358        I2Cx->CR2 &= CR2_LAST_Reset;
;;;359      }
;;;360    }
000156  4770              BX       lr
                  |L1.344|
000158  8881              LDRH     r1,[r0,#4]            ;358
00015a  f4215180          BIC      r1,r1,#0x1000         ;358
00015e  8081              STRH     r1,[r0,#4]            ;358
000160  4770              BX       lr
;;;361    
                          ENDP

                  I2C_GenerateSTART PROC
;;;370    *******************************************************************************/
;;;371    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000162  2900              CMP      r1,#0
;;;372    {
000164  d004              BEQ      |L1.368|
;;;373      /* Check the parameters */
;;;374      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;375      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;376    
;;;377      if (NewState != DISABLE)
;;;378      {
;;;379        /* Generate a START condition */
;;;380        I2Cx->CR1 |= CR1_START_Set;
000166  8801              LDRH     r1,[r0,#0]
000168  f4417180          ORR      r1,r1,#0x100
00016c  8001              STRH     r1,[r0,#0]
;;;381      }
;;;382      else
;;;383      {
;;;384        /* Disable the START condition generation */
;;;385        I2Cx->CR1 &= CR1_START_Reset;
;;;386      }
;;;387    }
00016e  4770              BX       lr
                  |L1.368|
000170  8801              LDRH     r1,[r0,#0]            ;385
000172  f4217180          BIC      r1,r1,#0x100          ;385
000176  8001              STRH     r1,[r0,#0]            ;385
000178  4770              BX       lr
;;;388    
                          ENDP

                  I2C_GenerateSTOP PROC
;;;397    *******************************************************************************/
;;;398    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
00017a  2900              CMP      r1,#0
;;;399    {
00017c  d004              BEQ      |L1.392|
;;;400      /* Check the parameters */
;;;401      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;402      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;403    
;;;404      if (NewState != DISABLE)
;;;405      {
;;;406        /* Generate a STOP condition */
;;;407        I2Cx->CR1 |= CR1_STOP_Set;
00017e  8801              LDRH     r1,[r0,#0]
000180  f4417100          ORR      r1,r1,#0x200
000184  8001              STRH     r1,[r0,#0]
;;;408      }
;;;409      else
;;;410      {
;;;411        /* Disable the STOP condition generation */
;;;412        I2Cx->CR1 &= CR1_STOP_Reset;
;;;413      }
;;;414    }
000186  4770              BX       lr
                  |L1.392|
000188  8801              LDRH     r1,[r0,#0]            ;412
00018a  f4217100          BIC      r1,r1,#0x200          ;412
00018e  8001              STRH     r1,[r0,#0]            ;412
000190  4770              BX       lr
;;;415    
                          ENDP

                  I2C_AcknowledgeConfig PROC
;;;424    *******************************************************************************/
;;;425    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000192  2900              CMP      r1,#0
;;;426    {
000194  d004              BEQ      |L1.416|
;;;427      /* Check the parameters */
;;;428      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;429      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;430    
;;;431      if (NewState != DISABLE)
;;;432      {
;;;433        /* Enable the acknowledgement */
;;;434        I2Cx->CR1 |= CR1_ACK_Set;
000196  8801              LDRH     r1,[r0,#0]
000198  f4416180          ORR      r1,r1,#0x400
00019c  8001              STRH     r1,[r0,#0]
;;;435      }
;;;436      else
;;;437      {
;;;438        /* Disable the acknowledgement */
;;;439        I2Cx->CR1 &= CR1_ACK_Reset;
;;;440      }
;;;441    }
00019e  4770              BX       lr
                  |L1.416|
0001a0  8801              LDRH     r1,[r0,#0]            ;439
0001a2  f4216180          BIC      r1,r1,#0x400          ;439
0001a6  8001              STRH     r1,[r0,#0]            ;439
0001a8  4770              BX       lr
;;;442    
                          ENDP

                  I2C_OwnAddress2Config PROC
;;;450    *******************************************************************************/
;;;451    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address)
0001aa  8982              LDRH     r2,[r0,#0xc]
;;;452    {
;;;453      u16 tmpreg = 0;
;;;454    
;;;455      /* Check the parameters */
;;;456      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;457    
;;;458      /* Get the old register value */
;;;459      tmpreg = I2Cx->OAR2;
;;;460      /* Reset I2Cx Own address2 bit [7:1] */
;;;461      tmpreg &= OAR2_ADD2_Reset;
0001ac  f02202fe          BIC      r2,r2,#0xfe
;;;462      /* Set I2Cx Own address2 */
;;;463      tmpreg |= (u16)(Address & (u16)0x00FE);
0001b0  f00101fe          AND      r1,r1,#0xfe
0001b4  4311              ORRS     r1,r1,r2
;;;464      /* Store the new register value */
;;;465      I2Cx->OAR2 = tmpreg;
0001b6  8181              STRH     r1,[r0,#0xc]
;;;466    }
0001b8  4770              BX       lr
;;;467    
                          ENDP

                  I2C_DualAddressCmd PROC
;;;476    *******************************************************************************/
;;;477    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001ba  2900              CMP      r1,#0
;;;478    {
0001bc  d004              BEQ      |L1.456|
;;;479      /* Check the parameters */
;;;480      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;481      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;482    
;;;483      if (NewState != DISABLE)
;;;484      {
;;;485        /* Enable dual addressing mode */
;;;486        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
0001be  8981              LDRH     r1,[r0,#0xc]
0001c0  f0410101          ORR      r1,r1,#1
0001c4  8181              STRH     r1,[r0,#0xc]
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Disable dual addressing mode */
;;;491        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
;;;492      }
;;;493    }
0001c6  4770              BX       lr
                  |L1.456|
0001c8  8981              LDRH     r1,[r0,#0xc]          ;491
0001ca  f0210101          BIC      r1,r1,#1              ;491
0001ce  8181              STRH     r1,[r0,#0xc]          ;491
0001d0  4770              BX       lr
;;;494    
                          ENDP

                  I2C_GeneralCallCmd PROC
;;;503    *******************************************************************************/
;;;504    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001d2  2900              CMP      r1,#0
;;;505    {
0001d4  d004              BEQ      |L1.480|
;;;506      /* Check the parameters */
;;;507      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;508      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;509    
;;;510      if (NewState != DISABLE)
;;;511      {
;;;512        /* Enable generall call */
;;;513        I2Cx->CR1 |= CR1_ENGC_Set;
0001d6  8801              LDRH     r1,[r0,#0]
0001d8  f0410140          ORR      r1,r1,#0x40
0001dc  8001              STRH     r1,[r0,#0]
;;;514      }
;;;515      else
;;;516      {
;;;517        /* Disable generall call */
;;;518        I2Cx->CR1 &= CR1_ENGC_Reset;
;;;519      }
;;;520    }
0001de  4770              BX       lr
                  |L1.480|
0001e0  8801              LDRH     r1,[r0,#0]            ;518
0001e2  f0210140          BIC      r1,r1,#0x40           ;518
0001e6  8001              STRH     r1,[r0,#0]            ;518
0001e8  4770              BX       lr
;;;521    
                          ENDP

                  I2C_ITConfig PROC
;;;536    *******************************************************************************/
;;;537    void I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState)
0001ea  2a00              CMP      r2,#0
;;;538    {
0001ec  d003              BEQ      |L1.502|
;;;539      /* Check the parameters */
;;;540      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;541      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;542      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;543      
;;;544      if (NewState != DISABLE)
;;;545      {
;;;546        /* Enable the selected I2C interrupts */
;;;547        I2Cx->CR2 |= I2C_IT;
0001ee  8882              LDRH     r2,[r0,#4]
0001f0  4311              ORRS     r1,r1,r2
0001f2  8081              STRH     r1,[r0,#4]
;;;548      }
;;;549      else
;;;550      {
;;;551        /* Disable the selected I2C interrupts */
;;;552        I2Cx->CR2 &= (u16)~I2C_IT;
;;;553      }
;;;554    }
0001f4  4770              BX       lr
                  |L1.502|
0001f6  8882              LDRH     r2,[r0,#4]            ;552
0001f8  ea220101          BIC      r1,r2,r1              ;552
0001fc  8081              STRH     r1,[r0,#4]            ;552
0001fe  4770              BX       lr
;;;555    
                          ENDP

                  I2C_SendData PROC
;;;563    *******************************************************************************/
;;;564    void I2C_SendData(I2C_TypeDef* I2Cx, u8 Data)
000200  8201              STRH     r1,[r0,#0x10]
;;;565    {
;;;566      /* Check the parameters */
;;;567      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;568    
;;;569      /* Write in the DR register the data to be sent */
;;;570      I2Cx->DR = Data;
;;;571    }
000202  4770              BX       lr
;;;572    
                          ENDP

                  I2C_ReceiveData PROC
;;;579    *******************************************************************************/
;;;580    u8 I2C_ReceiveData(I2C_TypeDef* I2Cx)
000204  8a00              LDRH     r0,[r0,#0x10]
;;;581    {
;;;582      /* Check the parameters */
;;;583      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;584    
;;;585      /* Return the data in the DR register */
;;;586      return (u8)I2Cx->DR;
000206  b2c0              UXTB     r0,r0
;;;587    }
000208  4770              BX       lr
;;;588    
                          ENDP

                  I2C_Send7bitAddress PROC
;;;601    *******************************************************************************/
;;;602    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction)
00020a  2a00              CMP      r2,#0
;;;603    {
00020c  d002              BEQ      |L1.532|
;;;604      /* Check the parameters */
;;;605      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;606      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;607    
;;;608      /* Test on the direction to set/reset the read/write bit */
;;;609      if (I2C_Direction != I2C_Direction_Transmitter)
;;;610      {
;;;611        /* Set the address bit0 for read */
;;;612        Address |= OAR1_ADD0_Set;
00020e  f0410101          ORR      r1,r1,#1
000212  e001              B        |L1.536|
                  |L1.532|
;;;613      }
;;;614      else
;;;615      {
;;;616        /* Reset the address bit0 for write */
;;;617        Address &= OAR1_ADD0_Reset;
000214  f00101fe          AND      r1,r1,#0xfe
                  |L1.536|
;;;618      }
;;;619      /* Send the address */
;;;620      I2Cx->DR = Address;
000218  8201              STRH     r1,[r0,#0x10]
;;;621    }
00021a  4770              BX       lr
;;;622    
                          ENDP

                  I2C_ReadRegister PROC
;;;639    *******************************************************************************/
;;;640    u16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register)
00021c  5a40              LDRH     r0,[r0,r1]
;;;641    {
;;;642      /* Check the parameters */
;;;643      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;644      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;645    
;;;646      /* Return the selected register value */
;;;647      return (*(vu16 *)(*((vu32 *)&I2Cx) + I2C_Register));
;;;648    }
00021e  4770              BX       lr
;;;649    
                          ENDP

                  I2C_SoftwareResetCmd PROC
;;;658    *******************************************************************************/
;;;659    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000220  2900              CMP      r1,#0
;;;660    {
000222  d004              BEQ      |L1.558|
;;;661      /* Check the parameters */
;;;662      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;663      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;664    
;;;665      if (NewState != DISABLE)
;;;666      {
;;;667        /* Peripheral under reset */
;;;668        I2Cx->CR1 |= CR1_SWRST_Set;
000224  8801              LDRH     r1,[r0,#0]
000226  f4414100          ORR      r1,r1,#0x8000
00022a  8001              STRH     r1,[r0,#0]
;;;669      }
;;;670      else
;;;671      {
;;;672        /* Peripheral not under reset */
;;;673        I2Cx->CR1 &= CR1_SWRST_Reset;
;;;674      }
;;;675    }
00022c  4770              BX       lr
                  |L1.558|
00022e  8801              LDRH     r1,[r0,#0]            ;673
000230  f3c1010e          UBFX     r1,r1,#0,#15          ;673
000234  8001              STRH     r1,[r0,#0]            ;673
000236  4770              BX       lr
;;;676    
                          ENDP

                  I2C_SMBusAlertConfig PROC
;;;687    *******************************************************************************/
;;;688    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert)
000238  f5b15f00          CMP      r1,#0x2000
;;;689    {
00023c  d004              BEQ      |L1.584|
;;;690      /* Check the parameters */
;;;691      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;692      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;693    
;;;694      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
;;;695      {
;;;696        /* Drive the SMBusAlert pin Low */
;;;697        I2Cx->CR1 |= I2C_SMBusAlert_Low;
;;;698      }
;;;699      else
;;;700      {
;;;701        /* Drive the SMBusAlert pin High  */
;;;702        I2Cx->CR1 &= I2C_SMBusAlert_High;
00023e  8801              LDRH     r1,[r0,#0]
000240  f4215100          BIC      r1,r1,#0x2000
000244  8001              STRH     r1,[r0,#0]
;;;703      }
;;;704    }
000246  4770              BX       lr
                  |L1.584|
000248  8801              LDRH     r1,[r0,#0]            ;697
00024a  f4415100          ORR      r1,r1,#0x2000         ;697
00024e  8001              STRH     r1,[r0,#0]            ;697
000250  4770              BX       lr
;;;705    
                          ENDP

                  I2C_TransmitPEC PROC
;;;714    *******************************************************************************/
;;;715    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000252  2900              CMP      r1,#0
;;;716    {
000254  d004              BEQ      |L1.608|
;;;717      /* Check the parameters */
;;;718      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;719      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;720    
;;;721      if (NewState != DISABLE)
;;;722      {
;;;723        /* Enable the selected I2C PEC transmission */
;;;724        I2Cx->CR1 |= CR1_PEC_Set;
000256  8801              LDRH     r1,[r0,#0]
000258  f4415180          ORR      r1,r1,#0x1000
00025c  8001              STRH     r1,[r0,#0]
;;;725      }
;;;726      else
;;;727      {
;;;728        /* Disable the selected I2C PEC transmission */
;;;729        I2Cx->CR1 &= CR1_PEC_Reset;
;;;730      }
;;;731    }
00025e  4770              BX       lr
                  |L1.608|
000260  8801              LDRH     r1,[r0,#0]            ;729
000262  f4215180          BIC      r1,r1,#0x1000         ;729
000266  8001              STRH     r1,[r0,#0]            ;729
000268  4770              BX       lr
;;;732    
                          ENDP

                  I2C_PECPositionConfig PROC
;;;745    *******************************************************************************/
;;;746    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition)
00026a  f5b16f00          CMP      r1,#0x800
;;;747    {
00026e  d004              BEQ      |L1.634|
;;;748      /* Check the parameters */
;;;749      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;750      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;751    
;;;752      if (I2C_PECPosition == I2C_PECPosition_Next)
;;;753      {
;;;754        /* Next byte in shift register is PEC */
;;;755        I2Cx->CR1 |= I2C_PECPosition_Next;
;;;756      }
;;;757      else
;;;758      {
;;;759        /* Current byte in shift register is PEC */
;;;760        I2Cx->CR1 &= I2C_PECPosition_Current;
000270  8801              LDRH     r1,[r0,#0]
000272  f4216100          BIC      r1,r1,#0x800
000276  8001              STRH     r1,[r0,#0]
;;;761      }
;;;762    }
000278  4770              BX       lr
                  |L1.634|
00027a  8801              LDRH     r1,[r0,#0]            ;755
00027c  f4416100          ORR      r1,r1,#0x800          ;755
000280  8001              STRH     r1,[r0,#0]            ;755
000282  4770              BX       lr
;;;763    
                          ENDP

                  I2C_CalculatePEC PROC
;;;773    *******************************************************************************/
;;;774    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000284  2900              CMP      r1,#0
;;;775    {
000286  d004              BEQ      |L1.658|
;;;776      /* Check the parameters */
;;;777      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;778      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;779    
;;;780      if (NewState != DISABLE)
;;;781      {
;;;782        /* Enable the selected I2C PEC calculation */
;;;783        I2Cx->CR1 |= CR1_ENPEC_Set;
000288  8801              LDRH     r1,[r0,#0]
00028a  f0410120          ORR      r1,r1,#0x20
00028e  8001              STRH     r1,[r0,#0]
;;;784      }
;;;785      else
;;;786      {
;;;787        /* Disable the selected I2C PEC calculation */
;;;788        I2Cx->CR1 &= CR1_ENPEC_Reset;
;;;789      }
;;;790    }
000290  4770              BX       lr
                  |L1.658|
000292  8801              LDRH     r1,[r0,#0]            ;788
000294  f0210120          BIC      r1,r1,#0x20           ;788
000298  8001              STRH     r1,[r0,#0]            ;788
00029a  4770              BX       lr
;;;791    
                          ENDP

                  I2C_GetPEC PROC
;;;798    *******************************************************************************/
;;;799    u8 I2C_GetPEC(I2C_TypeDef* I2Cx)
00029c  8b00              LDRH     r0,[r0,#0x18]
;;;800    {
;;;801      /* Check the parameters */
;;;802      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;803    
;;;804      /* Return the selected I2C PEC value */
;;;805      return ((I2Cx->SR2) >> 8);
00029e  0a00              LSRS     r0,r0,#8
;;;806    }
0002a0  4770              BX       lr
;;;807    
                          ENDP

                  I2C_ARPCmd PROC
;;;816    *******************************************************************************/
;;;817    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0002a2  2900              CMP      r1,#0
;;;818    {
0002a4  d004              BEQ      |L1.688|
;;;819      /* Check the parameters */
;;;820      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;821      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;822    
;;;823      if (NewState != DISABLE)
;;;824      {
;;;825        /* Enable the selected I2C ARP */
;;;826        I2Cx->CR1 |= CR1_ENARP_Set;
0002a6  8801              LDRH     r1,[r0,#0]
0002a8  f0410110          ORR      r1,r1,#0x10
0002ac  8001              STRH     r1,[r0,#0]
;;;827      }
;;;828      else
;;;829      {
;;;830        /* Disable the selected I2C ARP */
;;;831        I2Cx->CR1 &= CR1_ENARP_Reset;
;;;832      }
;;;833    }
0002ae  4770              BX       lr
                  |L1.688|
0002b0  8801              LDRH     r1,[r0,#0]            ;831
0002b2  f0210110          BIC      r1,r1,#0x10           ;831
0002b6  8001              STRH     r1,[r0,#0]            ;831
0002b8  4770              BX       lr
;;;834    
                          ENDP

                  I2C_StretchClockCmd PROC
;;;843    *******************************************************************************/
;;;844    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0002ba  2900              CMP      r1,#0
;;;845    {
0002bc  d004              BEQ      |L1.712|
;;;846      /* Check the parameters */
;;;847      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;848      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;849    
;;;850      if (NewState == DISABLE)
;;;851      {
;;;852        /* Enable the selected I2C Clock stretching */
;;;853        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
;;;854      }
;;;855      else
;;;856      {
;;;857        /* Disable the selected I2C Clock stretching */
;;;858        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
0002be  8801              LDRH     r1,[r0,#0]
0002c0  f0210180          BIC      r1,r1,#0x80
0002c4  8001              STRH     r1,[r0,#0]
;;;859      }
;;;860    }
0002c6  4770              BX       lr
                  |L1.712|
0002c8  8801              LDRH     r1,[r0,#0]            ;853
0002ca  f0410180          ORR      r1,r1,#0x80           ;853
0002ce  8001              STRH     r1,[r0,#0]            ;853
0002d0  4770              BX       lr
;;;861    
                          ENDP

                  I2C_FastModeDutyCycleConfig PROC
;;;872    *******************************************************************************/
;;;873    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle)
0002d2  f5b14f80          CMP      r1,#0x4000
;;;874    {
0002d6  d004              BEQ      |L1.738|
;;;875      /* Check the parameters */
;;;876      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;877      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;878    
;;;879      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
;;;880      {
;;;881        /* I2C fast mode Tlow/Thigh=2 */
;;;882        I2Cx->CCR &= I2C_DutyCycle_2;
0002d8  8b81              LDRH     r1,[r0,#0x1c]
0002da  f4214180          BIC      r1,r1,#0x4000
0002de  8381              STRH     r1,[r0,#0x1c]
;;;883      }
;;;884      else
;;;885      {
;;;886        /* I2C fast mode Tlow/Thigh=16/9 */
;;;887        I2Cx->CCR |= I2C_DutyCycle_16_9;
;;;888      }
;;;889    }
0002e0  4770              BX       lr
                  |L1.738|
0002e2  8b81              LDRH     r1,[r0,#0x1c]         ;887
0002e4  f4414180          ORR      r1,r1,#0x4000         ;887
0002e8  8381              STRH     r1,[r0,#0x1c]         ;887
0002ea  4770              BX       lr
;;;890    
                          ENDP

                  I2C_GetLastEvent PROC
;;;897    *******************************************************************************/
;;;898    u32 I2C_GetLastEvent(I2C_TypeDef* I2Cx)
0002ec  8a81              LDRH     r1,[r0,#0x14]
;;;899    {
;;;900      u32 lastevent = 0;
;;;901      u32 flag1 = 0, flag2 = 0;
;;;902    
;;;903      /* Check the parameters */
;;;904      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;905    
;;;906      /* Read the I2Cx status register */
;;;907      flag1 = I2Cx->SR1;
;;;908      flag2 = I2Cx->SR2;
0002ee  8b00              LDRH     r0,[r0,#0x18]
;;;909      flag2 = flag2 << 16;
0002f0  0400              LSLS     r0,r0,#16
;;;910    
;;;911      /* Get the last event value from I2C status register */
;;;912      lastevent = (flag1 | flag2) & FLAG_Mask;
0002f2  4308              ORRS     r0,r0,r1
0002f4  f020407f          BIC      r0,r0,#0xff000000
;;;913    
;;;914      /* Return status */
;;;915      return lastevent;
;;;916    }
0002f8  4770              BX       lr
;;;917    
                          ENDP

                  I2C_CheckEvent PROC
;;;939    *******************************************************************************/
;;;940    ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT)
0002fa  2200              MOVS     r2,#0
;;;941    {
;;;942      u32 lastevent = 0;
;;;943      u32 flag1 = 0, flag2 = 0;
;;;944      ErrorStatus status = ERROR;
;;;945    
;;;946      /* Check the parameters */
;;;947      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;948      assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;949    
;;;950      /* Read the I2Cx status register */
;;;951      flag1 = I2Cx->SR1;
0002fc  8a83              LDRH     r3,[r0,#0x14]
;;;952      flag2 = I2Cx->SR2;
0002fe  8b00              LDRH     r0,[r0,#0x18]
;;;953      flag2 = flag2 << 16;
000300  0400              LSLS     r0,r0,#16
;;;954    
;;;955      /* Get the last event value from I2C status register */
;;;956      lastevent = (flag1 | flag2) & FLAG_Mask;
000302  4318              ORRS     r0,r0,r3
000304  f020407f          BIC      r0,r0,#0xff000000
;;;957    
;;;958      /* Check whether the last event is equal to I2C_EVENT */
;;;959      if (lastevent == I2C_EVENT )
000308  4288              CMP      r0,r1
00030a  d100              BNE      |L1.782|
;;;960      {
;;;961        /* SUCCESS: last event is equal to I2C_EVENT */
;;;962        status = SUCCESS;
00030c  2201              MOVS     r2,#1
                  |L1.782|
;;;963      }
;;;964      else
;;;965      {
;;;966        /* ERROR: last event is different from I2C_EVENT */
;;;967        status = ERROR;
;;;968      }
;;;969    
;;;970      /* Return status */
;;;971      return status;
00030e  4610              MOV      r0,r2
;;;972    }
000310  4770              BX       lr
;;;973    
                          ENDP

                  I2C_GetFlagStatus PROC
;;;1004   *******************************************************************************/
;;;1005   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
000312  2200              MOVS     r2,#0
;;;1006   {
;;;1007     FlagStatus bitstatus = RESET;
;;;1008     u32 i2cstatus = 0;
;;;1009     u32 flag1 = 0, flag2 = 0;
;;;1010   
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1013     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1014   
;;;1015     /* Read the I2Cx status register */
;;;1016     flag1 = I2Cx->SR1;
000314  8a83              LDRH     r3,[r0,#0x14]
;;;1017     flag2 = I2Cx->SR2;
000316  8b00              LDRH     r0,[r0,#0x18]
;;;1018     flag2 = (flag2 & FLAG_Mask) << 16;
000318  0400              LSLS     r0,r0,#16
;;;1019   
;;;1020     /* Get the I2C status value */
;;;1021     i2cstatus = flag1 | flag2;
00031a  4318              ORRS     r0,r0,r3
;;;1022   
;;;1023     /* Get bit[23:0] of the flag */
;;;1024     I2C_FLAG &= FLAG_Mask;
00031c  f021417f          BIC      r1,r1,#0xff000000
;;;1025   
;;;1026     /* Check the status of the specified I2C flag */
;;;1027     if ((i2cstatus & I2C_FLAG) != (u32)RESET)
000320  4208              TST      r0,r1
000322  d000              BEQ      |L1.806|
;;;1028     {
;;;1029       /* I2C_FLAG is set */
;;;1030       bitstatus = SET;
000324  2201              MOVS     r2,#1
                  |L1.806|
;;;1031     }
;;;1032     else
;;;1033     {
;;;1034       /* I2C_FLAG is reset */
;;;1035       bitstatus = RESET;
;;;1036     }
;;;1037     /* Return the I2C_FLAG status */
;;;1038     return  bitstatus;
000326  4610              MOV      r0,r2
;;;1039   }
000328  4770              BX       lr
;;;1040   
                          ENDP

                  I2C_ClearFlag PROC
;;;1062   *******************************************************************************/
;;;1063   void I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG)
00032a  f021427f          BIC      r2,r1,#0xff000000
;;;1064   {
;;;1065     u32 flagpos = 0;
;;;1066     u32 flagindex = 0;
;;;1067   
;;;1068     /* Check the parameters */
;;;1069     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1070     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1071   
;;;1072     /* Get the I2C flag position */
;;;1073     flagpos = I2C_FLAG & FLAG_Mask;
;;;1074   
;;;1075     /* Get the I2C flag index */
;;;1076     flagindex = I2C_FLAG >> 28;
00032e  0f09              LSRS     r1,r1,#28
;;;1077   
;;;1078     /* Clear the flag by writing 0 */
;;;1079     if (flagindex == 1)
000330  2901              CMP      r1,#1
000332  d006              BEQ      |L1.834|
;;;1080     {
;;;1081       /* Clear the selected I2C flag */
;;;1082       I2Cx->SR1 = (u16)~flagpos;
;;;1083     }
;;;1084     /* Flags that need a read of the SR1 register to be cleared */
;;;1085     else if (flagindex == 2)
000334  2902              CMP      r1,#2
000336  d007              BEQ      |L1.840|
;;;1086     {
;;;1087       /* Read the SR1 register */
;;;1088       (void)I2Cx->SR1;
;;;1089     }
;;;1090     /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
;;;1091     else if (flagindex == 6)
000338  2906              CMP      r1,#6
00033a  d007              BEQ      |L1.844|
;;;1092     {
;;;1093       /* Read the SR1 register */
;;;1094       (void)I2Cx->SR1;
;;;1095   
;;;1096       /* Write on the CR1 register */
;;;1097       I2Cx->CR1 |= CR1_PE_Set;
;;;1098     }
;;;1099     /* Flags that need a read of SR1 and SR2 registers to be cleared */
;;;1100     else /*flagindex == 0xA*/
;;;1101     {
;;;1102       /* Read the SR1 register */
;;;1103       (void)I2Cx->SR1;
00033c  8a81              LDRH     r1,[r0,#0x14]
;;;1104   
;;;1105       /* Read the SR2 register */
;;;1106       (void)I2Cx->SR2;
00033e  8b00              LDRH     r0,[r0,#0x18]
;;;1107     }
;;;1108   }
000340  4770              BX       lr
                  |L1.834|
000342  43d1              MVNS     r1,r2                 ;1082
000344  8281              STRH     r1,[r0,#0x14]         ;1082
000346  4770              BX       lr
                  |L1.840|
000348  8a80              LDRH     r0,[r0,#0x14]         ;1088
00034a  4770              BX       lr
                  |L1.844|
00034c  8a81              LDRH     r1,[r0,#0x14]         ;1094
00034e  8801              LDRH     r1,[r0,#0]            ;1097
000350  f0410101          ORR      r1,r1,#1              ;1097
000354  8001              STRH     r1,[r0,#0]            ;1097
000356  4770              BX       lr
;;;1109   
                          ENDP

                  I2C_GetITStatus PROC
;;;1133   *******************************************************************************/
;;;1134   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT)
000358  2200              MOVS     r2,#0
;;;1135   {
;;;1136     ITStatus bitstatus = RESET;
;;;1137     u32 i2cstatus = 0;
;;;1138     u32 flag1 = 0, flag2 = 0;
;;;1139   
;;;1140     /* Check the parameters */
;;;1141     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1142     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1143   
;;;1144     /* Read the I2Cx status register */
;;;1145     flag1 = I2Cx->SR1;
00035a  8a83              LDRH     r3,[r0,#0x14]
;;;1146     flag2 = I2Cx->SR2;
00035c  8b00              LDRH     r0,[r0,#0x18]
;;;1147     flag2 = (flag2 & FLAG_Mask) << 16;
00035e  0400              LSLS     r0,r0,#16
;;;1148   
;;;1149     /* Get the I2C status value */
;;;1150     i2cstatus = flag1 | flag2;
000360  4318              ORRS     r0,r0,r3
;;;1151   
;;;1152     /* Get bit[23:0] of the flag */
;;;1153     I2C_IT &= FLAG_Mask;
000362  f021417f          BIC      r1,r1,#0xff000000
;;;1154   
;;;1155     /* Check the status of the specified I2C flag */
;;;1156     if ((i2cstatus & I2C_IT) != (u32)RESET)
000366  4208              TST      r0,r1
000368  d000              BEQ      |L1.876|
;;;1157     {
;;;1158       /* I2C_IT is set */
;;;1159       bitstatus = SET;
00036a  2201              MOVS     r2,#1
                  |L1.876|
;;;1160     }
;;;1161     else
;;;1162     {
;;;1163       /* I2C_IT is reset */
;;;1164       bitstatus = RESET;
;;;1165     }
;;;1166     /* Return the I2C_IT status */
;;;1167     return  bitstatus;
00036c  4610              MOV      r0,r2
;;;1168   }
00036e  4770              BX       lr
;;;1169   
                          ENDP

                  I2C_ClearITPendingBit PROC
;;;1191   *******************************************************************************/
;;;1192   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT)
000370  f021427f          BIC      r2,r1,#0xff000000
;;;1193   {
;;;1194     u32 flagpos = 0;
;;;1195     u32 flagindex = 0;
;;;1196   
;;;1197     /* Check the parameters */
;;;1198     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1199     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1200   
;;;1201     /* Get the I2C flag position */
;;;1202     flagpos = I2C_IT & FLAG_Mask;
;;;1203   
;;;1204     /* Get the I2C flag index */
;;;1205     flagindex = I2C_IT >> 28;
000374  0f09              LSRS     r1,r1,#28
;;;1206   
;;;1207     /* Clear the flag by writing 0 */
;;;1208     if (flagindex == 1)
000376  2901              CMP      r1,#1
000378  d006              BEQ      |L1.904|
;;;1209     {
;;;1210       /* Clear the selected I2C flag */
;;;1211       I2Cx->SR1 = (u16)~flagpos;
;;;1212     }
;;;1213     /* Flags that need a read of the SR1 register to be cleared */
;;;1214     else if (flagindex == 2)
00037a  2902              CMP      r1,#2
00037c  d007              BEQ      |L1.910|
;;;1215     {
;;;1216       /* Read the SR1 register */
;;;1217       (void)I2Cx->SR1;
;;;1218     }
;;;1219     /* Flags that need a read of SR1 and a write on CR1 registers to be cleared */
;;;1220     else if (flagindex == 6)
00037e  2906              CMP      r1,#6
000380  d007              BEQ      |L1.914|
;;;1221     {
;;;1222       /* Read the SR1 register */
;;;1223       (void)I2Cx->SR1;
;;;1224   
;;;1225       /* Write on the CR1 register */
;;;1226       I2Cx->CR1 |= CR1_PE_Set;
;;;1227     }
;;;1228     /* Flags that need a read of SR1 and SR2 registers to be cleared */
;;;1229     else /*flagindex == 0xA*/
;;;1230     {
;;;1231       /* Read the SR1 register */
;;;1232       (void)I2Cx->SR1;
000382  8a81              LDRH     r1,[r0,#0x14]
;;;1233   
;;;1234       /* Read the SR2 register */
;;;1235       (void)I2Cx->SR2;
000384  8b00              LDRH     r0,[r0,#0x18]
;;;1236     }
;;;1237   }
000386  4770              BX       lr
                  |L1.904|
000388  43d1              MVNS     r1,r2                 ;1211
00038a  8281              STRH     r1,[r0,#0x14]         ;1211
00038c  4770              BX       lr
                  |L1.910|
00038e  8a80              LDRH     r0,[r0,#0x14]         ;1217
000390  4770              BX       lr
                  |L1.914|
000392  8a81              LDRH     r1,[r0,#0x14]         ;1223
000394  8801              LDRH     r1,[r0,#0]            ;1226
000396  f0410101          ORR      r1,r1,#1              ;1226
00039a  8001              STRH     r1,[r0,#0]            ;1226
00039c  4770              BX       lr
;;;1238   
                          ENDP

00039e  0000              DCW      0x0000
                  |L1.928|
                          DCD      0x000f4240
                  |L1.932|
                          DCD      0x000186a0
