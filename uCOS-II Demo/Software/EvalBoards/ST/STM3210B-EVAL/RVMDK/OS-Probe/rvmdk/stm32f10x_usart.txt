; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\rvmdk\stm32f10x_usart.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime --diag_suppress=9931 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I.\RTE\_Flash -I"C:\Program Files\0Software\Keil_v5\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"C:\Program Files\0Software\Keil_v5\ARM\CMSIS\Include" -I"C:\Program Files\0Software\Keil_v5\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0" -D__MICROLIB -D__UVISION_VERSION=528 -DSTM32F10X_MD --omf_browse=.\rvmdk\stm32f10x_usart.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;91     *******************************************************************************/
;;;92     void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;93     {
;;;94       /* Check the parameters */
;;;95       assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;96     
;;;97       switch (*(u32*)&USARTx)
000002  4acf              LDR      r2,|L1.832|
000004  1a81              SUBS     r1,r0,r2
000006  4290              CMP      r0,r2
000008  d02f              BEQ      |L1.106|
00000a  dc12              BGT      |L1.50|
00000c  f1a04080          SUB      r0,r0,#0x40000000
000010  f5b04088          SUBS     r0,r0,#0x4400
000014  d01e              BEQ      |L1.84|
000016  f5b06f80          CMP      r0,#0x400
00001a  d13c              BNE      |L1.150|
;;;98       {
;;;99         case USART1_BASE:
;;;100          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
;;;101          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
;;;102          break;
;;;103    
;;;104        case USART2_BASE:
;;;105          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
;;;106          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
;;;107          break;
;;;108    
;;;109        case USART3_BASE:
;;;110          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
00001c  2101              MOVS     r1,#1
00001e  0488              LSLS     r0,r1,#18
000020  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;111          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000024  e8bd4010          POP      {r4,lr}
000028  2100              MOVS     r1,#0
00002a  f44f2080          MOV      r0,#0x40000
00002e  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.50|
000032  f5b16f80          CMP      r1,#0x400             ;97
000036  d023              BEQ      |L1.128|
000038  f5b14f6c          CMP      r1,#0xec00            ;97
00003c  d12b              BNE      |L1.150|
00003e  2101              MOVS     r1,#1                 ;100
000040  0388              LSLS     r0,r1,#14             ;100
000042  f7fffffe          BL       RCC_APB2PeriphResetCmd
000046  e8bd4010          POP      {r4,lr}               ;101
00004a  2100              MOVS     r1,#0                 ;101
00004c  f44f4080          MOV      r0,#0x4000            ;101
000050  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.84|
000054  2101              MOVS     r1,#1                 ;105
000056  0448              LSLS     r0,r1,#17             ;105
000058  f7fffffe          BL       RCC_APB1PeriphResetCmd
00005c  e8bd4010          POP      {r4,lr}               ;106
000060  2100              MOVS     r1,#0                 ;106
000062  f44f3000          MOV      r0,#0x20000           ;106
000066  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.106|
;;;112          break;
;;;113        
;;;114        case UART4_BASE:
;;;115          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  04c8              LSLS     r0,r1,#19
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;116          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000072  e8bd4010          POP      {r4,lr}
000076  2100              MOVS     r1,#0
000078  f44f2000          MOV      r0,#0x80000
00007c  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.128|
;;;117          break;
;;;118        
;;;119        case UART5_BASE:
;;;120          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000080  2101              MOVS     r1,#1
000082  0508              LSLS     r0,r1,#20
000084  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;121          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000088  e8bd4010          POP      {r4,lr}
00008c  2100              MOVS     r1,#0
00008e  f44f1080          MOV      r0,#0x100000
000092  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.150|
;;;122          break;            
;;;123    
;;;124        default:
;;;125          break;
;;;126      }
;;;127    }
000096  bd10              POP      {r4,pc}
;;;128    
                          ENDP

                  USART_Init PROC
;;;141    *******************************************************************************/
;;;142    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000098  b530              PUSH     {r4,r5,lr}
;;;143    {
00009a  b085              SUB      sp,sp,#0x14
00009c  4604              MOV      r4,r0
00009e  460d              MOV      r5,r1
;;;144      u32 tmpreg = 0x00, apbclock = 0x00;
;;;145      u32 integerdivider = 0x00;
;;;146      u32 fractionaldivider = 0x00;
;;;147      u32 usartxbase = 0;
;;;148      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;149    
;;;150      /* Check the parameters */
;;;151      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;152      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;153      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;154      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;155      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;156      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;157      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;158      /* The hardware flow control is available only for USART1, USART2 and USART3 */          
;;;159      assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
;;;160      
;;;161      usartxbase = (*(u32*)&USARTx);
;;;162    
;;;163    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;164      tmpreg = USARTx->CR2;
0000a0  8a20              LDRH     r0,[r4,#0x10]
;;;165      /* Clear STOP[13:12] bits */
;;;166      tmpreg &= CR2_STOP_CLEAR_Mask;
0000a2  f64c71ff          MOV      r1,#0xcfff
0000a6  4008              ANDS     r0,r0,r1
;;;167    
;;;168      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;169      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;170      tmpreg |= (u32)USART_InitStruct->USART_StopBits;
0000a8  88e9              LDRH     r1,[r5,#6]
0000aa  4308              ORRS     r0,r0,r1
;;;171      
;;;172      /* Write to USART CR2 */
;;;173      USARTx->CR2 = (u16)tmpreg;
0000ac  8220              STRH     r0,[r4,#0x10]
;;;174    
;;;175    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;176      tmpreg = USARTx->CR1;
0000ae  89a0              LDRH     r0,[r4,#0xc]
;;;177      /* Clear M, PCE, PS, TE and RE bits */
;;;178      tmpreg &= CR1_CLEAR_Mask;
0000b0  f64e11f3          MOV      r1,#0xe9f3
0000b4  4008              ANDS     r0,r0,r1
;;;179    
;;;180      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;181      /* Set the M bits according to USART_WordLength value */
;;;182      /* Set PCE and PS bits according to USART_Parity value */
;;;183      /* Set TE and RE bits according to USART_Mode value */
;;;184      tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
0000b6  88a9              LDRH     r1,[r5,#4]
0000b8  892a              LDRH     r2,[r5,#8]
0000ba  4311              ORRS     r1,r1,r2
0000bc  896a              LDRH     r2,[r5,#0xa]
0000be  4310              ORRS     r0,r0,r2
0000c0  4308              ORRS     r0,r0,r1
;;;185                USART_InitStruct->USART_Mode;
;;;186    
;;;187      /* Write to USART CR1 */
;;;188      USARTx->CR1 = (u16)tmpreg;
0000c2  81a0              STRH     r0,[r4,#0xc]
;;;189    
;;;190    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;191      tmpreg = USARTx->CR3;
0000c4  8aa0              LDRH     r0,[r4,#0x14]
;;;192      /* Clear CTSE and RTSE bits */
;;;193      tmpreg &= CR3_CLEAR_Mask;
0000c6  f64f41ff          MOV      r1,#0xfcff
0000ca  4008              ANDS     r0,r0,r1
;;;194    
;;;195      /* Configure the USART HFC -------------------------------------------------*/
;;;196      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;197      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
0000cc  89a9              LDRH     r1,[r5,#0xc]
0000ce  4308              ORRS     r0,r0,r1
;;;198    
;;;199      /* Write to USART CR3 */
;;;200      USARTx->CR3 = (u16)tmpreg;
0000d0  82a0              STRH     r0,[r4,#0x14]
;;;201    
;;;202    /*---------------------------- USART BRR Configuration -----------------------*/
;;;203      /* Configure the USART Baud Rate -------------------------------------------*/
;;;204      RCC_GetClocksFreq(&RCC_ClocksStatus);
0000d2  4668              MOV      r0,sp
0000d4  f7fffffe          BL       RCC_GetClocksFreq
;;;205      if (usartxbase == USART1_BASE)
0000d8  f1a44080          SUB      r0,r4,#0x40000000
0000dc  f5b0309c          SUBS     r0,r0,#0x13800
0000e0  d01f              BEQ      |L1.290|
;;;206      {
;;;207        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
;;;208      }
;;;209      else
;;;210      {
;;;211        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
0000e2  9802              LDR      r0,[sp,#8]
                  |L1.228|
;;;212      }
;;;213    
;;;214      /* Determine the integer part */
;;;215      integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
0000e4  eb0001c0          ADD      r1,r0,r0,LSL #3
0000e8  eb011000          ADD      r0,r1,r0,LSL #4
0000ec  6829              LDR      r1,[r5,#0]
0000ee  0089              LSLS     r1,r1,#2
0000f0  fbb0f0f1          UDIV     r0,r0,r1
;;;216      tmpreg = (integerdivider / 0x64) << 0x04;
0000f4  4a93              LDR      r2,|L1.836|
0000f6  fba23100          UMULL    r3,r1,r2,r0
0000fa  0949              LSRS     r1,r1,#5
0000fc  0109              LSLS     r1,r1,#4
;;;217    
;;;218      /* Determine the fractional part */
;;;219      fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
0000fe  090b              LSRS     r3,r1,#4
000100  f06f0c18          MVN      r12,#0x18
000104  fb03f30c          MUL      r3,r3,r12
000108  eb000083          ADD      r0,r0,r3,LSL #2
;;;220      tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
00010c  2332              MOVS     r3,#0x32
00010e  eb031000          ADD      r0,r3,r0,LSL #4
000112  fba22000          UMULL    r2,r0,r2,r0
000116  f3c01043          UBFX     r0,r0,#5,#4
00011a  4308              ORRS     r0,r0,r1
;;;221    
;;;222      /* Write to USART BRR */
;;;223      USARTx->BRR = (u16)tmpreg;
00011c  8120              STRH     r0,[r4,#8]
;;;224    }
00011e  b005              ADD      sp,sp,#0x14
000120  bd30              POP      {r4,r5,pc}
                  |L1.290|
000122  9803              LDR      r0,[sp,#0xc]          ;207
000124  e7de              B        |L1.228|
;;;225    
                          ENDP

                  USART_StructInit PROC
;;;233    *******************************************************************************/
;;;234    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000126  f44f5116          MOV      r1,#0x2580
;;;235    {
;;;236      /* USART_InitStruct members default value */
;;;237      USART_InitStruct->USART_BaudRate = 9600;
00012a  6001              STR      r1,[r0,#0]
;;;238      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
00012c  2100              MOVS     r1,#0
00012e  8081              STRH     r1,[r0,#4]
;;;239      USART_InitStruct->USART_StopBits = USART_StopBits_1;
000130  80c1              STRH     r1,[r0,#6]
;;;240      USART_InitStruct->USART_Parity = USART_Parity_No ;
000132  8101              STRH     r1,[r0,#8]
;;;241      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000134  220c              MOVS     r2,#0xc
000136  8142              STRH     r2,[r0,#0xa]
;;;242      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000138  8181              STRH     r1,[r0,#0xc]
;;;243    }
00013a  4770              BX       lr
;;;244    
                          ENDP

                  USART_ClockInit PROC
;;;256    *******************************************************************************/
;;;257    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
00013c  8a02              LDRH     r2,[r0,#0x10]
;;;258    {
;;;259      u32 tmpreg = 0x00;
;;;260    
;;;261      /* Check the parameters */
;;;262      assert_param(IS_USART_123_PERIPH(USARTx));
;;;263      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;264      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;265      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;266      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
;;;267      
;;;268    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;269      tmpreg = USARTx->CR2;
;;;270      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;271      tmpreg &= CR2_CLOCK_CLEAR_Mask;
00013e  f24f03ff          MOV      r3,#0xf0ff
000142  401a              ANDS     r2,r2,r3
;;;272    
;;;273      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;274      /* Set CLKEN bit according to USART_Clock value */
;;;275      /* Set CPOL bit according to USART_CPOL value */
;;;276      /* Set CPHA bit according to USART_CPHA value */
;;;277      /* Set LBCL bit according to USART_LastBit value */
;;;278      tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
000144  880b              LDRH     r3,[r1,#0]
000146  f8b1c002          LDRH     r12,[r1,#2]
00014a  ea43030c          ORR      r3,r3,r12
00014e  f8b1c004          LDRH     r12,[r1,#4]
000152  88c9              LDRH     r1,[r1,#6]
000154  ea4c0101          ORR      r1,r12,r1
000158  4319              ORRS     r1,r1,r3
00015a  4311              ORRS     r1,r1,r2
;;;279                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;280    
;;;281      /* Write to USART CR2 */
;;;282      USARTx->CR2 = (u16)tmpreg;
00015c  8201              STRH     r1,[r0,#0x10]
;;;283    }
00015e  4770              BX       lr
;;;284    
                          ENDP

                  USART_ClockStructInit PROC
;;;292    *******************************************************************************/
;;;293    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000160  2100              MOVS     r1,#0
;;;294    {
;;;295      /* USART_ClockInitStruct members default value */
;;;296      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000162  8001              STRH     r1,[r0,#0]
;;;297      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000164  8041              STRH     r1,[r0,#2]
;;;298      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000166  8081              STRH     r1,[r0,#4]
;;;299      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000168  80c1              STRH     r1,[r0,#6]
;;;300    }
00016a  4770              BX       lr
;;;301    
                          ENDP

                  USART_Cmd PROC
;;;312    *******************************************************************************/
;;;313    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
00016c  2900              CMP      r1,#0
;;;314    {
00016e  d004              BEQ      |L1.378|
;;;315      /* Check the parameters */
;;;316      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;317      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;318      
;;;319      if (NewState != DISABLE)
;;;320      {
;;;321        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;322        USARTx->CR1 |= CR1_UE_Set;
000170  8981              LDRH     r1,[r0,#0xc]
000172  f4415100          ORR      r1,r1,#0x2000
000176  8181              STRH     r1,[r0,#0xc]
;;;323      }
;;;324      else
;;;325      {
;;;326        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;327        USARTx->CR1 &= CR1_UE_Reset;
;;;328      }
;;;329    }
000178  4770              BX       lr
                  |L1.378|
00017a  8981              LDRH     r1,[r0,#0xc]          ;327
00017c  f4215100          BIC      r1,r1,#0x2000         ;327
000180  8181              STRH     r1,[r0,#0xc]          ;327
000182  4770              BX       lr
;;;330    
                          ENDP

                  USART_ITConfig PROC
;;;355    *******************************************************************************/
;;;356    void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
000184  f3c11342          UBFX     r3,r1,#5,#3
;;;357    {
;;;358      u32 usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;359      u32 usartxbase = 0x00;
;;;360    
;;;361      /* Check the parameters */
;;;362      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;363      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;364      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */     
;;;365      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;366    
;;;367      usartxbase = (*(u32*)&(USARTx));
;;;368    
;;;369      /* Get the USART register index */
;;;370      usartreg = (((u8)USART_IT) >> 0x05);
;;;371    
;;;372      /* Get the interrupt position */
;;;373      itpos = USART_IT & IT_Mask;
000188  f001011f          AND      r1,r1,#0x1f
;;;374    
;;;375      itmask = (((u32)0x01) << itpos);
00018c  f04f0c01          MOV      r12,#1
000190  fa0cf101          LSL      r1,r12,r1
;;;376        
;;;377      if (usartreg == 0x01) /* The IT is in CR1 register */
000194  2b01              CMP      r3,#1
000196  d007              BEQ      |L1.424|
;;;378      {
;;;379        usartxbase += 0x0C;
;;;380      }
;;;381      else if (usartreg == 0x02) /* The IT is in CR2 register */
000198  2b02              CMP      r3,#2
00019a  d007              BEQ      |L1.428|
;;;382      {
;;;383        usartxbase += 0x10;
;;;384      }
;;;385      else /* The IT is in CR3 register */
;;;386      {
;;;387        usartxbase += 0x14; 
00019c  3014              ADDS     r0,r0,#0x14
                  |L1.414|
;;;388      }
;;;389      if (NewState != DISABLE)
00019e  b13a              CBZ      r2,|L1.432|
;;;390      {
;;;391        *(vu32*)usartxbase  |= itmask;
0001a0  6802              LDR      r2,[r0,#0]
0001a2  4311              ORRS     r1,r1,r2
0001a4  6001              STR      r1,[r0,#0]
;;;392      }
;;;393      else
;;;394      {
;;;395        *(vu32*)usartxbase &= ~itmask;
;;;396      }
;;;397    }
0001a6  4770              BX       lr
                  |L1.424|
0001a8  300c              ADDS     r0,r0,#0xc            ;379
0001aa  e7f8              B        |L1.414|
                  |L1.428|
0001ac  3010              ADDS     r0,r0,#0x10           ;383
0001ae  e7f6              B        |L1.414|
                  |L1.432|
0001b0  6802              LDR      r2,[r0,#0]            ;395
0001b2  ea220101          BIC      r1,r2,r1              ;395
0001b6  6001              STR      r1,[r0,#0]            ;395
0001b8  4770              BX       lr
;;;398    
                          ENDP

                  USART_DMACmd PROC
;;;414    *******************************************************************************/
;;;415    void USART_DMACmd(USART_TypeDef* USARTx, u16 USART_DMAReq, FunctionalState NewState)
0001ba  2a00              CMP      r2,#0
;;;416    {
0001bc  d003              BEQ      |L1.454|
;;;417      /* Check the parameters */
;;;418      assert_param(IS_USART_1234_PERIPH(USARTx));
;;;419      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;420      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;421    
;;;422      if (NewState != DISABLE)
;;;423      {
;;;424        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;425           DMAR bits in the USART CR3 register */
;;;426        USARTx->CR3 |= USART_DMAReq;
0001be  8a82              LDRH     r2,[r0,#0x14]
0001c0  4311              ORRS     r1,r1,r2
0001c2  8281              STRH     r1,[r0,#0x14]
;;;427      }
;;;428      else
;;;429      {
;;;430        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;431           DMAR bits in the USART CR3 register */
;;;432        USARTx->CR3 &= (u16)~USART_DMAReq;
;;;433      }
;;;434    }
0001c4  4770              BX       lr
                  |L1.454|
0001c6  8a82              LDRH     r2,[r0,#0x14]         ;432
0001c8  ea220101          BIC      r1,r2,r1              ;432
0001cc  8281              STRH     r1,[r0,#0x14]         ;432
0001ce  4770              BX       lr
;;;435    
                          ENDP

                  USART_SetAddress PROC
;;;445    *******************************************************************************/
;;;446    void USART_SetAddress(USART_TypeDef* USARTx, u8 USART_Address)
0001d0  8a02              LDRH     r2,[r0,#0x10]
;;;447    {
;;;448      /* Check the parameters */
;;;449      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;450      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;451        
;;;452      /* Clear the USART address */
;;;453      USARTx->CR2 &= CR2_Address_Mask;
0001d2  f022020f          BIC      r2,r2,#0xf
0001d6  8202              STRH     r2,[r0,#0x10]
;;;454      /* Set the USART address node */
;;;455      USARTx->CR2 |= USART_Address;
0001d8  8a02              LDRH     r2,[r0,#0x10]
0001da  4311              ORRS     r1,r1,r2
0001dc  8201              STRH     r1,[r0,#0x10]
;;;456    }
0001de  4770              BX       lr
;;;457    
                          ENDP

                  USART_WakeUpConfig PROC
;;;470    *******************************************************************************/
;;;471    void USART_WakeUpConfig(USART_TypeDef* USARTx, u16 USART_WakeUp)
0001e0  8982              LDRH     r2,[r0,#0xc]
;;;472    {
;;;473      /* Check the parameters */
;;;474      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;475      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;476      
;;;477      USARTx->CR1 &= CR1_WAKE_Mask;
0001e2  f4226200          BIC      r2,r2,#0x800
0001e6  8182              STRH     r2,[r0,#0xc]
;;;478      USARTx->CR1 |= USART_WakeUp;
0001e8  8982              LDRH     r2,[r0,#0xc]
0001ea  4311              ORRS     r1,r1,r2
0001ec  8181              STRH     r1,[r0,#0xc]
;;;479    }
0001ee  4770              BX       lr
;;;480    
                          ENDP

                  USART_ReceiverWakeUpCmd PROC
;;;491    *******************************************************************************/
;;;492    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
0001f0  2900              CMP      r1,#0
;;;493    {
0001f2  d004              BEQ      |L1.510|
;;;494      /* Check the parameters */
;;;495      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;496      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;497      
;;;498      if (NewState != DISABLE)
;;;499      {
;;;500        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;501        USARTx->CR1 |= CR1_RWU_Set;
0001f4  8981              LDRH     r1,[r0,#0xc]
0001f6  f0410102          ORR      r1,r1,#2
0001fa  8181              STRH     r1,[r0,#0xc]
;;;502      }
;;;503      else
;;;504      {
;;;505        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;506        USARTx->CR1 &= CR1_RWU_Reset;
;;;507      }
;;;508    }
0001fc  4770              BX       lr
                  |L1.510|
0001fe  8981              LDRH     r1,[r0,#0xc]          ;506
000200  f0210102          BIC      r1,r1,#2              ;506
000204  8181              STRH     r1,[r0,#0xc]          ;506
000206  4770              BX       lr
;;;509    
                          ENDP

                  USART_LINBreakDetectLengthConfig PROC
;;;523    *******************************************************************************/
;;;524    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, u16 USART_LINBreakDetectLength)
000208  8a02              LDRH     r2,[r0,#0x10]
;;;525    {
;;;526      /* Check the parameters */
;;;527      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;528      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;529      
;;;530      USARTx->CR2 &= CR2_LBDL_Mask;
00020a  f0220220          BIC      r2,r2,#0x20
00020e  8202              STRH     r2,[r0,#0x10]
;;;531      USARTx->CR2 |= USART_LINBreakDetectLength;  
000210  8a02              LDRH     r2,[r0,#0x10]
000212  4311              ORRS     r1,r1,r2
000214  8201              STRH     r1,[r0,#0x10]
;;;532    }
000216  4770              BX       lr
;;;533    
                          ENDP

                  USART_LINCmd PROC
;;;544    *******************************************************************************/
;;;545    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000218  2900              CMP      r1,#0
;;;546    {
00021a  d004              BEQ      |L1.550|
;;;547      /* Check the parameters */
;;;548      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;549      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;550      
;;;551      if (NewState != DISABLE)
;;;552      {
;;;553        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;554        USARTx->CR2 |= CR2_LINEN_Set;
00021c  8a01              LDRH     r1,[r0,#0x10]
00021e  f4414180          ORR      r1,r1,#0x4000
000222  8201              STRH     r1,[r0,#0x10]
;;;555      }
;;;556      else
;;;557      {
;;;558        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;559        USARTx->CR2 &= CR2_LINEN_Reset;
;;;560      }
;;;561    }
000224  4770              BX       lr
                  |L1.550|
000226  8a01              LDRH     r1,[r0,#0x10]         ;559
000228  f4214180          BIC      r1,r1,#0x4000         ;559
00022c  8201              STRH     r1,[r0,#0x10]         ;559
00022e  4770              BX       lr
;;;562    
                          ENDP

                  USART_SendData PROC
;;;572    *******************************************************************************/
;;;573    void USART_SendData(USART_TypeDef* USARTx, u16 Data)
000230  f3c10108          UBFX     r1,r1,#0,#9
;;;574    {
;;;575      /* Check the parameters */
;;;576      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;577      assert_param(IS_USART_DATA(Data)); 
;;;578        
;;;579      /* Transmit Data */
;;;580      USARTx->DR = (Data & (u16)0x01FF);
000234  8081              STRH     r1,[r0,#4]
;;;581    }
000236  4770              BX       lr
;;;582    
                          ENDP

                  USART_ReceiveData PROC
;;;591    *******************************************************************************/
;;;592    u16 USART_ReceiveData(USART_TypeDef* USARTx)
000238  8880              LDRH     r0,[r0,#4]
;;;593    {
;;;594      /* Check the parameters */
;;;595      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;596      
;;;597      /* Receive Data */
;;;598      return (u16)(USARTx->DR & (u16)0x01FF);
00023a  f3c00008          UBFX     r0,r0,#0,#9
;;;599    }
00023e  4770              BX       lr
;;;600    
                          ENDP

                  USART_SendBreak PROC
;;;609    *******************************************************************************/
;;;610    void USART_SendBreak(USART_TypeDef* USARTx)
000240  8981              LDRH     r1,[r0,#0xc]
;;;611    {
;;;612      /* Check the parameters */
;;;613      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;614      
;;;615      /* Send break characters */
;;;616      USARTx->CR1 |= CR1_SBK_Set;
000242  f0410101          ORR      r1,r1,#1
000246  8181              STRH     r1,[r0,#0xc]
;;;617    }
000248  4770              BX       lr
;;;618    
                          ENDP

                  USART_SetGuardTime PROC
;;;628    *******************************************************************************/
;;;629    void USART_SetGuardTime(USART_TypeDef* USARTx, u8 USART_GuardTime)
00024a  8b02              LDRH     r2,[r0,#0x18]
;;;630    {    
;;;631      /* Check the parameters */
;;;632      assert_param(IS_USART_123_PERIPH(USARTx));
;;;633      
;;;634      /* Clear the USART Guard time */
;;;635      USARTx->GTPR &= GTPR_LSB_Mask;
00024c  b2d2              UXTB     r2,r2
00024e  8302              STRH     r2,[r0,#0x18]
;;;636      /* Set the USART guard time */
;;;637      USARTx->GTPR |= (u16)((u16)USART_GuardTime << 0x08);
000250  8b02              LDRH     r2,[r0,#0x18]
000252  ea422101          ORR      r1,r2,r1,LSL #8
000256  8301              STRH     r1,[r0,#0x18]
;;;638    }
000258  4770              BX       lr
;;;639    
                          ENDP

                  USART_SetPrescaler PROC
;;;650    *******************************************************************************/
;;;651    void USART_SetPrescaler(USART_TypeDef* USARTx, u8 USART_Prescaler)
00025a  8b02              LDRH     r2,[r0,#0x18]
;;;652    { 
;;;653      /* Check the parameters */
;;;654      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;655      
;;;656      /* Clear the USART prescaler */
;;;657      USARTx->GTPR &= GTPR_MSB_Mask;
00025c  f402427f          AND      r2,r2,#0xff00
000260  8302              STRH     r2,[r0,#0x18]
;;;658      /* Set the USART prescaler */
;;;659      USARTx->GTPR |= USART_Prescaler;
000262  8b02              LDRH     r2,[r0,#0x18]
000264  4311              ORRS     r1,r1,r2
000266  8301              STRH     r1,[r0,#0x18]
;;;660    }
000268  4770              BX       lr
;;;661    
                          ENDP

                  USART_SmartCardCmd PROC
;;;672    *******************************************************************************/
;;;673    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00026a  2900              CMP      r1,#0
;;;674    {
00026c  d004              BEQ      |L1.632|
;;;675      /* Check the parameters */
;;;676      assert_param(IS_USART_123_PERIPH(USARTx));
;;;677      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;678    
;;;679      if (NewState != DISABLE)
;;;680      {
;;;681        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;682        USARTx->CR3 |= CR3_SCEN_Set;
00026e  8a81              LDRH     r1,[r0,#0x14]
000270  f0410120          ORR      r1,r1,#0x20
000274  8281              STRH     r1,[r0,#0x14]
;;;683      }
;;;684      else
;;;685      {
;;;686        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;687        USARTx->CR3 &= CR3_SCEN_Reset;
;;;688      }
;;;689    }
000276  4770              BX       lr
                  |L1.632|
000278  8a81              LDRH     r1,[r0,#0x14]         ;687
00027a  f0210120          BIC      r1,r1,#0x20           ;687
00027e  8281              STRH     r1,[r0,#0x14]         ;687
000280  4770              BX       lr
;;;690    
                          ENDP

                  USART_SmartCardNACKCmd PROC
;;;701    *******************************************************************************/
;;;702    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000282  2900              CMP      r1,#0
;;;703    {
000284  d004              BEQ      |L1.656|
;;;704      /* Check the parameters */
;;;705      assert_param(IS_USART_123_PERIPH(USARTx));  
;;;706      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;707    
;;;708      if (NewState != DISABLE)
;;;709      {
;;;710        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;711        USARTx->CR3 |= CR3_NACK_Set;
000286  8a81              LDRH     r1,[r0,#0x14]
000288  f0410110          ORR      r1,r1,#0x10
00028c  8281              STRH     r1,[r0,#0x14]
;;;712      }
;;;713      else
;;;714      {
;;;715        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;716        USARTx->CR3 &= CR3_NACK_Reset;
;;;717      }
;;;718    }
00028e  4770              BX       lr
                  |L1.656|
000290  8a81              LDRH     r1,[r0,#0x14]         ;716
000292  f0210110          BIC      r1,r1,#0x10           ;716
000296  8281              STRH     r1,[r0,#0x14]         ;716
000298  4770              BX       lr
;;;719    
                          ENDP

                  USART_HalfDuplexCmd PROC
;;;730    *******************************************************************************/
;;;731    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
00029a  2900              CMP      r1,#0
;;;732    {
00029c  d004              BEQ      |L1.680|
;;;733      /* Check the parameters */
;;;734      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;735      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;736      
;;;737      if (NewState != DISABLE)
;;;738      {
;;;739        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;740        USARTx->CR3 |= CR3_HDSEL_Set;
00029e  8a81              LDRH     r1,[r0,#0x14]
0002a0  f0410108          ORR      r1,r1,#8
0002a4  8281              STRH     r1,[r0,#0x14]
;;;741      }
;;;742      else
;;;743      {
;;;744        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;745        USARTx->CR3 &= CR3_HDSEL_Reset;
;;;746      }
;;;747    }
0002a6  4770              BX       lr
                  |L1.680|
0002a8  8a81              LDRH     r1,[r0,#0x14]         ;745
0002aa  f0210108          BIC      r1,r1,#8              ;745
0002ae  8281              STRH     r1,[r0,#0x14]         ;745
0002b0  4770              BX       lr
;;;748    
                          ENDP

                  USART_IrDAConfig PROC
;;;761    *******************************************************************************/
;;;762    void USART_IrDAConfig(USART_TypeDef* USARTx, u16 USART_IrDAMode)
0002b2  8a82              LDRH     r2,[r0,#0x14]
;;;763    {
;;;764      /* Check the parameters */
;;;765      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;766      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;767        
;;;768      USARTx->CR3 &= CR3_IRLP_Mask;
0002b4  f0220204          BIC      r2,r2,#4
0002b8  8282              STRH     r2,[r0,#0x14]
;;;769      USARTx->CR3 |= USART_IrDAMode;
0002ba  8a82              LDRH     r2,[r0,#0x14]
0002bc  4311              ORRS     r1,r1,r2
0002be  8281              STRH     r1,[r0,#0x14]
;;;770    }
0002c0  4770              BX       lr
;;;771    
                          ENDP

                  USART_IrDACmd PROC
;;;782    *******************************************************************************/
;;;783    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
0002c2  2900              CMP      r1,#0
;;;784    {
0002c4  d004              BEQ      |L1.720|
;;;785      /* Check the parameters */
;;;786      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;787      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;788        
;;;789      if (NewState != DISABLE)
;;;790      {
;;;791        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;792        USARTx->CR3 |= CR3_IREN_Set;
0002c6  8a81              LDRH     r1,[r0,#0x14]
0002c8  f0410102          ORR      r1,r1,#2
0002cc  8281              STRH     r1,[r0,#0x14]
;;;793      }
;;;794      else
;;;795      {
;;;796        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;797        USARTx->CR3 &= CR3_IREN_Reset;
;;;798      }
;;;799    }
0002ce  4770              BX       lr
                  |L1.720|
0002d0  8a81              LDRH     r1,[r0,#0x14]         ;797
0002d2  f0210102          BIC      r1,r1,#2              ;797
0002d6  8281              STRH     r1,[r0,#0x14]         ;797
0002d8  4770              BX       lr
;;;800    
                          ENDP

                  USART_GetFlagStatus PROC
;;;822    *******************************************************************************/
;;;823    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG)
0002da  4602              MOV      r2,r0
;;;824    {
;;;825      FlagStatus bitstatus = RESET;
0002dc  2000              MOVS     r0,#0
;;;826    
;;;827      /* Check the parameters */
;;;828      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;829      assert_param(IS_USART_FLAG(USART_FLAG));
;;;830      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;831    
;;;832      if ((USARTx->SR & USART_FLAG) != (u16)RESET)
0002de  8812              LDRH     r2,[r2,#0]
0002e0  420a              TST      r2,r1
0002e2  d000              BEQ      |L1.742|
;;;833      {
;;;834        bitstatus = SET;
0002e4  2001              MOVS     r0,#1
                  |L1.742|
;;;835      }
;;;836      else
;;;837      {
;;;838        bitstatus = RESET;
;;;839      }
;;;840      return bitstatus;
;;;841    }
0002e6  4770              BX       lr
;;;842    
                          ENDP

                  USART_ClearFlag PROC
;;;868    *******************************************************************************/
;;;869    void USART_ClearFlag(USART_TypeDef* USARTx, u16 USART_FLAG)
0002e8  43c9              MVNS     r1,r1
;;;870    {
;;;871      /* Check the parameters */
;;;872      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;873      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;874      assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
;;;875       
;;;876      USARTx->SR = (u16)~USART_FLAG;
0002ea  8001              STRH     r1,[r0,#0]
;;;877    }
0002ec  4770              BX       lr
;;;878    
                          ENDP

                  USART_GetITStatus PROC
;;;901    *******************************************************************************/
;;;902    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT)
0002ee  b410              PUSH     {r4}
;;;903    {
;;;904      u32 bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;905      ITStatus bitstatus = RESET;
0002f0  f04f0c00          MOV      r12,#0
;;;906    
;;;907      /* Check the parameters */
;;;908      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;909      assert_param(IS_USART_IT(USART_IT));
;;;910      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
;;;911      
;;;912      /* Get the USART register index */
;;;913      usartreg = (((u8)USART_IT) >> 0x05);
0002f4  f3c11342          UBFX     r3,r1,#5,#3
;;;914    
;;;915      /* Get the interrupt position */
;;;916      itmask = USART_IT & IT_Mask;
0002f8  f001021f          AND      r2,r1,#0x1f
;;;917    
;;;918      itmask = (u32)0x01 << itmask;
0002fc  2401              MOVS     r4,#1
0002fe  fa04f202          LSL      r2,r4,r2
;;;919      
;;;920      if (usartreg == 0x01) /* The IT  is in CR1 register */
000302  2b01              CMP      r3,#1
000304  d00f              BEQ      |L1.806|
;;;921      {
;;;922        itmask &= USARTx->CR1;
;;;923      }
;;;924      else if (usartreg == 0x02) /* The IT  is in CR2 register */
000306  2b02              CMP      r3,#2
000308  d010              BEQ      |L1.812|
;;;925      {
;;;926        itmask &= USARTx->CR2;
;;;927      }
;;;928      else /* The IT  is in CR3 register */
;;;929      {
;;;930        itmask &= USARTx->CR3;
00030a  8a83              LDRH     r3,[r0,#0x14]
00030c  401a              ANDS     r2,r2,r3
                  |L1.782|
;;;931      }
;;;932      
;;;933      bitpos = USART_IT >> 0x08;
00030e  0a09              LSRS     r1,r1,#8
;;;934    
;;;935      bitpos = (u32)0x01 << bitpos;
000310  fa04f101          LSL      r1,r4,r1
;;;936      bitpos &= USARTx->SR;
000314  8800              LDRH     r0,[r0,#0]
000316  4008              ANDS     r0,r0,r1
;;;937    
;;;938      if ((itmask != (u16)RESET)&&(bitpos != (u16)RESET))
000318  b112              CBZ      r2,|L1.800|
00031a  b108              CBZ      r0,|L1.800|
;;;939      {
;;;940        bitstatus = SET;
00031c  f04f0c01          MOV      r12,#1
                  |L1.800|
;;;941      }
;;;942      else
;;;943      {
;;;944        bitstatus = RESET;
;;;945      }
;;;946      
;;;947      return bitstatus;  
;;;948    }
000320  bc10              POP      {r4}
000322  4660              MOV      r0,r12                ;947
000324  4770              BX       lr
                  |L1.806|
000326  8983              LDRH     r3,[r0,#0xc]          ;922
000328  401a              ANDS     r2,r2,r3              ;922
00032a  e7f0              B        |L1.782|
                  |L1.812|
00032c  8a03              LDRH     r3,[r0,#0x10]         ;926
00032e  401a              ANDS     r2,r2,r3              ;926
000330  e7ed              B        |L1.782|
;;;949    
                          ENDP

                  USART_ClearITPendingBit PROC
;;;975    *******************************************************************************/
;;;976    void USART_ClearITPendingBit(USART_TypeDef* USARTx, u16 USART_IT)
000332  0a09              LSRS     r1,r1,#8
;;;977    {
;;;978      u16 bitpos = 0x00, itmask = 0x00;
;;;979    
;;;980      /* Check the parameters */
;;;981      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;982      assert_param(IS_USART_CLEAR_IT(USART_IT));
;;;983      assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
;;;984      
;;;985      bitpos = USART_IT >> 0x08;
;;;986    
;;;987      itmask = (u16)((u16)0x01 << bitpos);
000334  2201              MOVS     r2,#1
000336  fa02f101          LSL      r1,r2,r1
;;;988      USARTx->SR = (u16)~itmask;
00033a  43c9              MVNS     r1,r1
00033c  8001              STRH     r1,[r0,#0]
;;;989    }
00033e  4770              BX       lr
;;;990    
                          ENDP

                  |L1.832|
                          DCD      0x40004c00
                  |L1.836|
                          DCD      0x51eb851f
