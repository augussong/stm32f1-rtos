; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\rvmdk\stm32f10x_tim.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime --diag_suppress=9931 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I.\RTE\_Flash -I"C:\Program Files\0Software\Keil_v5\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"C:\Program Files\0Software\Keil_v5\ARM\CMSIS\Include" -I"C:\Program Files\0Software\Keil_v5\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0" -D__MICROLIB -D__UVISION_VERSION=528 -DSTM32F10X_MD --omf_browse=.\rvmdk\stm32f10x_tim.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;135    *******************************************************************************/
;;;136    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;137    {
;;;138      /* Check the parameters */
;;;139      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;140     
;;;141      switch (*(u32*)&TIMx)
000002  4afc              LDR      r2,|L1.1012|
000004  1a81              SUBS     r1,r0,r2
000006  4290              CMP      r0,r2
000008  d055              BEQ      |L1.182|
00000a  dc17              BGT      |L1.60|
00000c  f1b04f80          CMP      r0,#0x40000000
000010  d033              BEQ      |L1.122|
000012  f1a04080          SUB      r0,r0,#0x40000000
000016  f5b06080          SUBS     r0,r0,#0x400
00001a  d038              BEQ      |L1.142|
00001c  f5b06f80          CMP      r0,#0x400
000020  d03f              BEQ      |L1.162|
000022  f5b06f00          CMP      r0,#0x800
000026  d15a              BNE      |L1.222|
;;;142      {
;;;143        case TIM1_BASE:
;;;144          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
;;;145          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
;;;146          break; 
;;;147          
;;;148        case TIM2_BASE:
;;;149          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;150          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;151          break;
;;;152     
;;;153        case TIM3_BASE:
;;;154          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
;;;155          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
;;;156          break;
;;;157     
;;;158        case TIM4_BASE:
;;;159          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
;;;160          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
;;;161          break;
;;;162          
;;;163        case TIM5_BASE:
;;;164          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000028  2101              MOVS     r1,#1
00002a  2008              MOVS     r0,#8
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;165          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000030  2100              MOVS     r1,#0
000032  e8bd4010          POP      {r4,lr}
000036  2008              MOVS     r0,#8
000038  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.60|
00003c  f5b16f80          CMP      r1,#0x400             ;141
000040  d043              BEQ      |L1.202|
000042  f5b13f8e          CMP      r1,#0x11c00           ;141
000046  d00d              BEQ      |L1.100|
000048  f5b13f92          CMP      r1,#0x12400           ;141
00004c  d147              BNE      |L1.222|
;;;166          break;
;;;167          
;;;168        case TIM6_BASE:
;;;169          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
;;;170          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
;;;171          break;
;;;172          
;;;173        case TIM7_BASE:
;;;174          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
;;;175          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
;;;176          break;
;;;177          
;;;178        case TIM8_BASE:
;;;179          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
00004e  2101              MOVS     r1,#1
000050  0348              LSLS     r0,r1,#13
000052  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;180          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
000056  e8bd4010          POP      {r4,lr}
00005a  2100              MOVS     r1,#0
00005c  f44f5000          MOV      r0,#0x2000
000060  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.100|
000064  2101              MOVS     r1,#1                 ;144
000066  02c8              LSLS     r0,r1,#11             ;144
000068  f7fffffe          BL       RCC_APB2PeriphResetCmd
00006c  e8bd4010          POP      {r4,lr}               ;145
000070  2100              MOVS     r1,#0                 ;145
000072  f44f6000          MOV      r0,#0x800             ;145
000076  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.122|
00007a  2101              MOVS     r1,#1                 ;149
00007c  4608              MOV      r0,r1                 ;149
00007e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000082  2100              MOVS     r1,#0                 ;150
000084  e8bd4010          POP      {r4,lr}               ;150
000088  2001              MOVS     r0,#1                 ;150
00008a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.142|
00008e  2101              MOVS     r1,#1                 ;154
000090  2002              MOVS     r0,#2                 ;154
000092  f7fffffe          BL       RCC_APB1PeriphResetCmd
000096  2100              MOVS     r1,#0                 ;155
000098  e8bd4010          POP      {r4,lr}               ;155
00009c  2002              MOVS     r0,#2                 ;155
00009e  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.162|
0000a2  2101              MOVS     r1,#1                 ;159
0000a4  2004              MOVS     r0,#4                 ;159
0000a6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000aa  2100              MOVS     r1,#0                 ;160
0000ac  e8bd4010          POP      {r4,lr}               ;160
0000b0  2004              MOVS     r0,#4                 ;160
0000b2  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.182|
0000b6  2101              MOVS     r1,#1                 ;169
0000b8  2010              MOVS     r0,#0x10              ;169
0000ba  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000be  2100              MOVS     r1,#0                 ;170
0000c0  e8bd4010          POP      {r4,lr}               ;170
0000c4  2010              MOVS     r0,#0x10              ;170
0000c6  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.202|
0000ca  2101              MOVS     r1,#1                 ;174
0000cc  2020              MOVS     r0,#0x20              ;174
0000ce  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000d2  2100              MOVS     r1,#0                 ;175
0000d4  e8bd4010          POP      {r4,lr}               ;175
0000d8  2020              MOVS     r0,#0x20              ;175
0000da  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L1.222|
;;;181          break; 
;;;182          
;;;183        default:
;;;184          break;
;;;185      }
;;;186    }
0000de  bd10              POP      {r4,pc}
;;;187    
                          ENDP

                  TIM_TimeBaseInit PROC
;;;199    *******************************************************************************/
;;;200    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
0000e0  8802              LDRH     r2,[r0,#0]
;;;201    {
;;;202      /* Check the parameters */
;;;203      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;204      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;205      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;206    
;;;207      /* Select the Counter Mode and set the clock division */
;;;208      TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
0000e2  f002028f          AND      r2,r2,#0x8f
0000e6  8002              STRH     r2,[r0,#0]
;;;209      TIMx->CR1 |= (u32)TIM_TimeBaseInitStruct->TIM_ClockDivision |
0000e8  88ca              LDRH     r2,[r1,#6]
0000ea  884b              LDRH     r3,[r1,#2]
0000ec  431a              ORRS     r2,r2,r3
0000ee  8803              LDRH     r3,[r0,#0]
0000f0  431a              ORRS     r2,r2,r3
0000f2  8002              STRH     r2,[r0,#0]
;;;210                    TIM_TimeBaseInitStruct->TIM_CounterMode;
;;;211      /* Set the Autoreload value */
;;;212      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
0000f4  888a              LDRH     r2,[r1,#4]
0000f6  8582              STRH     r2,[r0,#0x2c]
;;;213    
;;;214      /* Set the Prescaler value */
;;;215      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
0000f8  880a              LDRH     r2,[r1,#0]
0000fa  8502              STRH     r2,[r0,#0x28]
;;;216    
;;;217      /* Generate an update event to reload the Prescaler value immediatly */
;;;218      TIMx->EGR = TIM_PSCReloadMode_Immediate;
0000fc  2201              MOVS     r2,#1
0000fe  8282              STRH     r2,[r0,#0x14]
;;;219        
;;;220      if (((*(u32*)&TIMx) == TIM1_BASE) || ((*(u32*)&TIMx) == TIM8_BASE))  
000100  f1a04280          SUB      r2,r0,#0x40000000
000104  f5b23296          SUBS     r2,r2,#0x12c00
000108  d004              BEQ      |L1.276|
00010a  f1a04280          SUB      r2,r0,#0x40000000
00010e  f5b2329a          SUBS     r2,r2,#0x13400
000112  d101              BNE      |L1.280|
                  |L1.276|
;;;221      {
;;;222        /* Set the Repetition Counter value */
;;;223        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000114  7a09              LDRB     r1,[r1,#8]
000116  8601              STRH     r1,[r0,#0x30]
                  |L1.280|
;;;224      }        
;;;225    }
000118  4770              BX       lr
;;;226    
                          ENDP

                  TIM_OC1Init PROC
;;;238    *******************************************************************************/
;;;239    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
00011a  b410              PUSH     {r4}
;;;240    {
;;;241      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;242       
;;;243      /* Check the parameters */
;;;244      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;245      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;246      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;247      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;248    
;;;249      /* Disable the Channel 1: Reset the CC1E Bit */
;;;250      TIMx->CCER &= CCER_CC1E_Reset;
00011c  8c02              LDRH     r2,[r0,#0x20]
00011e  f0220201          BIC      r2,r2,#1
000122  8402              STRH     r2,[r0,#0x20]
;;;251      
;;;252      /* Get the TIMx CCER register value */
;;;253      tmpccer = TIMx->CCER;
000124  8c03              LDRH     r3,[r0,#0x20]
;;;254    
;;;255      /* Get the TIMx CR2 register value */
;;;256      tmpcr2 =  TIMx->CR2;
000126  8882              LDRH     r2,[r0,#4]
;;;257      
;;;258      /* Get the TIMx CCMR1 register value */
;;;259      tmpccmrx = TIMx->CCMR1;
000128  f8b0c018          LDRH     r12,[r0,#0x18]
;;;260        
;;;261      /* Reset the Output Compare Mode Bits */
;;;262      tmpccmrx &= CCMR_OC13M_Mask;
00012c  f02c0c70          BIC      r12,r12,#0x70
;;;263      
;;;264      /* Select the Output Compare Mode */
;;;265      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000130  880c              LDRH     r4,[r1,#0]
000132  ea440c0c          ORR      r12,r4,r12
;;;266      
;;;267      /* Reset the Output Polarity level */
;;;268      tmpccer &= CCER_CC1P_Reset;
000136  f0230302          BIC      r3,r3,#2
;;;269    
;;;270      /* Set the Output Compare Polarity */
;;;271      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00013a  890c              LDRH     r4,[r1,#8]
00013c  4323              ORRS     r3,r3,r4
;;;272      
;;;273      /* Set the Output State */
;;;274      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
00013e  884c              LDRH     r4,[r1,#2]
000140  4323              ORRS     r3,r3,r4
;;;275      
;;;276      /* Set the Capture Compare Register value */
;;;277      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
000142  88cc              LDRH     r4,[r1,#6]
000144  8684              STRH     r4,[r0,#0x34]
;;;278      
;;;279      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
000146  f1a04480          SUB      r4,r0,#0x40000000
00014a  f5b43496          SUBS     r4,r4,#0x12c00
00014e  d004              BEQ      |L1.346|
000150  f1a04480          SUB      r4,r0,#0x40000000
000154  f5b4349a          SUBS     r4,r4,#0x13400
000158  d10f              BNE      |L1.378|
                  |L1.346|
;;;280      {
;;;281        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;282        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;283        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;284        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;285        
;;;286        /* Reset the Output N Polarity level */
;;;287        tmpccer &= CCER_CC1NP_Reset;
00015a  f0230308          BIC      r3,r3,#8
;;;288    
;;;289        /* Set the Output N Polarity */
;;;290        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
00015e  894c              LDRH     r4,[r1,#0xa]
000160  4323              ORRS     r3,r3,r4
;;;291    
;;;292        /* Reset the Output N State */
;;;293        tmpccer &= CCER_CC1NE_Reset;
000162  f0230304          BIC      r3,r3,#4
;;;294        
;;;295        /* Set the Output N State */
;;;296        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000166  888c              LDRH     r4,[r1,#4]
000168  4323              ORRS     r3,r3,r4
;;;297    
;;;298        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;299        tmpcr2 &= CR2_OIS1_Reset;
00016a  f4224201          BIC      r2,r2,#0x8100
;;;300        tmpcr2 &= CR2_OIS1N_Reset;
00016e  f4224202          BIC      r2,r2,#0x8200
;;;301    
;;;302        /* Set the Output Idle state */
;;;303        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000172  898c              LDRH     r4,[r1,#0xc]
000174  4322              ORRS     r2,r2,r4
;;;304    
;;;305        /* Set the Output N Idle state */
;;;306        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000176  89c9              LDRH     r1,[r1,#0xe]
000178  430a              ORRS     r2,r2,r1
                  |L1.378|
;;;307      }
;;;308      /* Write to TIMx CR2 */
;;;309      TIMx->CR2 = tmpcr2;
00017a  8082              STRH     r2,[r0,#4]
;;;310      
;;;311      /* Write to TIMx CCMR1 */
;;;312      TIMx->CCMR1 = tmpccmrx;
00017c  f8a0c018          STRH     r12,[r0,#0x18]
;;;313      
;;;314      /* Write to TIMx CCER */
;;;315      TIMx->CCER = tmpccer;
000180  8403              STRH     r3,[r0,#0x20]
;;;316    }
000182  bc10              POP      {r4}
000184  4770              BX       lr
;;;317    
                          ENDP

                  TIM_OC2Init PROC
;;;329    *******************************************************************************/
;;;330    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000186  b430              PUSH     {r4,r5}
;;;331    {
;;;332      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;333       
;;;334      /* Check the parameters */
;;;335      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;336      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;337      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;338      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;339    
;;;340      /* Disable the Channel 2: Reset the CC2E Bit */
;;;341      TIMx->CCER &= CCER_CC2E_Reset;
000188  8c02              LDRH     r2,[r0,#0x20]
00018a  f0220210          BIC      r2,r2,#0x10
00018e  8402              STRH     r2,[r0,#0x20]
;;;342      
;;;343      /* Get the TIMx CCER register value */  
;;;344      tmpccer = TIMx->CCER;
000190  8c02              LDRH     r2,[r0,#0x20]
;;;345    
;;;346      /* Get the TIMx CR2 register value */
;;;347      tmpcr2 =  TIMx->CR2;
000192  8883              LDRH     r3,[r0,#4]
;;;348      
;;;349      /* Get the TIMx CCMR1 register value */
;;;350      tmpccmrx = TIMx->CCMR1;
000194  f8b0c018          LDRH     r12,[r0,#0x18]
;;;351        
;;;352      /* Reset the Output Compare Mode Bits */
;;;353      tmpccmrx &= CCMR_OC24M_Mask;
000198  f42c44e0          BIC      r4,r12,#0x7000
;;;354      
;;;355      /* Select the Output Compare Mode */
;;;356      tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
00019c  880d              LDRH     r5,[r1,#0]
00019e  f64f7cff          MOV      r12,#0xffff
0001a2  ea0c2505          AND      r5,r12,r5,LSL #8
0001a6  432c              ORRS     r4,r4,r5
;;;357      
;;;358      /* Reset the Output Polarity level */
;;;359      tmpccer &= CCER_CC2P_Reset;
0001a8  f0220220          BIC      r2,r2,#0x20
;;;360    
;;;361      /* Set the Output Compare Polarity */
;;;362      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 4);
0001ac  890d              LDRH     r5,[r1,#8]
0001ae  ea0c1505          AND      r5,r12,r5,LSL #4
0001b2  432a              ORRS     r2,r2,r5
;;;363      
;;;364      /* Set the Output State */
;;;365      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 4);
0001b4  884d              LDRH     r5,[r1,#2]
0001b6  ea0c1505          AND      r5,r12,r5,LSL #4
0001ba  432a              ORRS     r2,r2,r5
;;;366      
;;;367      /* Set the Capture Compare Register value */
;;;368      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
0001bc  88cd              LDRH     r5,[r1,#6]
0001be  8705              STRH     r5,[r0,#0x38]
;;;369      
;;;370      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
0001c0  f1a04580          SUB      r5,r0,#0x40000000
0001c4  f5b53596          SUBS     r5,r5,#0x12c00
0001c8  d004              BEQ      |L1.468|
0001ca  f1a04580          SUB      r5,r0,#0x40000000
0001ce  f5b5359a          SUBS     r5,r5,#0x13400
0001d2  d117              BNE      |L1.516|
                  |L1.468|
;;;371      {
;;;372        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;373        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;374        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;375        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;376        
;;;377        /* Reset the Output N Polarity level */
;;;378        tmpccer &= CCER_CC2NP_Reset;
0001d4  f0220280          BIC      r2,r2,#0x80
;;;379    
;;;380        /* Set the Output N Polarity */
;;;381        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
0001d8  894d              LDRH     r5,[r1,#0xa]
0001da  ea0c1505          AND      r5,r12,r5,LSL #4
0001de  432a              ORRS     r2,r2,r5
;;;382    
;;;383        /* Reset the Output N State */
;;;384        tmpccer &= CCER_CC2NE_Reset;
0001e0  f0220240          BIC      r2,r2,#0x40
;;;385        
;;;386        /* Set the Output N State */
;;;387        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 4);
0001e4  888d              LDRH     r5,[r1,#4]
0001e6  ea0c1505          AND      r5,r12,r5,LSL #4
0001ea  432a              ORRS     r2,r2,r5
;;;388    
;;;389        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;390        tmpcr2 &= CR2_OIS2_Reset;
0001ec  f4234304          BIC      r3,r3,#0x8400
;;;391        tmpcr2 &= CR2_OIS2N_Reset;
0001f0  f4234308          BIC      r3,r3,#0x8800
;;;392    
;;;393        /* Set the Output Idle state */
;;;394        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 2);
0001f4  898d              LDRH     r5,[r1,#0xc]
0001f6  ea0c0585          AND      r5,r12,r5,LSL #2
0001fa  432b              ORRS     r3,r3,r5
;;;395    
;;;396        /* Set the Output N Idle state */
;;;397        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
0001fc  89c9              LDRH     r1,[r1,#0xe]
0001fe  ea0c0181          AND      r1,r12,r1,LSL #2
000202  430b              ORRS     r3,r3,r1
                  |L1.516|
;;;398      }
;;;399    
;;;400      /* Write to TIMx CR2 */
;;;401      TIMx->CR2 = tmpcr2;
000204  8083              STRH     r3,[r0,#4]
;;;402      
;;;403      /* Write to TIMx CCMR1 */
;;;404      TIMx->CCMR1 = tmpccmrx;
000206  8304              STRH     r4,[r0,#0x18]
;;;405      
;;;406      /* Write to TIMx CCER */
;;;407      TIMx->CCER = tmpccer;
000208  8402              STRH     r2,[r0,#0x20]
;;;408    }
00020a  bc30              POP      {r4,r5}
00020c  4770              BX       lr
;;;409    
                          ENDP

                  TIM_OC3Init PROC
;;;421    *******************************************************************************/
;;;422    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
00020e  b430              PUSH     {r4,r5}
;;;423    {
;;;424      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;425       
;;;426      /* Check the parameters */
;;;427      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;428      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;429      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;430      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;431    
;;;432      /* Disable the Channel 2: Reset the CC2E Bit */
;;;433      TIMx->CCER &= CCER_CC3E_Reset;
000210  8c02              LDRH     r2,[r0,#0x20]
000212  f4227280          BIC      r2,r2,#0x100
000216  8402              STRH     r2,[r0,#0x20]
;;;434      
;;;435      /* Get the TIMx CCER register value */
;;;436      tmpccer = TIMx->CCER;
000218  8c02              LDRH     r2,[r0,#0x20]
;;;437    
;;;438      /* Get the TIMx CR2 register value */
;;;439      tmpcr2 =  TIMx->CR2;
00021a  8883              LDRH     r3,[r0,#4]
;;;440      
;;;441      /* Get the TIMx CCMR2 register value */
;;;442      tmpccmrx = TIMx->CCMR2;
00021c  f8b0c01c          LDRH     r12,[r0,#0x1c]
;;;443        
;;;444      /* Reset the Output Compare Mode Bits */
;;;445      tmpccmrx &= CCMR_OC13M_Mask;
000220  f02c0c70          BIC      r12,r12,#0x70
;;;446      
;;;447      /* Select the Output Compare Mode */
;;;448      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000224  880c              LDRH     r4,[r1,#0]
000226  ea44040c          ORR      r4,r4,r12
;;;449      
;;;450      /* Reset the Output Polarity level */
;;;451      tmpccer &= CCER_CC3P_Reset;
00022a  f4227200          BIC      r2,r2,#0x200
;;;452    
;;;453      /* Set the Output Compare Polarity */
;;;454      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00022e  890d              LDRH     r5,[r1,#8]
000230  f64f7cff          MOV      r12,#0xffff
000234  ea0c2505          AND      r5,r12,r5,LSL #8
000238  432a              ORRS     r2,r2,r5
;;;455      
;;;456      /* Set the Output State */
;;;457      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 8);
00023a  884d              LDRH     r5,[r1,#2]
00023c  ea0c2505          AND      r5,r12,r5,LSL #8
000240  432a              ORRS     r2,r2,r5
;;;458      
;;;459      /* Set the Capture Compare Register value */
;;;460      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000242  88cd              LDRH     r5,[r1,#6]
000244  8785              STRH     r5,[r0,#0x3c]
;;;461      
;;;462      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
000246  f1a04580          SUB      r5,r0,#0x40000000
00024a  f5b53596          SUBS     r5,r5,#0x12c00
00024e  d004              BEQ      |L1.602|
000250  f1a04580          SUB      r5,r0,#0x40000000
000254  f5b5359a          SUBS     r5,r5,#0x13400
000258  d117              BNE      |L1.650|
                  |L1.602|
;;;463      {
;;;464        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;465        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;466        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;467        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;468        
;;;469        /* Reset the Output N Polarity level */
;;;470        tmpccer &= CCER_CC3NP_Reset;
00025a  f4226200          BIC      r2,r2,#0x800
;;;471    
;;;472        /* Set the Output N Polarity */
;;;473        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
00025e  894d              LDRH     r5,[r1,#0xa]
000260  ea0c2505          AND      r5,r12,r5,LSL #8
000264  432a              ORRS     r2,r2,r5
;;;474    
;;;475        /* Reset the Output N State */
;;;476        tmpccer &= CCER_CC3NE_Reset;
000266  f4226280          BIC      r2,r2,#0x400
;;;477        
;;;478        /* Set the Output N State */
;;;479        tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 8);
00026a  888d              LDRH     r5,[r1,#4]
00026c  ea0c2505          AND      r5,r12,r5,LSL #8
000270  432a              ORRS     r2,r2,r5
;;;480    
;;;481        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;482        tmpcr2 &= CR2_OIS3_Reset;
000272  f4234310          BIC      r3,r3,#0x9000
;;;483        tmpcr2 &= CR2_OIS3N_Reset;
000276  f4234320          BIC      r3,r3,#0xa000
;;;484    
;;;485        /* Set the Output Idle state */
;;;486        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 4);
00027a  898d              LDRH     r5,[r1,#0xc]
00027c  ea0c1505          AND      r5,r12,r5,LSL #4
000280  432b              ORRS     r3,r3,r5
;;;487    
;;;488        /* Set the Output N Idle state */
;;;489        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000282  89c9              LDRH     r1,[r1,#0xe]
000284  ea0c1101          AND      r1,r12,r1,LSL #4
000288  430b              ORRS     r3,r3,r1
                  |L1.650|
;;;490      }
;;;491    
;;;492      /* Write to TIMx CR2 */
;;;493      TIMx->CR2 = tmpcr2;
00028a  8083              STRH     r3,[r0,#4]
;;;494      
;;;495      /* Write to TIMx CCMR2 */
;;;496      TIMx->CCMR2 = tmpccmrx;
00028c  8384              STRH     r4,[r0,#0x1c]
;;;497      
;;;498      /* Write to TIMx CCER */
;;;499      TIMx->CCER = tmpccer;
00028e  8402              STRH     r2,[r0,#0x20]
;;;500    }
000290  bc30              POP      {r4,r5}
000292  4770              BX       lr
;;;501    
                          ENDP

                  TIM_OC4Init PROC
;;;513    *******************************************************************************/
;;;514    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000294  b430              PUSH     {r4,r5}
;;;515    {
;;;516      u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;517       
;;;518      /* Check the parameters */
;;;519      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;520      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;521      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;522      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;523    
;;;524      /* Disable the Channel 2: Reset the CC4E Bit */
;;;525      TIMx->CCER &= CCER_CC4E_Reset;
000296  8c02              LDRH     r2,[r0,#0x20]
000298  f4225280          BIC      r2,r2,#0x1000
00029c  8402              STRH     r2,[r0,#0x20]
;;;526      
;;;527      /* Get the TIMx CCER register value */
;;;528      tmpccer = TIMx->CCER;
00029e  8c03              LDRH     r3,[r0,#0x20]
;;;529    
;;;530      /* Get the TIMx CR2 register value */
;;;531      tmpcr2 =  TIMx->CR2;
0002a0  8882              LDRH     r2,[r0,#4]
;;;532      
;;;533      /* Get the TIMx CCMR2 register value */
;;;534      tmpccmrx = TIMx->CCMR2;
0002a2  f8b0c01c          LDRH     r12,[r0,#0x1c]
;;;535        
;;;536      /* Reset the Output Compare Mode Bits */
;;;537      tmpccmrx &= CCMR_OC24M_Mask;
0002a6  f42c4ce0          BIC      r12,r12,#0x7000
;;;538      
;;;539      /* Select the Output Compare Mode */
;;;540      tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
0002aa  880d              LDRH     r5,[r1,#0]
0002ac  f64f74ff          MOV      r4,#0xffff
0002b0  ea042505          AND      r5,r4,r5,LSL #8
0002b4  ea450c0c          ORR      r12,r5,r12
;;;541      
;;;542      /* Reset the Output Polarity level */
;;;543      tmpccer &= CCER_CC4P_Reset;
0002b8  f4235300          BIC      r3,r3,#0x2000
;;;544    
;;;545      /* Set the Output Compare Polarity */
;;;546      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 12);
0002bc  890d              LDRH     r5,[r1,#8]
0002be  ea043505          AND      r5,r4,r5,LSL #12
0002c2  432b              ORRS     r3,r3,r5
;;;547      
;;;548      /* Set the Output State */
;;;549      tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 12);
0002c4  884d              LDRH     r5,[r1,#2]
0002c6  ea043505          AND      r5,r4,r5,LSL #12
0002ca  432b              ORRS     r3,r3,r5
;;;550      
;;;551      /* Set the Capture Compare Register value */
;;;552      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
0002cc  88cd              LDRH     r5,[r1,#6]
0002ce  f8a05040          STRH     r5,[r0,#0x40]
;;;553      
;;;554      if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
0002d2  f1a04580          SUB      r5,r0,#0x40000000
0002d6  f5b53596          SUBS     r5,r5,#0x12c00
0002da  d004              BEQ      |L1.742|
0002dc  f1a04580          SUB      r5,r0,#0x40000000
0002e0  f5b5359a          SUBS     r5,r5,#0x13400
0002e4  d105              BNE      |L1.754|
                  |L1.742|
;;;555      {
;;;556        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;557    
;;;558        /* Reset the Ouput Compare IDLE State */
;;;559        tmpcr2 &= CR2_OIS4_Reset;
0002e6  f3c2020d          UBFX     r2,r2,#0,#14
;;;560    
;;;561        /* Set the Output Idle state */
;;;562        tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 6);
0002ea  8989              LDRH     r1,[r1,#0xc]
0002ec  ea041181          AND      r1,r4,r1,LSL #6
0002f0  430a              ORRS     r2,r2,r1
                  |L1.754|
;;;563      }
;;;564    
;;;565      /* Write to TIMx CR2 */
;;;566      TIMx->CR2 = tmpcr2;
0002f2  8082              STRH     r2,[r0,#4]
;;;567      
;;;568      /* Write to TIMx CCMR2 */  
;;;569      TIMx->CCMR2 = tmpccmrx;
0002f4  f8a0c01c          STRH     r12,[r0,#0x1c]
;;;570      
;;;571      /* Write to TIMx CCER */
;;;572      TIMx->CCER = tmpccer;
0002f8  8403              STRH     r3,[r0,#0x20]
;;;573    }
0002fa  bc30              POP      {r4,r5}
0002fc  4770              BX       lr
;;;574    
                          ENDP

                  TIM_SetIC4Prescaler PROC
;;;2751   *******************************************************************************/
;;;2752   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
0002fe  8b82              LDRH     r2,[r0,#0x1c]
;;;2753   {  
;;;2754     /* Check the parameters */
;;;2755     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2756     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2757   
;;;2758     /* Reset the IC4PSC Bits */
;;;2759     TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
000300  f4226240          BIC      r2,r2,#0xc00
000304  8382              STRH     r2,[r0,#0x1c]
;;;2760   
;;;2761     /* Set the IC4PSC value */
;;;2762     TIMx->CCMR2 |= (u16)(TIM_ICPSC << 8);
000306  8b82              LDRH     r2,[r0,#0x1c]
000308  f64f73ff          MOV      r3,#0xffff
00030c  ea032101          AND      r1,r3,r1,LSL #8
000310  4311              ORRS     r1,r1,r2
000312  8381              STRH     r1,[r0,#0x1c]
;;;2763   }
000314  4770              BX       lr
;;;2764   
                          ENDP

                  TI4_Config PROC
;;;3196   *******************************************************************************/
;;;3197   static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000316  b430              PUSH     {r4,r5}
;;;3198                          u16 TIM_ICFilter)
;;;3199   {
;;;3200     u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
;;;3201   
;;;3202     /* Disable the Channel 4: Reset the CC4E Bit */
;;;3203     TIMx->CCER &= CCER_CC4E_Reset;
000318  f8b0c020          LDRH     r12,[r0,#0x20]
00031c  f42c5c80          BIC      r12,r12,#0x1000
000320  f8a0c020          STRH     r12,[r0,#0x20]
;;;3204   
;;;3205     tmpccmr2 = TIMx->CCMR2;
000324  8b84              LDRH     r4,[r0,#0x1c]
;;;3206     tmpccer = TIMx->CCER;
000326  f8b0c020          LDRH     r12,[r0,#0x20]
;;;3207     tmp = (u16)(TIM_ICPolarity << 12);
00032a  f64f75ff          MOV      r5,#0xffff
00032e  ea053101          AND      r1,r5,r1,LSL #12
;;;3208   
;;;3209     /* Select the Input and set the filter */
;;;3210     tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000332  f4244473          BIC      r4,r4,#0xf300
;;;3211     tmpccmr2 |= (u16)(TIM_ICSelection << 8) | (u16)(TIM_ICFilter << 12);
000336  ea052202          AND      r2,r5,r2,LSL #8
00033a  ea053303          AND      r3,r5,r3,LSL #12
00033e  431a              ORRS     r2,r2,r3
000340  4322              ORRS     r2,r2,r4
;;;3212   
;;;3213     /* Select the Polarity and set the CC4E Bit */
;;;3214     tmpccer &= CCER_CC4P_Reset;
000342  f42c5300          BIC      r3,r12,#0x2000
;;;3215     tmpccer |= tmp | CCER_CC4E_Set;
000346  4319              ORRS     r1,r1,r3
000348  f4415180          ORR      r1,r1,#0x1000
;;;3216   
;;;3217     /* Write to TIMx CCMR2 and CCER registers */
;;;3218     TIMx->CCMR2 = tmpccmr2;
00034c  8382              STRH     r2,[r0,#0x1c]
;;;3219     TIMx->CCER = tmpccer ;
00034e  8401              STRH     r1,[r0,#0x20]
;;;3220   }
000350  bc30              POP      {r4,r5}
000352  4770              BX       lr
;;;3221   
                          ENDP

                  TIM_SetIC3Prescaler PROC
;;;2723   *******************************************************************************/
;;;2724   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
000354  8b82              LDRH     r2,[r0,#0x1c]
;;;2725   {
;;;2726     /* Check the parameters */
;;;2727     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2728     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2729   
;;;2730     /* Reset the IC3PSC Bits */
;;;2731     TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
000356  f022020c          BIC      r2,r2,#0xc
00035a  8382              STRH     r2,[r0,#0x1c]
;;;2732   
;;;2733     /* Set the IC3PSC value */
;;;2734     TIMx->CCMR2 |= TIM_ICPSC;
00035c  8b82              LDRH     r2,[r0,#0x1c]
00035e  4311              ORRS     r1,r1,r2
000360  8381              STRH     r1,[r0,#0x1c]
;;;2735   }
000362  4770              BX       lr
;;;2736   
                          ENDP

                  TI3_Config PROC
;;;3149   *******************************************************************************/
;;;3150   static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000364  b430              PUSH     {r4,r5}
;;;3151                          u16 TIM_ICFilter)
;;;3152   {
;;;3153     u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
;;;3154   
;;;3155     /* Disable the Channel 3: Reset the CC3E Bit */
;;;3156     TIMx->CCER &= CCER_CC3E_Reset;
000366  f8b0c020          LDRH     r12,[r0,#0x20]
00036a  f42c7c80          BIC      r12,r12,#0x100
00036e  f8a0c020          STRH     r12,[r0,#0x20]
;;;3157   
;;;3158     tmpccmr2 = TIMx->CCMR2;
000372  8b84              LDRH     r4,[r0,#0x1c]
;;;3159     tmpccer = TIMx->CCER;
000374  f8b0c020          LDRH     r12,[r0,#0x20]
;;;3160     tmp = (u16)(TIM_ICPolarity << 8);
000378  f64f75ff          MOV      r5,#0xffff
00037c  ea052101          AND      r1,r5,r1,LSL #8
;;;3161   
;;;3162     /* Select the Input and set the filter */
;;;3163     tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000380  f02404f3          BIC      r4,r4,#0xf3
;;;3164     tmpccmr2 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
000384  ea051303          AND      r3,r5,r3,LSL #4
000388  431a              ORRS     r2,r2,r3
00038a  4322              ORRS     r2,r2,r4
;;;3165   
;;;3166     /* Select the Polarity and set the CC3E Bit */
;;;3167     tmpccer &= CCER_CC3P_Reset;
00038c  f42c7300          BIC      r3,r12,#0x200
;;;3168     tmpccer |= tmp | CCER_CC3E_Set;
000390  4319              ORRS     r1,r1,r3
000392  f4417180          ORR      r1,r1,#0x100
;;;3169   
;;;3170     /* Write to TIMx CCMR2 and CCER registers */
;;;3171     TIMx->CCMR2 = tmpccmr2;
000396  8382              STRH     r2,[r0,#0x1c]
;;;3172     TIMx->CCER = tmpccer;
000398  8401              STRH     r1,[r0,#0x20]
;;;3173   }
00039a  bc30              POP      {r4,r5}
00039c  4770              BX       lr
;;;3174   
                          ENDP

                  TIM_SetIC2Prescaler PROC
;;;2695   *******************************************************************************/
;;;2696   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
00039e  8b02              LDRH     r2,[r0,#0x18]
;;;2697   {
;;;2698     /* Check the parameters */
;;;2699     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2700     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2701   
;;;2702     /* Reset the IC2PSC Bits */
;;;2703     TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
0003a0  f4226240          BIC      r2,r2,#0xc00
0003a4  8302              STRH     r2,[r0,#0x18]
;;;2704   
;;;2705     /* Set the IC2PSC value */
;;;2706     TIMx->CCMR1 |= (u16)(TIM_ICPSC << 8);
0003a6  8b02              LDRH     r2,[r0,#0x18]
0003a8  f64f73ff          MOV      r3,#0xffff
0003ac  ea032101          AND      r1,r3,r1,LSL #8
0003b0  4311              ORRS     r1,r1,r2
0003b2  8301              STRH     r1,[r0,#0x18]
;;;2707   }
0003b4  4770              BX       lr
;;;2708   
                          ENDP

                  TI2_Config PROC
;;;3101   *******************************************************************************/
;;;3102   static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
0003b6  b430              PUSH     {r4,r5}
;;;3103                          u16 TIM_ICFilter)
;;;3104   {
;;;3105     u16 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
;;;3106   
;;;3107     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3108     TIMx->CCER &= CCER_CC2E_Reset;
0003b8  f8b0c020          LDRH     r12,[r0,#0x20]
0003bc  f02c0c10          BIC      r12,r12,#0x10
0003c0  f8a0c020          STRH     r12,[r0,#0x20]
;;;3109   
;;;3110     tmpccmr1 = TIMx->CCMR1;
0003c4  8b04              LDRH     r4,[r0,#0x18]
;;;3111     tmpccer = TIMx->CCER;
0003c6  f8b0c020          LDRH     r12,[r0,#0x20]
;;;3112     tmp = (u16)(TIM_ICPolarity << 4);
0003ca  f64f75ff          MOV      r5,#0xffff
0003ce  ea051101          AND      r1,r5,r1,LSL #4
;;;3113   
;;;3114     /* Select the Input and set the filter */
;;;3115     tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
0003d2  f4244473          BIC      r4,r4,#0xf300
;;;3116     tmpccmr1 |= (u16)(TIM_ICFilter << 12);
0003d6  ea053303          AND      r3,r5,r3,LSL #12
0003da  4323              ORRS     r3,r3,r4
;;;3117     tmpccmr1 |= (u16)(TIM_ICSelection << 8);
0003dc  ea052202          AND      r2,r5,r2,LSL #8
0003e0  431a              ORRS     r2,r2,r3
;;;3118   
;;;3119     /* Select the Polarity and set the CC2E Bit */
;;;3120     tmpccer &= CCER_CC2P_Reset;
0003e2  f02c0320          BIC      r3,r12,#0x20
;;;3121     tmpccer |=  tmp | CCER_CC2E_Set;
0003e6  4319              ORRS     r1,r1,r3
0003e8  f0410110          ORR      r1,r1,#0x10
;;;3122   
;;;3123     /* Write to TIMx CCMR1 and CCER registers */
;;;3124     TIMx->CCMR1 = tmpccmr1 ;
0003ec  8302              STRH     r2,[r0,#0x18]
;;;3125     TIMx->CCER = tmpccer;
0003ee  8401              STRH     r1,[r0,#0x20]
;;;3126   }
0003f0  bc30              POP      {r4,r5}
0003f2  4770              BX       lr
                  |L1.1012|
                          DCD      0x40001000
                          ENDP

                  TIM_SetIC1Prescaler PROC
;;;2667   *******************************************************************************/
;;;2668   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
0003f8  8b02              LDRH     r2,[r0,#0x18]
;;;2669   {
;;;2670     /* Check the parameters */
;;;2671     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2672     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2673   
;;;2674     /* Reset the IC1PSC Bits */
;;;2675     TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
0003fa  f022020c          BIC      r2,r2,#0xc
0003fe  8302              STRH     r2,[r0,#0x18]
;;;2676   
;;;2677     /* Set the IC1PSC value */
;;;2678     TIMx->CCMR1 |= TIM_ICPSC;
000400  8b02              LDRH     r2,[r0,#0x18]
000402  4311              ORRS     r1,r1,r2
000404  8301              STRH     r1,[r0,#0x18]
;;;2679   }
000406  4770              BX       lr
;;;2680   
                          ENDP

                  TI1_Config PROC
;;;3055   *******************************************************************************/
;;;3056   static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
000408  b430              PUSH     {r4,r5}
;;;3057                          u16 TIM_ICFilter)
;;;3058   {
;;;3059     u16 tmpccmr1 = 0, tmpccer = 0;
;;;3060   
;;;3061     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3062     TIMx->CCER &= CCER_CC1E_Reset;
00040a  f8b0c020          LDRH     r12,[r0,#0x20]
00040e  f02c0c01          BIC      r12,r12,#1
000412  f8a0c020          STRH     r12,[r0,#0x20]
;;;3063   
;;;3064     tmpccmr1 = TIMx->CCMR1;
000416  8b04              LDRH     r4,[r0,#0x18]
;;;3065     tmpccer = TIMx->CCER;
000418  f8b0c020          LDRH     r12,[r0,#0x20]
;;;3066   
;;;3067     /* Select the Input and set the filter */
;;;3068     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
00041c  f02404f3          BIC      r4,r4,#0xf3
;;;3069     tmpccmr1 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
000420  f64f75ff          MOV      r5,#0xffff
000424  ea051303          AND      r3,r5,r3,LSL #4
000428  431a              ORRS     r2,r2,r3
00042a  4322              ORRS     r2,r2,r4
;;;3070   
;;;3071     /* Select the Polarity and set the CC1E Bit */
;;;3072     tmpccer &= CCER_CC1P_Reset;
00042c  f02c0302          BIC      r3,r12,#2
;;;3073     tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
000430  4319              ORRS     r1,r1,r3
000432  f0410101          ORR      r1,r1,#1
;;;3074   
;;;3075     /* Write to TIMx CCMR1 and CCER registers */
;;;3076     TIMx->CCMR1 = tmpccmr1;
000436  8302              STRH     r2,[r0,#0x18]
;;;3077     TIMx->CCER = tmpccer;
000438  8401              STRH     r1,[r0,#0x20]
;;;3078   }
00043a  bc30              POP      {r4,r5}
00043c  4770              BX       lr
;;;3079   
                          ENDP

                  TIM_ICInit PROC
;;;586    *******************************************************************************/
;;;587    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
00043e  b570              PUSH     {r4-r6,lr}
;;;588    {
000440  4605              MOV      r5,r0
000442  460c              MOV      r4,r1
;;;589      /* Check the parameters */
;;;590      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;591      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
;;;592      assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;593      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;594      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;595      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;596      
;;;597      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000444  8821              LDRH     r1,[r4,#0]
;;;598      {
;;;599        /* TI1 Configuration */
;;;600        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000446  f8b4c002          LDRH     r12,[r4,#2]
00044a  88a2              LDRH     r2,[r4,#4]
00044c  8923              LDRH     r3,[r4,#8]
00044e  2900              CMP      r1,#0                 ;597
000450  d00c              BEQ      |L1.1132|
;;;601                   TIM_ICInitStruct->TIM_ICSelection,
;;;602                   TIM_ICInitStruct->TIM_ICFilter);
;;;603    
;;;604        /* Set the Input Capture Prescaler value */
;;;605        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;606      }
;;;607      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000452  2904              CMP      r1,#4
000454  d013              BEQ      |L1.1150|
;;;608      {
;;;609        /* TI2 Configuration */
;;;610        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;611                   TIM_ICInitStruct->TIM_ICSelection,
;;;612                   TIM_ICInitStruct->TIM_ICFilter);
;;;613    
;;;614        /* Set the Input Capture Prescaler value */
;;;615        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;616      }
;;;617      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000456  2908              CMP      r1,#8
000458  d01a              BEQ      |L1.1168|
;;;618      {
;;;619        /* TI3 Configuration */
;;;620        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;621                   TIM_ICInitStruct->TIM_ICSelection,
;;;622                   TIM_ICInitStruct->TIM_ICFilter);
;;;623    
;;;624        /* Set the Input Capture Prescaler value */
;;;625        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;626      }
;;;627      else
;;;628      {
;;;629        /* TI4 Configuration */
;;;630        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00045a  4661              MOV      r1,r12
00045c  4628              MOV      r0,r5
00045e  f7fffffe          BL       TI4_Config
;;;631                   TIM_ICInitStruct->TIM_ICSelection,
;;;632                   TIM_ICInitStruct->TIM_ICFilter);
;;;633    
;;;634        /* Set the Input Capture Prescaler value */
;;;635        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000462  88e1              LDRH     r1,[r4,#6]
000464  4628              MOV      r0,r5
000466  e8bd4070          POP      {r4-r6,lr}
00046a  e7fe              B        TIM_SetIC4Prescaler
                  |L1.1132|
00046c  4661              MOV      r1,r12                ;600
00046e  4628              MOV      r0,r5                 ;600
000470  f7fffffe          BL       TI1_Config
000474  88e1              LDRH     r1,[r4,#6]            ;605
000476  4628              MOV      r0,r5                 ;605
000478  e8bd4070          POP      {r4-r6,lr}            ;605
00047c  e7fe              B        TIM_SetIC1Prescaler
                  |L1.1150|
00047e  4661              MOV      r1,r12                ;610
000480  4628              MOV      r0,r5                 ;610
000482  f7fffffe          BL       TI2_Config
000486  88e1              LDRH     r1,[r4,#6]            ;615
000488  4628              MOV      r0,r5                 ;615
00048a  e8bd4070          POP      {r4-r6,lr}            ;615
00048e  e7fe              B        TIM_SetIC2Prescaler
                  |L1.1168|
000490  4661              MOV      r1,r12                ;620
000492  4628              MOV      r0,r5                 ;620
000494  f7fffffe          BL       TI3_Config
000498  88e1              LDRH     r1,[r4,#6]            ;625
00049a  4628              MOV      r0,r5                 ;625
00049c  e8bd4070          POP      {r4-r6,lr}            ;625
0004a0  e7fe              B        TIM_SetIC3Prescaler
;;;636      }
;;;637    }
;;;638    
                          ENDP

                  TIM_PWMIConfig PROC
;;;651    *******************************************************************************/
;;;652    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
0004a2  e92d41f0          PUSH     {r4-r8,lr}
;;;653    {
0004a6  4607              MOV      r7,r0
0004a8  460c              MOV      r4,r1
;;;654      u16 icoppositepolarity = TIM_ICPolarity_Rising;
0004aa  2500              MOVS     r5,#0
;;;655      u16 icoppositeselection = TIM_ICSelection_DirectTI;
0004ac  2601              MOVS     r6,#1
;;;656    
;;;657      /* Check the parameters */
;;;658      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;659    
;;;660      /* Select the Opposite Input Polarity */
;;;661      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
0004ae  8861              LDRH     r1,[r4,#2]
0004b0  2900              CMP      r1,#0
0004b2  d100              BNE      |L1.1206|
;;;662      {
;;;663        icoppositepolarity = TIM_ICPolarity_Falling;
0004b4  2502              MOVS     r5,#2
                  |L1.1206|
;;;664      }
;;;665      else
;;;666      {
;;;667        icoppositepolarity = TIM_ICPolarity_Rising;
;;;668      }
;;;669    
;;;670      /* Select the Opposite Input */
;;;671      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
0004b6  88a2              LDRH     r2,[r4,#4]
0004b8  2a01              CMP      r2,#1
0004ba  d100              BNE      |L1.1214|
;;;672      {
;;;673        icoppositeselection = TIM_ICSelection_IndirectTI;
0004bc  2602              MOVS     r6,#2
                  |L1.1214|
;;;674      }
;;;675      else
;;;676      {
;;;677        icoppositeselection = TIM_ICSelection_DirectTI;
;;;678      }
;;;679    
;;;680      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
0004be  8820              LDRH     r0,[r4,#0]
;;;681      {
;;;682        /* TI1 Configuration */
;;;683        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
0004c0  8923              LDRH     r3,[r4,#8]
0004c2  b188              CBZ      r0,|L1.1256|
;;;684                   TIM_ICInitStruct->TIM_ICFilter);
;;;685    
;;;686        /* Set the Input Capture Prescaler value */
;;;687        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;688    
;;;689        /* TI2 Configuration */
;;;690        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;691    
;;;692        /* Set the Input Capture Prescaler value */
;;;693        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;694      }
;;;695      else
;;;696      { 
;;;697        /* TI2 Configuration */
;;;698        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
0004c4  4638              MOV      r0,r7
0004c6  f7fffffe          BL       TI2_Config
;;;699                   TIM_ICInitStruct->TIM_ICFilter);
;;;700    
;;;701        /* Set the Input Capture Prescaler value */
;;;702        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0004ca  88e1              LDRH     r1,[r4,#6]
0004cc  4638              MOV      r0,r7
0004ce  f7fffffe          BL       TIM_SetIC2Prescaler
;;;703    
;;;704        /* TI1 Configuration */
;;;705        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
0004d2  8923              LDRH     r3,[r4,#8]
0004d4  4632              MOV      r2,r6
0004d6  4629              MOV      r1,r5
0004d8  4638              MOV      r0,r7
0004da  f7fffffe          BL       TI1_Config
;;;706    
;;;707        /* Set the Input Capture Prescaler value */
;;;708        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0004de  88e1              LDRH     r1,[r4,#6]
0004e0  4638              MOV      r0,r7
0004e2  e8bd41f0          POP      {r4-r8,lr}
0004e6  e7fe              B        TIM_SetIC1Prescaler
                  |L1.1256|
0004e8  4638              MOV      r0,r7                 ;683
0004ea  f7fffffe          BL       TI1_Config
0004ee  88e1              LDRH     r1,[r4,#6]            ;687
0004f0  4638              MOV      r0,r7                 ;687
0004f2  f7fffffe          BL       TIM_SetIC1Prescaler
0004f6  8923              LDRH     r3,[r4,#8]            ;690
0004f8  4632              MOV      r2,r6                 ;690
0004fa  4629              MOV      r1,r5                 ;690
0004fc  4638              MOV      r0,r7                 ;690
0004fe  f7fffffe          BL       TI2_Config
000502  88e1              LDRH     r1,[r4,#6]            ;693
000504  4638              MOV      r0,r7                 ;693
000506  e8bd41f0          POP      {r4-r8,lr}            ;693
00050a  e7fe              B        TIM_SetIC2Prescaler
;;;709      }
;;;710    }
;;;711    
                          ENDP

                  TIM_BDTRConfig PROC
;;;722    *******************************************************************************/
;;;723    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
00050c  880a              LDRH     r2,[r1,#0]
;;;724    {
;;;725      /* Check the parameters */
;;;726      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;727      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;728      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;729      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;730      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;731      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;732      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;733    
;;;734      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;735         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;736    
;;;737      TIMx->BDTR = (u32)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
00050e  884b              LDRH     r3,[r1,#2]
000510  f8b1c006          LDRH     r12,[r1,#6]
000514  431a              ORRS     r2,r2,r3
000516  888b              LDRH     r3,[r1,#4]
000518  ea43030c          ORR      r3,r3,r12
00051c  431a              ORRS     r2,r2,r3
00051e  890b              LDRH     r3,[r1,#8]
000520  431a              ORRS     r2,r2,r3
000522  894b              LDRH     r3,[r1,#0xa]
000524  8989              LDRH     r1,[r1,#0xc]
000526  431a              ORRS     r2,r2,r3
000528  4311              ORRS     r1,r1,r2
00052a  f8a01044          STRH     r1,[r0,#0x44]
;;;738                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;739                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;740                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;741    
;;;742    }
00052e  4770              BX       lr
;;;743    
                          ENDP

                  TIM_TimeBaseStructInit PROC
;;;751    *******************************************************************************/
;;;752    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000530  f64f71ff          MOV      r1,#0xffff
;;;753    {
;;;754      /* Set the default configuration */
;;;755      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000534  8081              STRH     r1,[r0,#4]
;;;756      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000536  2100              MOVS     r1,#0
000538  8001              STRH     r1,[r0,#0]
;;;757      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00053a  80c1              STRH     r1,[r0,#6]
;;;758      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00053c  8041              STRH     r1,[r0,#2]
;;;759      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00053e  7201              STRB     r1,[r0,#8]
;;;760    }
000540  4770              BX       lr
;;;761    
                          ENDP

                  TIM_OCStructInit PROC
;;;769    *******************************************************************************/
;;;770    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000542  2100              MOVS     r1,#0
;;;771    {
;;;772      /* Set the default configuration */
;;;773      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000544  8001              STRH     r1,[r0,#0]
;;;774      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000546  8041              STRH     r1,[r0,#2]
;;;775      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000548  8081              STRH     r1,[r0,#4]
;;;776      TIM_OCInitStruct->TIM_Pulse = 0x0000;
00054a  80c1              STRH     r1,[r0,#6]
;;;777      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00054c  8101              STRH     r1,[r0,#8]
;;;778      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00054e  8141              STRH     r1,[r0,#0xa]
;;;779      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
000550  8181              STRH     r1,[r0,#0xc]
;;;780      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000552  81c1              STRH     r1,[r0,#0xe]
;;;781    }
000554  4770              BX       lr
;;;782    
                          ENDP

                  TIM_ICStructInit PROC
;;;790    *******************************************************************************/
;;;791    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000556  2100              MOVS     r1,#0
;;;792    {
;;;793      /* Set the default configuration */
;;;794      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000558  8001              STRH     r1,[r0,#0]
;;;795      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
00055a  8041              STRH     r1,[r0,#2]
;;;796      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
00055c  2201              MOVS     r2,#1
00055e  8082              STRH     r2,[r0,#4]
;;;797      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
000560  80c1              STRH     r1,[r0,#6]
;;;798      TIM_ICInitStruct->TIM_ICFilter = 0x00;
000562  8101              STRH     r1,[r0,#8]
;;;799    }
000564  4770              BX       lr
;;;800    
                          ENDP

                  TIM_BDTRStructInit PROC
;;;808    *******************************************************************************/
;;;809    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000566  2100              MOVS     r1,#0
;;;810    {
;;;811      /* Set the default configuration */
;;;812      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000568  8001              STRH     r1,[r0,#0]
;;;813      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
00056a  8041              STRH     r1,[r0,#2]
;;;814      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
00056c  8081              STRH     r1,[r0,#4]
;;;815      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
00056e  80c1              STRH     r1,[r0,#6]
;;;816      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
000570  8101              STRH     r1,[r0,#8]
;;;817      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
000572  8141              STRH     r1,[r0,#0xa]
;;;818      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
000574  8181              STRH     r1,[r0,#0xc]
;;;819    }
000576  4770              BX       lr
;;;820    
                          ENDP

                  TIM_Cmd PROC
;;;829    *******************************************************************************/
;;;830    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000578  2900              CMP      r1,#0
;;;831    {
00057a  d004              BEQ      |L1.1414|
;;;832      /* Check the parameters */
;;;833      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;834      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;835      
;;;836      if (NewState != DISABLE)
;;;837      {
;;;838        /* Enable the TIM Counter */
;;;839        TIMx->CR1 |= CR1_CEN_Set;
00057c  8801              LDRH     r1,[r0,#0]
00057e  f0410101          ORR      r1,r1,#1
000582  8001              STRH     r1,[r0,#0]
;;;840      }
;;;841      else
;;;842      {
;;;843        /* Disable the TIM Counter */
;;;844        TIMx->CR1 &= CR1_CEN_Reset;
;;;845      }
;;;846    }
000584  4770              BX       lr
                  |L1.1414|
000586  8801              LDRH     r1,[r0,#0]            ;844
000588  f0210101          BIC      r1,r1,#1              ;844
00058c  f421417c          BIC      r1,r1,#0xfc00         ;844
000590  8001              STRH     r1,[r0,#0]            ;844
000592  4770              BX       lr
;;;847    
                          ENDP

                  TIM_CtrlPWMOutputs PROC
;;;856    *******************************************************************************/
;;;857    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000594  2900              CMP      r1,#0
;;;858    {
000596  d006              BEQ      |L1.1446|
;;;859      /* Check the parameters */
;;;860      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;861      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;862    
;;;863      if (NewState != DISABLE)
;;;864      {
;;;865        /* Enable the TIM Main Output */
;;;866        TIMx->BDTR |= BDTR_MOE_Set;
000598  f8b01044          LDRH     r1,[r0,#0x44]
00059c  f4414100          ORR      r1,r1,#0x8000
0005a0  f8a01044          STRH     r1,[r0,#0x44]
;;;867      }
;;;868      else
;;;869      {
;;;870        /* Disable the TIM Main Output */
;;;871        TIMx->BDTR &= BDTR_MOE_Reset;
;;;872      }  
;;;873    }
0005a4  4770              BX       lr
                  |L1.1446|
0005a6  f8b01044          LDRH     r1,[r0,#0x44]         ;871
0005aa  f3c1010e          UBFX     r1,r1,#0,#15          ;871
0005ae  f8a01044          STRH     r1,[r0,#0x44]         ;871
0005b2  4770              BX       lr
;;;874    
                          ENDP

                  TIM_ITConfig PROC
;;;894    *******************************************************************************/
;;;895    void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
0005b4  2a00              CMP      r2,#0
;;;896    {  
0005b6  d003              BEQ      |L1.1472|
;;;897      /* Check the parameters */
;;;898      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;899      assert_param(IS_TIM_IT(TIM_IT));
;;;900      assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
;;;901      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;902      
;;;903      if (NewState != DISABLE)
;;;904      {
;;;905        /* Enable the Interrupt sources */
;;;906        TIMx->DIER |= TIM_IT;
0005b8  8982              LDRH     r2,[r0,#0xc]
0005ba  4311              ORRS     r1,r1,r2
0005bc  8181              STRH     r1,[r0,#0xc]
;;;907      }
;;;908      else
;;;909      {
;;;910        /* Disable the Interrupt sources */
;;;911        TIMx->DIER &= (u16)~TIM_IT;
;;;912      }
;;;913    }
0005be  4770              BX       lr
                  |L1.1472|
0005c0  8982              LDRH     r2,[r0,#0xc]          ;911
0005c2  ea220101          BIC      r1,r2,r1              ;911
0005c6  8181              STRH     r1,[r0,#0xc]          ;911
0005c8  4770              BX       lr
;;;914    
                          ENDP

                  TIM_GenerateEvent PROC
;;;929    *******************************************************************************/
;;;930    void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
0005ca  8281              STRH     r1,[r0,#0x14]
;;;931    { 
;;;932      /* Check the parameters */
;;;933      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;934      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;935      assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
;;;936    
;;;937      /* Set the event sources */
;;;938      TIMx->EGR = TIM_EventSource;
;;;939    }
0005cc  4770              BX       lr
;;;940    
                          ENDP

                  TIM_DMAConfig PROC
;;;960    *******************************************************************************/
;;;961    void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
0005ce  4311              ORRS     r1,r1,r2
;;;962    {
;;;963      /* Check the parameters */
;;;964      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;965      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;966      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;967    
;;;968      /* Set the DMA Base and the DMA Burst Length */
;;;969      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
0005d0  f8a01048          STRH     r1,[r0,#0x48]
;;;970    }
0005d4  4770              BX       lr
;;;971    
                          ENDP

                  TIM_DMACmd PROC
;;;989    *******************************************************************************/
;;;990    void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState)
0005d6  2a00              CMP      r2,#0
;;;991    { 
0005d8  d003              BEQ      |L1.1506|
;;;992      /* Check the parameters */
;;;993      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;994      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;995      assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
;;;996      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;997      
;;;998      if (NewState != DISABLE)
;;;999      {
;;;1000       /* Enable the DMA sources */
;;;1001       TIMx->DIER |= TIM_DMASource; 
0005da  8982              LDRH     r2,[r0,#0xc]
0005dc  4311              ORRS     r1,r1,r2
0005de  8181              STRH     r1,[r0,#0xc]
;;;1002     }
;;;1003     else
;;;1004     {
;;;1005       /* Disable the DMA sources */
;;;1006       TIMx->DIER &= (u16)~TIM_DMASource;
;;;1007     }
;;;1008   }
0005e0  4770              BX       lr
                  |L1.1506|
0005e2  8982              LDRH     r2,[r0,#0xc]          ;1006
0005e4  ea220101          BIC      r1,r2,r1              ;1006
0005e8  8181              STRH     r1,[r0,#0xc]          ;1006
0005ea  4770              BX       lr
;;;1009   
                          ENDP

                  TIM_InternalClockConfig PROC
;;;1017   *******************************************************************************/
;;;1018   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
0005ec  8901              LDRH     r1,[r0,#8]
;;;1019   {
;;;1020     /* Check the parameters */
;;;1021     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1022   
;;;1023     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;1024     TIMx->SMCR &=  SMCR_SMS_Mask;
0005ee  f0210107          BIC      r1,r1,#7
0005f2  8101              STRH     r1,[r0,#8]
;;;1025   }
0005f4  4770              BX       lr
;;;1026   /*******************************************************************************
                          ENDP

                  TIM_SelectInputTrigger PROC
;;;1305   *******************************************************************************/
;;;1306   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
0005f6  8902              LDRH     r2,[r0,#8]
;;;1307   {
;;;1308     u16 tmpsmcr = 0;
;;;1309   
;;;1310     /* Check the parameters */
;;;1311     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1312     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1313   
;;;1314     /* Get the TIMx SMCR register value */
;;;1315     tmpsmcr = TIMx->SMCR;
;;;1316   
;;;1317     /* Reset the TS Bits */
;;;1318     tmpsmcr &= SMCR_TS_Mask;
0005f8  f0220270          BIC      r2,r2,#0x70
;;;1319   
;;;1320     /* Set the Input Trigger source */
;;;1321     tmpsmcr |= TIM_InputTriggerSource;
0005fc  4311              ORRS     r1,r1,r2
;;;1322   
;;;1323     /* Write to TIMx SMCR */
;;;1324     TIMx->SMCR = tmpsmcr;
0005fe  8101              STRH     r1,[r0,#8]
;;;1325   }
000600  4770              BX       lr
;;;1326   
                          ENDP

                  TIM_ITRxExternalClockConfig PROC
;;;1039   *******************************************************************************/
;;;1040   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
000602  b500              PUSH     {lr}
;;;1041   {
000604  4603              MOV      r3,r0
;;;1042     /* Check the parameters */
;;;1043     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1044     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1045   
;;;1046     /* Select the Internal Trigger */
;;;1047     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000606  4618              MOV      r0,r3
000608  f7fffffe          BL       TIM_SelectInputTrigger
;;;1048   
;;;1049     /* Select the External clock mode1 */
;;;1050     TIMx->SMCR |= TIM_SlaveMode_External1;
00060c  8918              LDRH     r0,[r3,#8]
00060e  f0400007          ORR      r0,r0,#7
000612  8118              STRH     r0,[r3,#8]
;;;1051   }
000614  bd00              POP      {pc}
;;;1052   /*******************************************************************************
                          ENDP

                  TIM_TIxExternalClockConfig PROC
;;;1070   *******************************************************************************/
;;;1071   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
000616  b570              PUSH     {r4-r6,lr}
;;;1072                                   u16 TIM_ICPolarity, u16 ICFilter)
;;;1073   {
000618  460d              MOV      r5,r1
00061a  4604              MOV      r4,r0
00061c  4611              MOV      r1,r2
;;;1074     /* Check the parameters */
;;;1075     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1076     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1077     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1078     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1079   
;;;1080     /* Configure the Timer Input Clock Source */
;;;1081     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00061e  2d60              CMP      r5,#0x60
000620  d00c              BEQ      |L1.1596|
;;;1082     {
;;;1083       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;1084     }
;;;1085     else
;;;1086     {
;;;1087       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000622  2201              MOVS     r2,#1
000624  4620              MOV      r0,r4
000626  f7fffffe          BL       TI1_Config
                  |L1.1578|
;;;1088     }
;;;1089   
;;;1090     /* Select the Trigger source */
;;;1091     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
00062a  4629              MOV      r1,r5
00062c  4620              MOV      r0,r4
00062e  f7fffffe          BL       TIM_SelectInputTrigger
;;;1092   
;;;1093     /* Select the External clock mode1 */
;;;1094     TIMx->SMCR |= TIM_SlaveMode_External1;
000632  8920              LDRH     r0,[r4,#8]
000634  f0400007          ORR      r0,r0,#7
000638  8120              STRH     r0,[r4,#8]
;;;1095   }
00063a  bd70              POP      {r4-r6,pc}
                  |L1.1596|
00063c  2201              MOVS     r2,#1                 ;1083
00063e  4620              MOV      r0,r4                 ;1083
000640  f7fffffe          BL       TI2_Config
000644  e7f1              B        |L1.1578|
;;;1096   
                          ENDP

                  TIM_ETRConfig PROC
;;;1202   *******************************************************************************/
;;;1203   void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
000646  f8b0c008          LDRH     r12,[r0,#8]
;;;1204                      u16 ExtTRGFilter)
;;;1205   {
;;;1206     u16 tmpsmcr = 0;
;;;1207   
;;;1208     /* Check the parameters */
;;;1209     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1210     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1211     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1212     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1213   
;;;1214     tmpsmcr = TIMx->SMCR;
;;;1215   
;;;1216     /* Reset the ETR Bits */
;;;1217     tmpsmcr &= SMCR_ETR_Mask;
00064a  f00c0cff          AND      r12,r12,#0xff
;;;1218   
;;;1219     /* Set the Prescaler, the Filter value and the Polarity */
;;;1220     tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)(ExtTRGFilter << 8);
00064e  4311              ORRS     r1,r1,r2
000650  f64f72ff          MOV      r2,#0xffff
000654  ea022203          AND      r2,r2,r3,LSL #8
000658  4311              ORRS     r1,r1,r2
00065a  ea41010c          ORR      r1,r1,r12
;;;1221   
;;;1222     /* Write to TIMx SMCR */
;;;1223     TIMx->SMCR = tmpsmcr;
00065e  8101              STRH     r1,[r0,#8]
;;;1224   }
000660  4770              BX       lr
;;;1225   
                          ENDP

                  TIM_ETRClockMode1Config PROC
;;;1116   *******************************************************************************/
;;;1117   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
000662  b510              PUSH     {r4,lr}
;;;1118                                u16 ExtTRGFilter)
;;;1119   {
000664  4604              MOV      r4,r0
;;;1120     u16 tmpsmcr = 0;
;;;1121   
;;;1122     /* Check the parameters */
;;;1123     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1124     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1125     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1126     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1127   
;;;1128     /* Configure the ETR Clock source */
;;;1129     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000666  4620              MOV      r0,r4
000668  f7fffffe          BL       TIM_ETRConfig
;;;1130     
;;;1131     /* Get the TIMx SMCR register value */
;;;1132     tmpsmcr = TIMx->SMCR;
00066c  8920              LDRH     r0,[r4,#8]
;;;1133   
;;;1134     /* Reset the SMS Bits */
;;;1135     tmpsmcr &= SMCR_SMS_Mask;
00066e  f0200007          BIC      r0,r0,#7
;;;1136     /* Select the External clock mode1 */
;;;1137     tmpsmcr |= TIM_SlaveMode_External1;
000672  f0400007          ORR      r0,r0,#7
;;;1138   
;;;1139     /* Select the Trigger selection : ETRF */
;;;1140     tmpsmcr &= SMCR_TS_Mask;
000676  f0200070          BIC      r0,r0,#0x70
;;;1141     tmpsmcr |= TIM_TS_ETRF;
00067a  f0400070          ORR      r0,r0,#0x70
;;;1142   
;;;1143     /* Write to TIMx SMCR */
;;;1144     TIMx->SMCR = tmpsmcr;
00067e  8120              STRH     r0,[r4,#8]
;;;1145   }
000680  bd10              POP      {r4,pc}
;;;1146   
                          ENDP

                  TIM_ETRClockMode2Config PROC
;;;1166   *******************************************************************************/
;;;1167   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
000682  b510              PUSH     {r4,lr}
;;;1168                                u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)
;;;1169   {
000684  4604              MOV      r4,r0
;;;1170     /* Check the parameters */
;;;1171     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1172     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1173     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1174     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1175   
;;;1176     /* Configure the ETR Clock source */
;;;1177     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000686  4620              MOV      r0,r4
000688  f7fffffe          BL       TIM_ETRConfig
;;;1178   
;;;1179     /* Enable the External clock mode2 */
;;;1180     TIMx->SMCR |= SMCR_ECE_Set;
00068c  8920              LDRH     r0,[r4,#8]
00068e  f4404080          ORR      r0,r0,#0x4000
000692  8120              STRH     r0,[r4,#8]
;;;1181   }
000694  bd10              POP      {r4,pc}
;;;1182   
                          ENDP

                  TIM_PrescalerConfig PROC
;;;1239   *******************************************************************************/
;;;1240   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
000696  8501              STRH     r1,[r0,#0x28]
;;;1241   {
;;;1242     /* Check the parameters */
;;;1243     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1244     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1245   
;;;1246     /* Set the Prescaler value */
;;;1247     TIMx->PSC = Prescaler;
;;;1248   
;;;1249     /* Set or reset the UG Bit */
;;;1250     TIMx->EGR = TIM_PSCReloadMode;
000698  8282              STRH     r2,[r0,#0x14]
;;;1251   }
00069a  4770              BX       lr
;;;1252   
                          ENDP

                  TIM_CounterModeConfig PROC
;;;1267   *******************************************************************************/
;;;1268   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
00069c  8802              LDRH     r2,[r0,#0]
;;;1269   {
;;;1270     u16 tmpcr1 = 0;
;;;1271   
;;;1272     /* Check the parameters */
;;;1273     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1274     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1275   
;;;1276     tmpcr1 = TIMx->CR1;
;;;1277   
;;;1278     /* Reset the CMS and DIR Bits */
;;;1279     tmpcr1 &= CR1_CounterMode_Mask;
00069e  f4226247          BIC      r2,r2,#0xc70
0006a2  f4224270          BIC      r2,r2,#0xf000
;;;1280   
;;;1281     /* Set the Counter Mode */
;;;1282     tmpcr1 |= TIM_CounterMode;
0006a6  4311              ORRS     r1,r1,r2
;;;1283   
;;;1284     /* Write to TIMx CR1 register */
;;;1285     TIMx->CR1 = tmpcr1;
0006a8  8001              STRH     r1,[r0,#0]
;;;1286   }
0006aa  4770              BX       lr
;;;1287   
                          ENDP

                  TIM_EncoderInterfaceConfig PROC
;;;1350   *******************************************************************************/
;;;1351   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
0006ac  b430              PUSH     {r4,r5}
;;;1352                                   u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
;;;1353   {
;;;1354     u16 tmpsmcr = 0;
;;;1355     u16 tmpccmr1 = 0;
;;;1356     u16 tmpccer = 0;
;;;1357       
;;;1358     /* Check the parameters */
;;;1359     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1360     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1361     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1362     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1363   
;;;1364     /* Get the TIMx SMCR register value */
;;;1365     tmpsmcr = TIMx->SMCR;
0006ae  8905              LDRH     r5,[r0,#8]
;;;1366   
;;;1367     /* Get the TIMx CCMR1 register value */
;;;1368     tmpccmr1 = TIMx->CCMR1;
0006b0  f8b0c018          LDRH     r12,[r0,#0x18]
;;;1369   
;;;1370     /* Get the TIMx CCER register value */
;;;1371     tmpccer = TIMx->CCER;
0006b4  8c04              LDRH     r4,[r0,#0x20]
;;;1372   
;;;1373     /* Set the encoder Mode */
;;;1374     tmpsmcr &= SMCR_SMS_Mask;
0006b6  f0250507          BIC      r5,r5,#7
;;;1375     tmpsmcr |= TIM_EncoderMode;
0006ba  4329              ORRS     r1,r1,r5
;;;1376   
;;;1377     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1378     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
0006bc  f02c0c03          BIC      r12,r12,#3
0006c0  f42c7c40          BIC      r12,r12,#0x300
;;;1379     tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
0006c4  f2401501          MOV      r5,#0x101
0006c8  ea4c0c05          ORR      r12,r12,r5
;;;1380   
;;;1381     /* Set the TI1 and the TI2 Polarities */
;;;1382     tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
0006cc  f0240422          BIC      r4,r4,#0x22
;;;1383     tmpccer |= (TIM_IC1Polarity | (u16)(TIM_IC2Polarity << 4));
0006d0  f64f75ff          MOV      r5,#0xffff
0006d4  ea051303          AND      r3,r5,r3,LSL #4
0006d8  431a              ORRS     r2,r2,r3
0006da  4322              ORRS     r2,r2,r4
;;;1384   
;;;1385     /* Write to TIMx SMCR */
;;;1386     TIMx->SMCR = tmpsmcr;
0006dc  8101              STRH     r1,[r0,#8]
;;;1387   
;;;1388     /* Write to TIMx CCMR1 */
;;;1389     TIMx->CCMR1 = tmpccmr1;
0006de  f8a0c018          STRH     r12,[r0,#0x18]
;;;1390   
;;;1391     /* Write to TIMx CCER */
;;;1392     TIMx->CCER = tmpccer;
0006e2  8402              STRH     r2,[r0,#0x20]
;;;1393   }
0006e4  bc30              POP      {r4,r5}
0006e6  4770              BX       lr
;;;1394   
                          ENDP

                  TIM_ForcedOC1Config PROC
;;;1408   *******************************************************************************/
;;;1409   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
0006e8  8b02              LDRH     r2,[r0,#0x18]
;;;1410   {
;;;1411     u16 tmpccmr1 = 0;
;;;1412   
;;;1413     /* Check the parameters */
;;;1414     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1415     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1416   
;;;1417     tmpccmr1 = TIMx->CCMR1;
;;;1418   
;;;1419     /* Reset the OC1M Bits */
;;;1420     tmpccmr1 &= CCMR_OC13M_Mask;
0006ea  f0220270          BIC      r2,r2,#0x70
;;;1421   
;;;1422     /* Configure The Forced output Mode */
;;;1423     tmpccmr1 |= TIM_ForcedAction;
0006ee  4311              ORRS     r1,r1,r2
;;;1424   
;;;1425     /* Write to TIMx CCMR1 register */
;;;1426     TIMx->CCMR1 = tmpccmr1;
0006f0  8301              STRH     r1,[r0,#0x18]
;;;1427   }
0006f2  4770              BX       lr
;;;1428   
                          ENDP

                  TIM_ForcedOC2Config PROC
;;;1442   *******************************************************************************/
;;;1443   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
0006f4  8b02              LDRH     r2,[r0,#0x18]
;;;1444   {
;;;1445     u16 tmpccmr1 = 0;
;;;1446   
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1449     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1450   
;;;1451     tmpccmr1 = TIMx->CCMR1;
;;;1452   
;;;1453     /* Reset the OC2M Bits */
;;;1454     tmpccmr1 &= CCMR_OC24M_Mask;
0006f6  f42242e0          BIC      r2,r2,#0x7000
;;;1455   
;;;1456     /* Configure The Forced output Mode */
;;;1457     tmpccmr1 |= (u16)(TIM_ForcedAction << 8);
0006fa  f64f73ff          MOV      r3,#0xffff
0006fe  ea032101          AND      r1,r3,r1,LSL #8
000702  4311              ORRS     r1,r1,r2
;;;1458   
;;;1459     /* Write to TIMx CCMR1 register */
;;;1460     TIMx->CCMR1 = tmpccmr1;
000704  8301              STRH     r1,[r0,#0x18]
;;;1461   }
000706  4770              BX       lr
;;;1462   
                          ENDP

                  TIM_ForcedOC3Config PROC
;;;1476   *******************************************************************************/
;;;1477   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
000708  8b82              LDRH     r2,[r0,#0x1c]
;;;1478   {
;;;1479     u16 tmpccmr2 = 0;
;;;1480   
;;;1481     /* Check the parameters */
;;;1482     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1483     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1484   
;;;1485     tmpccmr2 = TIMx->CCMR2;
;;;1486   
;;;1487     /* Reset the OC1M Bits */
;;;1488     tmpccmr2 &= CCMR_OC13M_Mask;
00070a  f0220270          BIC      r2,r2,#0x70
;;;1489   
;;;1490     /* Configure The Forced output Mode */
;;;1491     tmpccmr2 |= TIM_ForcedAction;
00070e  4311              ORRS     r1,r1,r2
;;;1492   
;;;1493     /* Write to TIMx CCMR2 register */
;;;1494     TIMx->CCMR2 = tmpccmr2;
000710  8381              STRH     r1,[r0,#0x1c]
;;;1495   }
000712  4770              BX       lr
;;;1496   
                          ENDP

                  TIM_ForcedOC4Config PROC
;;;1510   *******************************************************************************/
;;;1511   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
000714  8b82              LDRH     r2,[r0,#0x1c]
;;;1512   {
;;;1513     u16 tmpccmr2 = 0;
;;;1514   
;;;1515     /* Check the parameters */
;;;1516     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1517     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1518     tmpccmr2 = TIMx->CCMR2;
;;;1519   
;;;1520     /* Reset the OC2M Bits */
;;;1521     tmpccmr2 &= CCMR_OC24M_Mask;
000716  f42242e0          BIC      r2,r2,#0x7000
;;;1522   
;;;1523     /* Configure The Forced output Mode */
;;;1524     tmpccmr2 |= (u16)(TIM_ForcedAction << 8);
00071a  f64f73ff          MOV      r3,#0xffff
00071e  ea032101          AND      r1,r3,r1,LSL #8
000722  4311              ORRS     r1,r1,r2
;;;1525   
;;;1526     /* Write to TIMx CCMR2 register */
;;;1527     TIMx->CCMR2 = tmpccmr2;
000724  8381              STRH     r1,[r0,#0x1c]
;;;1528   }
000726  4770              BX       lr
;;;1529   
                          ENDP

                  TIM_ARRPreloadConfig PROC
;;;1539   *******************************************************************************/
;;;1540   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000728  2900              CMP      r1,#0
;;;1541   {
00072a  d004              BEQ      |L1.1846|
;;;1542     /* Check the parameters */
;;;1543     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1544     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1545   
;;;1546     if (NewState != DISABLE)
;;;1547     {
;;;1548       /* Set the ARR Preload Bit */
;;;1549       TIMx->CR1 |= CR1_ARPE_Set;
00072c  8801              LDRH     r1,[r0,#0]
00072e  f0410180          ORR      r1,r1,#0x80
000732  8001              STRH     r1,[r0,#0]
;;;1550     }
;;;1551     else
;;;1552     {
;;;1553       /* Reset the ARR Preload Bit */
;;;1554       TIMx->CR1 &= CR1_ARPE_Reset;
;;;1555     }
;;;1556   }
000734  4770              BX       lr
                  |L1.1846|
000736  8801              LDRH     r1,[r0,#0]            ;1554
000738  f42141f9          BIC      r1,r1,#0x7c80         ;1554
00073c  f4214100          BIC      r1,r1,#0x8000         ;1554
000740  8001              STRH     r1,[r0,#0]            ;1554
000742  4770              BX       lr
;;;1557   
                          ENDP

                  TIM_SelectCOM PROC
;;;1566   *******************************************************************************/
;;;1567   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000744  2900              CMP      r1,#0
;;;1568   {
000746  d004              BEQ      |L1.1874|
;;;1569     /* Check the parameters */
;;;1570     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1571     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1572   
;;;1573     if (NewState != DISABLE)
;;;1574     {
;;;1575       /* Set the COM Bit */
;;;1576       TIMx->CR2 |= CR2_CCUS_Set;
000748  8881              LDRH     r1,[r0,#4]
00074a  f0410104          ORR      r1,r1,#4
00074e  8081              STRH     r1,[r0,#4]
;;;1577     }
;;;1578     else
;;;1579     {
;;;1580       /* Reset the COM Bit */
;;;1581       TIMx->CR2 &= CR2_CCUS_Reset;
;;;1582     }
;;;1583   }
000750  4770              BX       lr
                  |L1.1874|
000752  8881              LDRH     r1,[r0,#4]            ;1581
000754  f0210104          BIC      r1,r1,#4              ;1581
000758  8081              STRH     r1,[r0,#4]            ;1581
00075a  4770              BX       lr
;;;1584   
                          ENDP

                  TIM_SelectCCDMA PROC
;;;1594   *******************************************************************************/
;;;1595   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
00075c  2900              CMP      r1,#0
;;;1596   {
00075e  d004              BEQ      |L1.1898|
;;;1597     /* Check the parameters */
;;;1598     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1599     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1600   
;;;1601     if (NewState != DISABLE)
;;;1602     {
;;;1603       /* Set the CCDS Bit */
;;;1604       TIMx->CR2 |= CR2_CCDS_Set;
000760  8881              LDRH     r1,[r0,#4]
000762  f0410108          ORR      r1,r1,#8
000766  8081              STRH     r1,[r0,#4]
;;;1605     }
;;;1606     else
;;;1607     {
;;;1608       /* Reset the CCDS Bit */
;;;1609       TIMx->CR2 &= CR2_CCDS_Reset;
;;;1610     }
;;;1611   }
000768  4770              BX       lr
                  |L1.1898|
00076a  8881              LDRH     r1,[r0,#4]            ;1609
00076c  f0210108          BIC      r1,r1,#8              ;1609
000770  8081              STRH     r1,[r0,#4]            ;1609
000772  4770              BX       lr
;;;1612   
                          ENDP

                  TIM_CCPreloadControl PROC
;;;1622   *******************************************************************************/
;;;1623   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000774  2900              CMP      r1,#0
;;;1624   { 
000776  d004              BEQ      |L1.1922|
;;;1625     /* Check the parameters */
;;;1626     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1627     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1628   
;;;1629     if (NewState != DISABLE)
;;;1630     {
;;;1631       /* Set the CCPC Bit */
;;;1632       TIMx->CR2 |= CR2_CCPC_Set;
000778  8881              LDRH     r1,[r0,#4]
00077a  f0410101          ORR      r1,r1,#1
00077e  8081              STRH     r1,[r0,#4]
;;;1633     }
;;;1634     else
;;;1635     {
;;;1636       /* Reset the CCPC Bit */
;;;1637       TIMx->CR2 &= CR2_CCPC_Reset;
;;;1638     }
;;;1639   }
000780  4770              BX       lr
                  |L1.1922|
000782  8881              LDRH     r1,[r0,#4]            ;1637
000784  f0210101          BIC      r1,r1,#1              ;1637
000788  8081              STRH     r1,[r0,#4]            ;1637
00078a  4770              BX       lr
;;;1640   
                          ENDP

                  TIM_OC1PreloadConfig PROC
;;;1653   *******************************************************************************/
;;;1654   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
00078c  8b02              LDRH     r2,[r0,#0x18]
;;;1655   {
;;;1656     u16 tmpccmr1 = 0;
;;;1657   
;;;1658     /* Check the parameters */
;;;1659     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1660     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1661   
;;;1662     tmpccmr1 = TIMx->CCMR1;
;;;1663   
;;;1664     /* Reset the OC1PE Bit */
;;;1665     tmpccmr1 &= CCMR_OC13PE_Reset;
00078e  f0220208          BIC      r2,r2,#8
;;;1666   
;;;1667     /* Enable or Disable the Output Compare Preload feature */
;;;1668     tmpccmr1 |= TIM_OCPreload;
000792  4311              ORRS     r1,r1,r2
;;;1669   
;;;1670     /* Write to TIMx CCMR1 register */
;;;1671     TIMx->CCMR1 = tmpccmr1;
000794  8301              STRH     r1,[r0,#0x18]
;;;1672   }
000796  4770              BX       lr
;;;1673   
                          ENDP

                  TIM_OC2PreloadConfig PROC
;;;1686   *******************************************************************************/
;;;1687   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
000798  8b02              LDRH     r2,[r0,#0x18]
;;;1688   {
;;;1689     u16 tmpccmr1 = 0;
;;;1690   
;;;1691     /* Check the parameters */
;;;1692     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1693     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1694   
;;;1695     tmpccmr1 = TIMx->CCMR1;
;;;1696   
;;;1697     /* Reset the OC2PE Bit */
;;;1698     tmpccmr1 &= CCMR_OC24PE_Reset;
00079a  f4226200          BIC      r2,r2,#0x800
;;;1699   
;;;1700     /* Enable or Disable the Output Compare Preload feature */
;;;1701     tmpccmr1 |= (u16)(TIM_OCPreload << 8);
00079e  f64f73ff          MOV      r3,#0xffff
0007a2  ea032101          AND      r1,r3,r1,LSL #8
0007a6  4311              ORRS     r1,r1,r2
;;;1702   
;;;1703     /* Write to TIMx CCMR1 register */
;;;1704     TIMx->CCMR1 = tmpccmr1;
0007a8  8301              STRH     r1,[r0,#0x18]
;;;1705   }
0007aa  4770              BX       lr
;;;1706   
                          ENDP

                  TIM_OC3PreloadConfig PROC
;;;1719   *******************************************************************************/
;;;1720   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
0007ac  8b82              LDRH     r2,[r0,#0x1c]
;;;1721   {
;;;1722     u16 tmpccmr2 = 0;
;;;1723   
;;;1724     /* Check the parameters */
;;;1725     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1726     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1727   
;;;1728     tmpccmr2 = TIMx->CCMR2;
;;;1729   
;;;1730     /* Reset the OC3PE Bit */
;;;1731     tmpccmr2 &= CCMR_OC13PE_Reset;
0007ae  f0220208          BIC      r2,r2,#8
;;;1732   
;;;1733     /* Enable or Disable the Output Compare Preload feature */
;;;1734     tmpccmr2 |= TIM_OCPreload;
0007b2  4311              ORRS     r1,r1,r2
;;;1735   
;;;1736     /* Write to TIMx CCMR2 register */
;;;1737     TIMx->CCMR2 = tmpccmr2;
0007b4  8381              STRH     r1,[r0,#0x1c]
;;;1738   }
0007b6  4770              BX       lr
;;;1739   
                          ENDP

                  TIM_OC4PreloadConfig PROC
;;;1752   *******************************************************************************/
;;;1753   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
0007b8  8b82              LDRH     r2,[r0,#0x1c]
;;;1754   {
;;;1755     u16 tmpccmr2 = 0;
;;;1756   
;;;1757     /* Check the parameters */
;;;1758     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1759     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1760   
;;;1761     tmpccmr2 = TIMx->CCMR2;
;;;1762   
;;;1763     /* Reset the OC4PE Bit */
;;;1764     tmpccmr2 &= CCMR_OC24PE_Reset;
0007ba  f4226200          BIC      r2,r2,#0x800
;;;1765   
;;;1766     /* Enable or Disable the Output Compare Preload feature */
;;;1767     tmpccmr2 |= (u16)(TIM_OCPreload << 8);
0007be  f64f73ff          MOV      r3,#0xffff
0007c2  ea032101          AND      r1,r3,r1,LSL #8
0007c6  4311              ORRS     r1,r1,r2
;;;1768   
;;;1769     /* Write to TIMx CCMR2 register */
;;;1770     TIMx->CCMR2 = tmpccmr2;
0007c8  8381              STRH     r1,[r0,#0x1c]
;;;1771   }
0007ca  4770              BX       lr
;;;1772   
                          ENDP

                  TIM_OC1FastConfig PROC
;;;1784   *******************************************************************************/
;;;1785   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
0007cc  8b02              LDRH     r2,[r0,#0x18]
;;;1786   {
;;;1787     u16 tmpccmr1 = 0;
;;;1788   
;;;1789     /* Check the parameters */
;;;1790     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1791     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1792   
;;;1793     /* Get the TIMx CCMR1 register value */
;;;1794     tmpccmr1 = TIMx->CCMR1;
;;;1795   
;;;1796     /* Reset the OC1FE Bit */
;;;1797     tmpccmr1 &= CCMR_OC13FE_Reset;
0007ce  f0220204          BIC      r2,r2,#4
;;;1798   
;;;1799     /* Enable or Disable the Output Compare Fast Bit */
;;;1800     tmpccmr1 |= TIM_OCFast;
0007d2  4311              ORRS     r1,r1,r2
;;;1801   
;;;1802     /* Write to TIMx CCMR1 */
;;;1803     TIMx->CCMR1 = tmpccmr1;
0007d4  8301              STRH     r1,[r0,#0x18]
;;;1804   }
0007d6  4770              BX       lr
;;;1805   
                          ENDP

                  TIM_OC2FastConfig PROC
;;;1817   *******************************************************************************/
;;;1818   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
0007d8  8b02              LDRH     r2,[r0,#0x18]
;;;1819   {
;;;1820     u16 tmpccmr1 = 0;
;;;1821   
;;;1822     /* Check the parameters */
;;;1823     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1824     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1825   
;;;1826     /* Get the TIMx CCMR1 register value */
;;;1827     tmpccmr1 = TIMx->CCMR1;
;;;1828   
;;;1829     /* Reset the OC2FE Bit */
;;;1830     tmpccmr1 &= CCMR_OC24FE_Reset;
0007da  f4226280          BIC      r2,r2,#0x400
;;;1831   
;;;1832     /* Enable or Disable the Output Compare Fast Bit */
;;;1833     tmpccmr1 |= (u16)(TIM_OCFast << 8);
0007de  f64f73ff          MOV      r3,#0xffff
0007e2  ea032101          AND      r1,r3,r1,LSL #8
0007e6  4311              ORRS     r1,r1,r2
;;;1834   
;;;1835     /* Write to TIMx CCMR1 */
;;;1836     TIMx->CCMR1 = tmpccmr1;
0007e8  8301              STRH     r1,[r0,#0x18]
;;;1837   }
0007ea  4770              BX       lr
;;;1838   
                          ENDP

                  TIM_OC3FastConfig PROC
;;;1850   *******************************************************************************/
;;;1851   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
0007ec  8b82              LDRH     r2,[r0,#0x1c]
;;;1852   {
;;;1853     u16 tmpccmr2 = 0;
;;;1854   
;;;1855     /* Check the parameters */
;;;1856     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1857     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1858   
;;;1859     /* Get the TIMx CCMR2 register value */
;;;1860     tmpccmr2 = TIMx->CCMR2;
;;;1861   
;;;1862     /* Reset the OC3FE Bit */
;;;1863     tmpccmr2 &= CCMR_OC13FE_Reset;
0007ee  f0220204          BIC      r2,r2,#4
;;;1864   
;;;1865     /* Enable or Disable the Output Compare Fast Bit */
;;;1866     tmpccmr2 |= TIM_OCFast;
0007f2  4311              ORRS     r1,r1,r2
;;;1867   
;;;1868     /* Write to TIMx CCMR2 */
;;;1869     TIMx->CCMR2 = tmpccmr2;
0007f4  8381              STRH     r1,[r0,#0x1c]
;;;1870   }
0007f6  4770              BX       lr
;;;1871   
                          ENDP

                  TIM_OC4FastConfig PROC
;;;1883   *******************************************************************************/
;;;1884   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
0007f8  8b82              LDRH     r2,[r0,#0x1c]
;;;1885   {
;;;1886     u16 tmpccmr2 = 0;
;;;1887   
;;;1888     /* Check the parameters */
;;;1889     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1890     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1891   
;;;1892     /* Get the TIMx CCMR2 register value */
;;;1893     tmpccmr2 = TIMx->CCMR2;
;;;1894   
;;;1895     /* Reset the OC4FE Bit */
;;;1896     tmpccmr2 &= CCMR_OC24FE_Reset;
0007fa  f4226280          BIC      r2,r2,#0x400
;;;1897   
;;;1898     /* Enable or Disable the Output Compare Fast Bit */
;;;1899     tmpccmr2 |= (u16)(TIM_OCFast << 8);
0007fe  f64f73ff          MOV      r3,#0xffff
000802  ea032101          AND      r1,r3,r1,LSL #8
000806  4311              ORRS     r1,r1,r2
;;;1900   
;;;1901     /* Write to TIMx CCMR2 */
;;;1902     TIMx->CCMR2 = tmpccmr2;
000808  8381              STRH     r1,[r0,#0x1c]
;;;1903   }
00080a  4770              BX       lr
;;;1904   
                          ENDP

                  TIM_ClearOC1Ref PROC
;;;1916   *******************************************************************************/
;;;1917   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
00080c  8b02              LDRH     r2,[r0,#0x18]
;;;1918   {
;;;1919     u16 tmpccmr1 = 0;
;;;1920   
;;;1921     /* Check the parameters */
;;;1922     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1923     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1924   
;;;1925     tmpccmr1 = TIMx->CCMR1;
;;;1926   
;;;1927     /* Reset the OC1CE Bit */
;;;1928     tmpccmr1 &= CCMR_OC13CE_Reset;
00080e  f0220280          BIC      r2,r2,#0x80
;;;1929   
;;;1930     /* Enable or Disable the Output Compare Clear Bit */
;;;1931     tmpccmr1 |= TIM_OCClear;
000812  4311              ORRS     r1,r1,r2
;;;1932   
;;;1933     /* Write to TIMx CCMR1 register */
;;;1934     TIMx->CCMR1 = tmpccmr1;
000814  8301              STRH     r1,[r0,#0x18]
;;;1935   }
000816  4770              BX       lr
;;;1936   
                          ENDP

                  TIM_ClearOC2Ref PROC
;;;1948   *******************************************************************************/
;;;1949   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000818  8b02              LDRH     r2,[r0,#0x18]
;;;1950   {
;;;1951     u16 tmpccmr1 = 0;
;;;1952   
;;;1953     /* Check the parameters */
;;;1954     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1955     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1956   
;;;1957     tmpccmr1 = TIMx->CCMR1;
;;;1958   
;;;1959     /* Reset the OC2CE Bit */
;;;1960     tmpccmr1 &= CCMR_OC24CE_Reset;
00081a  f3c2020e          UBFX     r2,r2,#0,#15
;;;1961   
;;;1962     /* Enable or Disable the Output Compare Clear Bit */
;;;1963     tmpccmr1 |= (u16)(TIM_OCClear << 8);
00081e  f64f73ff          MOV      r3,#0xffff
000822  ea032101          AND      r1,r3,r1,LSL #8
000826  4311              ORRS     r1,r1,r2
;;;1964   
;;;1965     /* Write to TIMx CCMR1 register */
;;;1966     TIMx->CCMR1 = tmpccmr1;
000828  8301              STRH     r1,[r0,#0x18]
;;;1967   }
00082a  4770              BX       lr
;;;1968   
                          ENDP

                  TIM_ClearOC3Ref PROC
;;;1980   *******************************************************************************/
;;;1981   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
00082c  8b82              LDRH     r2,[r0,#0x1c]
;;;1982   {
;;;1983     u16 tmpccmr2 = 0;
;;;1984   
;;;1985     /* Check the parameters */
;;;1986     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1987     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1988   
;;;1989     tmpccmr2 = TIMx->CCMR2;
;;;1990   
;;;1991     /* Reset the OC3CE Bit */
;;;1992     tmpccmr2 &= CCMR_OC13CE_Reset;
00082e  f0220280          BIC      r2,r2,#0x80
;;;1993   
;;;1994     /* Enable or Disable the Output Compare Clear Bit */
;;;1995     tmpccmr2 |= TIM_OCClear;
000832  4311              ORRS     r1,r1,r2
;;;1996   
;;;1997     /* Write to TIMx CCMR2 register */
;;;1998     TIMx->CCMR2 = tmpccmr2;
000834  8381              STRH     r1,[r0,#0x1c]
;;;1999   }
000836  4770              BX       lr
;;;2000   
                          ENDP

                  TIM_ClearOC4Ref PROC
;;;2012   *******************************************************************************/
;;;2013   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
000838  8b82              LDRH     r2,[r0,#0x1c]
;;;2014   {
;;;2015     u16 tmpccmr2 = 0;
;;;2016   
;;;2017     /* Check the parameters */
;;;2018     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2019     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;2020   
;;;2021     tmpccmr2 = TIMx->CCMR2;
;;;2022   
;;;2023     /* Reset the OC4CE Bit */
;;;2024     tmpccmr2 &= CCMR_OC24CE_Reset;
00083a  f3c2020e          UBFX     r2,r2,#0,#15
;;;2025   
;;;2026     /* Enable or Disable the Output Compare Clear Bit */
;;;2027     tmpccmr2 |= (u16)(TIM_OCClear << 8);
00083e  f64f73ff          MOV      r3,#0xffff
000842  ea032101          AND      r1,r3,r1,LSL #8
000846  4311              ORRS     r1,r1,r2
;;;2028   
;;;2029     /* Write to TIMx CCMR2 register */
;;;2030     TIMx->CCMR2 = tmpccmr2;
000848  8381              STRH     r1,[r0,#0x1c]
;;;2031   }
00084a  4770              BX       lr
;;;2032   
                          ENDP

                  TIM_OC1PolarityConfig PROC
;;;2044   *******************************************************************************/
;;;2045   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
00084c  8c02              LDRH     r2,[r0,#0x20]
;;;2046   {
;;;2047     u16 tmpccer = 0;
;;;2048   
;;;2049     /* Check the parameters */
;;;2050     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2051     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2052   
;;;2053     tmpccer = TIMx->CCER;
;;;2054   
;;;2055     /* Set or Reset the CC1P Bit */
;;;2056     tmpccer &= CCER_CC1P_Reset;
00084e  f0220202          BIC      r2,r2,#2
;;;2057     tmpccer |= TIM_OCPolarity;
000852  4311              ORRS     r1,r1,r2
;;;2058   
;;;2059     /* Write to TIMx CCER register */
;;;2060     TIMx->CCER = tmpccer;
000854  8401              STRH     r1,[r0,#0x20]
;;;2061   }
000856  4770              BX       lr
;;;2062   
                          ENDP

                  TIM_OC1NPolarityConfig PROC
;;;2073   *******************************************************************************/
;;;2074   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
000858  8c02              LDRH     r2,[r0,#0x20]
;;;2075   {
;;;2076     u16 tmpccer = 0;
;;;2077   
;;;2078     /* Check the parameters */
;;;2079     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2080     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2081      
;;;2082     tmpccer = TIMx->CCER;
;;;2083   
;;;2084     /* Set or Reset the CC1NP Bit */
;;;2085     tmpccer &= CCER_CC1NP_Reset;
00085a  f0220208          BIC      r2,r2,#8
;;;2086     tmpccer |= TIM_OCNPolarity;
00085e  4311              ORRS     r1,r1,r2
;;;2087   
;;;2088     /* Write to TIMx CCER register */
;;;2089     TIMx->CCER = tmpccer;
000860  8401              STRH     r1,[r0,#0x20]
;;;2090   }
000862  4770              BX       lr
;;;2091   
                          ENDP

                  TIM_OC2PolarityConfig PROC
;;;2103   *******************************************************************************/
;;;2104   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
000864  8c02              LDRH     r2,[r0,#0x20]
;;;2105   {
;;;2106     u16 tmpccer = 0;
;;;2107   
;;;2108     /* Check the parameters */
;;;2109     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2110     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2111   
;;;2112     tmpccer = TIMx->CCER;
;;;2113   
;;;2114     /* Set or Reset the CC2P Bit */
;;;2115     tmpccer &= CCER_CC2P_Reset;
000866  f0220220          BIC      r2,r2,#0x20
;;;2116     tmpccer |= (u16)(TIM_OCPolarity << 4);
00086a  f64f73ff          MOV      r3,#0xffff
00086e  ea031101          AND      r1,r3,r1,LSL #4
000872  4311              ORRS     r1,r1,r2
;;;2117   
;;;2118     /* Write to TIMx CCER register */
;;;2119     TIMx->CCER = tmpccer;
000874  8401              STRH     r1,[r0,#0x20]
;;;2120   }
000876  4770              BX       lr
;;;2121   
                          ENDP

                  TIM_OC2NPolarityConfig PROC
;;;2132   *******************************************************************************/
;;;2133   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
000878  8c02              LDRH     r2,[r0,#0x20]
;;;2134   {
;;;2135     u16 tmpccer = 0;
;;;2136   
;;;2137     /* Check the parameters */
;;;2138     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2139     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2140     
;;;2141     tmpccer = TIMx->CCER;
;;;2142   
;;;2143     /* Set or Reset the CC2NP Bit */
;;;2144     tmpccer &= CCER_CC2NP_Reset;
00087a  f0220280          BIC      r2,r2,#0x80
;;;2145     tmpccer |= (u16)(TIM_OCNPolarity << 4);
00087e  f64f73ff          MOV      r3,#0xffff
000882  ea031101          AND      r1,r3,r1,LSL #4
000886  4311              ORRS     r1,r1,r2
;;;2146   
;;;2147     /* Write to TIMx CCER register */
;;;2148     TIMx->CCER = tmpccer;
000888  8401              STRH     r1,[r0,#0x20]
;;;2149   }
00088a  4770              BX       lr
;;;2150   
                          ENDP

                  TIM_OC3PolarityConfig PROC
;;;2162   *******************************************************************************/
;;;2163   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
00088c  8c02              LDRH     r2,[r0,#0x20]
;;;2164   {
;;;2165     u16 tmpccer = 0;
;;;2166   
;;;2167     /* Check the parameters */
;;;2168     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2169     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2170   
;;;2171     tmpccer = TIMx->CCER;
;;;2172   
;;;2173     /* Set or Reset the CC3P Bit */
;;;2174     tmpccer &= CCER_CC3P_Reset;
00088e  f4227200          BIC      r2,r2,#0x200
;;;2175     tmpccer |= (u16)(TIM_OCPolarity << 8);
000892  f64f73ff          MOV      r3,#0xffff
000896  ea032101          AND      r1,r3,r1,LSL #8
00089a  4311              ORRS     r1,r1,r2
;;;2176   
;;;2177     /* Write to TIMx CCER register */
;;;2178     TIMx->CCER = tmpccer;
00089c  8401              STRH     r1,[r0,#0x20]
;;;2179   }
00089e  4770              BX       lr
;;;2180   
                          ENDP

                  TIM_OC3NPolarityConfig PROC
;;;2191   *******************************************************************************/
;;;2192   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
0008a0  8c02              LDRH     r2,[r0,#0x20]
;;;2193   {
;;;2194     u16 tmpccer = 0;
;;;2195    
;;;2196     /* Check the parameters */
;;;2197     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2198     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;2199       
;;;2200     tmpccer = TIMx->CCER;
;;;2201   
;;;2202     /* Set or Reset the CC3NP Bit */
;;;2203     tmpccer &= CCER_CC3NP_Reset;
0008a2  f4226200          BIC      r2,r2,#0x800
;;;2204     tmpccer |= (u16)(TIM_OCNPolarity << 8);
0008a6  f64f73ff          MOV      r3,#0xffff
0008aa  ea032101          AND      r1,r3,r1,LSL #8
0008ae  4311              ORRS     r1,r1,r2
;;;2205   
;;;2206     /* Write to TIMx CCER register */
;;;2207     TIMx->CCER = tmpccer;
0008b0  8401              STRH     r1,[r0,#0x20]
;;;2208   }
0008b2  4770              BX       lr
;;;2209   
                          ENDP

                  TIM_OC4PolarityConfig PROC
;;;2221   *******************************************************************************/
;;;2222   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
0008b4  8c02              LDRH     r2,[r0,#0x20]
;;;2223   {
;;;2224     u16 tmpccer = 0;
;;;2225   
;;;2226     /* Check the parameters */
;;;2227     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2228     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;2229   
;;;2230     tmpccer = TIMx->CCER;
;;;2231   
;;;2232     /* Set or Reset the CC4P Bit */
;;;2233     tmpccer &= CCER_CC4P_Reset;
0008b6  f4225200          BIC      r2,r2,#0x2000
;;;2234     tmpccer |= (u16)(TIM_OCPolarity << 12);
0008ba  f64f73ff          MOV      r3,#0xffff
0008be  ea033101          AND      r1,r3,r1,LSL #12
0008c2  4311              ORRS     r1,r1,r2
;;;2235   
;;;2236     /* Write to TIMx CCER register */
;;;2237     TIMx->CCER = tmpccer;
0008c4  8401              STRH     r1,[r0,#0x20]
;;;2238   }
0008c6  4770              BX       lr
;;;2239   
                          ENDP

                  TIM_CCxCmd PROC
;;;2255   *******************************************************************************/
;;;2256   void TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx)
0008c8  8c03              LDRH     r3,[r0,#0x20]
;;;2257   {
;;;2258     /* Check the parameters */
;;;2259     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2260     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2261     assert_param(IS_TIM_CCX(TIM_CCx));
;;;2262   
;;;2263     /* Reset the CCxE Bit */
;;;2264     TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
0008ca  f04f0c01          MOV      r12,#1
0008ce  fa0cfc01          LSL      r12,r12,r1
0008d2  ea23030c          BIC      r3,r3,r12
0008d6  8403              STRH     r3,[r0,#0x20]
;;;2265   
;;;2266     /* Set or reset the CCxE Bit */ 
;;;2267     TIMx->CCER |=  (u16)(TIM_CCx << TIM_Channel);
0008d8  8c03              LDRH     r3,[r0,#0x20]
0008da  fa02f101          LSL      r1,r2,r1
0008de  4319              ORRS     r1,r1,r3
0008e0  8401              STRH     r1,[r0,#0x20]
;;;2268   }
0008e2  4770              BX       lr
;;;2269   
                          ENDP

                  TIM_CCxNCmd PROC
;;;2283   *******************************************************************************/
;;;2284   void TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN)
0008e4  8c03              LDRH     r3,[r0,#0x20]
;;;2285   {
;;;2286     /* Check the parameters */
;;;2287     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2288     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2289     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2290   
;;;2291     /* Reset the CCxNE Bit */
;;;2292     TIMx->CCER &= (u16)(~((u16)(CCER_CCNE_Set << TIM_Channel)));
0008e6  f04f0c04          MOV      r12,#4
0008ea  fa0cfc01          LSL      r12,r12,r1
0008ee  ea23030c          BIC      r3,r3,r12
0008f2  8403              STRH     r3,[r0,#0x20]
;;;2293   
;;;2294     /* Set or reset the CCxNE Bit */ 
;;;2295     TIMx->CCER |=  (u16)(TIM_CCxN << TIM_Channel);
0008f4  8c03              LDRH     r3,[r0,#0x20]
0008f6  fa02f101          LSL      r1,r2,r1
0008fa  4319              ORRS     r1,r1,r3
0008fc  8401              STRH     r1,[r0,#0x20]
;;;2296   }
0008fe  4770              BX       lr
;;;2297   
                          ENDP

                  TIM_SelectOCxM PROC
;;;2323   *******************************************************************************/
;;;2324   void TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode)
000900  8c03              LDRH     r3,[r0,#0x20]
;;;2325   {
;;;2326     /* Check the parameters */
;;;2327     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2328     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2329     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2330     
;;;2331     /* Disable the Channel: Reset the CCxE Bit */
;;;2332     TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
000902  f04f0c01          MOV      r12,#1
000906  fa0cfc01          LSL      r12,r12,r1
00090a  ea23030c          BIC      r3,r3,r12
00090e  8403              STRH     r3,[r0,#0x20]
;;;2333   
;;;2334     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000910  2900              CMP      r1,#0
000912  d010              BEQ      |L1.2358|
000914  2908              CMP      r1,#8
000916  d00e              BEQ      |L1.2358|
;;;2335     {
;;;2336       /* Reset the OCxM bits in the CCMRx register */
;;;2337       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
;;;2338      
;;;2339       /* Configure the OCxM bits in the CCMRx register */
;;;2340       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) = TIM_OCMode;
;;;2341   
;;;2342     }
;;;2343     else
;;;2344     {
;;;2345       /* Reset the OCxM bits in the CCMRx register */
;;;2346       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
000918  1f09              SUBS     r1,r1,#4
00091a  f3c1014e          UBFX     r1,r1,#1,#15
00091e  4408              ADD      r0,r0,r1
000920  6981              LDR      r1,[r0,#0x18]
000922  f64873ff          MOV      r3,#0x8fff
000926  4019              ANDS     r1,r1,r3
000928  6181              STR      r1,[r0,#0x18]
;;;2347       
;;;2348       /* Configure the OCxM bits in the CCMRx register */
;;;2349       *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) = (u16)(TIM_OCMode << 8);
00092a  f64f71ff          MOV      r1,#0xffff
00092e  ea012102          AND      r1,r1,r2,LSL #8
000932  6181              STR      r1,[r0,#0x18]
;;;2350     }
;;;2351   }
000934  4770              BX       lr
                  |L1.2358|
000936  eb000051          ADD      r0,r0,r1,LSR #1       ;2337
00093a  6981              LDR      r1,[r0,#0x18]         ;2337
00093c  f64f738f          MOV      r3,#0xff8f            ;2337
000940  4019              ANDS     r1,r1,r3              ;2337
000942  6181              STR      r1,[r0,#0x18]         ;2337
000944  6182              STR      r2,[r0,#0x18]         ;2340
000946  4770              BX       lr
;;;2352   
                          ENDP

                  TIM_UpdateDisableConfig PROC
;;;2361   *******************************************************************************/
;;;2362   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000948  2900              CMP      r1,#0
;;;2363   {
00094a  d004              BEQ      |L1.2390|
;;;2364     /* Check the parameters */
;;;2365     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2366     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2367   
;;;2368     if (NewState != DISABLE)
;;;2369     {
;;;2370       /* Set the Update Disable Bit */
;;;2371       TIMx->CR1 |= CR1_UDIS_Set;
00094c  8801              LDRH     r1,[r0,#0]
00094e  f0410102          ORR      r1,r1,#2
000952  8001              STRH     r1,[r0,#0]
;;;2372     }
;;;2373     else
;;;2374     {
;;;2375       /* Reset the Update Disable Bit */
;;;2376       TIMx->CR1 &= CR1_UDIS_Reset;
;;;2377     }
;;;2378   }
000954  4770              BX       lr
                  |L1.2390|
000956  8801              LDRH     r1,[r0,#0]            ;2376
000958  f0210102          BIC      r1,r1,#2              ;2376
00095c  f421417c          BIC      r1,r1,#0xfc00         ;2376
000960  8001              STRH     r1,[r0,#0]            ;2376
000962  4770              BX       lr
;;;2379   
                          ENDP

                  TIM_UpdateRequestConfig PROC
;;;2390   *******************************************************************************/
;;;2391   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
000964  2900              CMP      r1,#0
;;;2392   {
000966  d004              BEQ      |L1.2418|
;;;2393     /* Check the parameters */
;;;2394     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2395     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2396   
;;;2397     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2398     {
;;;2399       /* Set the URS Bit */
;;;2400       TIMx->CR1 |= CR1_URS_Set;
000968  8801              LDRH     r1,[r0,#0]
00096a  f0410104          ORR      r1,r1,#4
00096e  8001              STRH     r1,[r0,#0]
;;;2401     }
;;;2402     else
;;;2403     {
;;;2404       /* Reset the URS Bit */
;;;2405       TIMx->CR1 &= CR1_URS_Reset;
;;;2406     }
;;;2407   }
000970  4770              BX       lr
                  |L1.2418|
000972  8801              LDRH     r1,[r0,#0]            ;2405
000974  f0210104          BIC      r1,r1,#4              ;2405
000978  f421417c          BIC      r1,r1,#0xfc00         ;2405
00097c  8001              STRH     r1,[r0,#0]            ;2405
00097e  4770              BX       lr
;;;2408   
                          ENDP

                  TIM_SelectHallSensor PROC
;;;2417   *******************************************************************************/
;;;2418   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000980  2900              CMP      r1,#0
;;;2419   {
000982  d004              BEQ      |L1.2446|
;;;2420     /* Check the parameters */
;;;2421     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2422     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2423   
;;;2424     if (NewState != DISABLE)
;;;2425     {
;;;2426       /* Set the TI1S Bit */
;;;2427       TIMx->CR2 |= CR2_TI1S_Set;
000984  8881              LDRH     r1,[r0,#4]
000986  f0410180          ORR      r1,r1,#0x80
00098a  8081              STRH     r1,[r0,#4]
;;;2428     }
;;;2429     else
;;;2430     {
;;;2431       /* Reset the TI1S Bit */
;;;2432       TIMx->CR2 &= CR2_TI1S_Reset;
;;;2433     }
;;;2434   }
00098c  4770              BX       lr
                  |L1.2446|
00098e  8881              LDRH     r1,[r0,#4]            ;2432
000990  f0210180          BIC      r1,r1,#0x80           ;2432
000994  8081              STRH     r1,[r0,#4]            ;2432
000996  4770              BX       lr
;;;2435   
                          ENDP

                  TIM_SelectOnePulseMode PROC
;;;2446   *******************************************************************************/
;;;2447   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
000998  8802              LDRH     r2,[r0,#0]
;;;2448   {
;;;2449     /* Check the parameters */
;;;2450     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2451     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2452   
;;;2453     /* Reset the OPM Bit */
;;;2454     TIMx->CR1 &= CR1_OPM_Reset;
00099a  f4226281          BIC      r2,r2,#0x408
00099e  f4224278          BIC      r2,r2,#0xf800
0009a2  8002              STRH     r2,[r0,#0]
;;;2455   
;;;2456     /* Configure the OPM Mode */
;;;2457     TIMx->CR1 |= TIM_OPMode;
0009a4  8802              LDRH     r2,[r0,#0]
0009a6  4311              ORRS     r1,r1,r2
0009a8  8001              STRH     r1,[r0,#0]
;;;2458   }
0009aa  4770              BX       lr
;;;2459   
                          ENDP

                  TIM_SelectOutputTrigger PROC
;;;2479   *******************************************************************************/
;;;2480   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
0009ac  8882              LDRH     r2,[r0,#4]
;;;2481   {
;;;2482     /* Check the parameters */
;;;2483     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2484     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2485     assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
;;;2486   
;;;2487     /* Reset the MMS Bits */
;;;2488     TIMx->CR2 &= CR2_MMS_Mask;
0009ae  f0220270          BIC      r2,r2,#0x70
0009b2  8082              STRH     r2,[r0,#4]
;;;2489   
;;;2490     /* Select the TRGO source */
;;;2491     TIMx->CR2 |=  TIM_TRGOSource;
0009b4  8882              LDRH     r2,[r0,#4]
0009b6  4311              ORRS     r1,r1,r2
0009b8  8081              STRH     r1,[r0,#4]
;;;2492   }
0009ba  4770              BX       lr
;;;2493   
                          ENDP

                  TIM_SelectSlaveMode PROC
;;;2507   *******************************************************************************/
;;;2508   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
0009bc  8902              LDRH     r2,[r0,#8]
;;;2509   {
;;;2510     /* Check the parameters */
;;;2511     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2512     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2513   
;;;2514     /* Reset the SMS Bits */
;;;2515     TIMx->SMCR &= SMCR_SMS_Mask;
0009be  f0220207          BIC      r2,r2,#7
0009c2  8102              STRH     r2,[r0,#8]
;;;2516   
;;;2517     /* Select the Slave Mode */
;;;2518     TIMx->SMCR |= TIM_SlaveMode;
0009c4  8902              LDRH     r2,[r0,#8]
0009c6  4311              ORRS     r1,r1,r2
0009c8  8101              STRH     r1,[r0,#8]
;;;2519   }
0009ca  4770              BX       lr
;;;2520   
                          ENDP

                  TIM_SelectMasterSlaveMode PROC
;;;2533   *******************************************************************************/
;;;2534   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
0009cc  8902              LDRH     r2,[r0,#8]
;;;2535   {
;;;2536     /* Check the parameters */
;;;2537     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2538     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2539   
;;;2540     /* Reset the MSM Bit */
;;;2541     TIMx->SMCR &= SMCR_MSM_Reset;
0009ce  f0220280          BIC      r2,r2,#0x80
0009d2  8102              STRH     r2,[r0,#8]
;;;2542     
;;;2543     /* Set or Reset the MSM Bit */
;;;2544     TIMx->SMCR |= TIM_MasterSlaveMode;
0009d4  8902              LDRH     r2,[r0,#8]
0009d6  4311              ORRS     r1,r1,r2
0009d8  8101              STRH     r1,[r0,#8]
;;;2545   }
0009da  4770              BX       lr
;;;2546   
                          ENDP

                  TIM_SetCounter PROC
;;;2554   *******************************************************************************/
;;;2555   void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
0009dc  8481              STRH     r1,[r0,#0x24]
;;;2556   {
;;;2557     /* Check the parameters */
;;;2558     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2559   
;;;2560     /* Set the Counter Register value */
;;;2561     TIMx->CNT = Counter;
;;;2562   }
0009de  4770              BX       lr
;;;2563   
                          ENDP

                  TIM_SetAutoreload PROC
;;;2571   *******************************************************************************/
;;;2572   void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
0009e0  8581              STRH     r1,[r0,#0x2c]
;;;2573   {
;;;2574     /* Check the parameters */
;;;2575     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2576   
;;;2577     /* Set the Autoreload Register value */
;;;2578     TIMx->ARR = Autoreload;
;;;2579   }
0009e2  4770              BX       lr
;;;2580   
                          ENDP

                  TIM_SetCompare1 PROC
;;;2589   *******************************************************************************/
;;;2590   void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
0009e4  8681              STRH     r1,[r0,#0x34]
;;;2591   {
;;;2592     /* Check the parameters */
;;;2593     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2594   
;;;2595     /* Set the Capture Compare1 Register value */
;;;2596     TIMx->CCR1 = Compare1;
;;;2597   }
0009e6  4770              BX       lr
;;;2598   
                          ENDP

                  TIM_SetCompare2 PROC
;;;2607   *******************************************************************************/
;;;2608   void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
0009e8  8701              STRH     r1,[r0,#0x38]
;;;2609   {
;;;2610     /* Check the parameters */
;;;2611     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2612   
;;;2613     /* Set the Capture Compare2 Register value */
;;;2614     TIMx->CCR2 = Compare2;
;;;2615   }
0009ea  4770              BX       lr
;;;2616   
                          ENDP

                  TIM_SetCompare3 PROC
;;;2625   *******************************************************************************/
;;;2626   void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
0009ec  8781              STRH     r1,[r0,#0x3c]
;;;2627   {
;;;2628     /* Check the parameters */
;;;2629     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2630   
;;;2631     /* Set the Capture Compare3 Register value */
;;;2632     TIMx->CCR3 = Compare3;
;;;2633   }
0009ee  4770              BX       lr
;;;2634   
                          ENDP

                  TIM_SetCompare4 PROC
;;;2643   *******************************************************************************/
;;;2644   void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
0009f0  f8a01040          STRH     r1,[r0,#0x40]
;;;2645   {
;;;2646     /* Check the parameters */
;;;2647     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2648   
;;;2649     /* Set the Capture Compare4 Register value */
;;;2650     TIMx->CCR4 = Compare4;
;;;2651   }
0009f4  4770              BX       lr
;;;2652   
                          ENDP

                  TIM_SetClockDivision PROC
;;;2777   *******************************************************************************/
;;;2778   void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
0009f6  8802              LDRH     r2,[r0,#0]
;;;2779   {
;;;2780     /* Check the parameters */
;;;2781     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2782     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2783   
;;;2784     /* Reset the CKD Bits */
;;;2785     TIMx->CR1 &= CR1_CKD_Mask;
0009f8  b2d2              UXTB     r2,r2
0009fa  8002              STRH     r2,[r0,#0]
;;;2786   
;;;2787     /* Set the CKD value */
;;;2788     TIMx->CR1 |= TIM_CKD;
0009fc  8802              LDRH     r2,[r0,#0]
0009fe  4311              ORRS     r1,r1,r2
000a00  8001              STRH     r1,[r0,#0]
;;;2789   }
000a02  4770              BX       lr
;;;2790   /*******************************************************************************
                          ENDP

                  TIM_GetCapture1 PROC
;;;2797   *******************************************************************************/
;;;2798   u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
000a04  8e80              LDRH     r0,[r0,#0x34]
;;;2799   {
;;;2800     /* Check the parameters */
;;;2801     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2802   
;;;2803     /* Get the Capture 1 Register value */
;;;2804     return TIMx->CCR1;
;;;2805   }
000a06  4770              BX       lr
;;;2806   
                          ENDP

                  TIM_GetCapture2 PROC
;;;2814   *******************************************************************************/
;;;2815   u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
000a08  8f00              LDRH     r0,[r0,#0x38]
;;;2816   {
;;;2817     /* Check the parameters */
;;;2818     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2819   
;;;2820     /* Get the Capture 2 Register value */
;;;2821     return TIMx->CCR2;
;;;2822   }
000a0a  4770              BX       lr
;;;2823   
                          ENDP

                  TIM_GetCapture3 PROC
;;;2831   *******************************************************************************/
;;;2832   u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
000a0c  8f80              LDRH     r0,[r0,#0x3c]
;;;2833   {
;;;2834     /* Check the parameters */
;;;2835     assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;2836   
;;;2837     /* Get the Capture 3 Register value */
;;;2838     return TIMx->CCR3;
;;;2839   }
000a0e  4770              BX       lr
;;;2840   
                          ENDP

                  TIM_GetCapture4 PROC
;;;2848   *******************************************************************************/
;;;2849   u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
000a10  f8b00040          LDRH     r0,[r0,#0x40]
;;;2850   {
;;;2851     /* Check the parameters */
;;;2852     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2853   
;;;2854     /* Get the Capture 4 Register value */
;;;2855     return TIMx->CCR4;
;;;2856   }
000a14  4770              BX       lr
;;;2857   
                          ENDP

                  TIM_GetCounter PROC
;;;2864   *******************************************************************************/
;;;2865   u16 TIM_GetCounter(TIM_TypeDef* TIMx)
000a16  8c80              LDRH     r0,[r0,#0x24]
;;;2866   {
;;;2867     /* Check the parameters */
;;;2868     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2869   
;;;2870     /* Get the Counter Register value */
;;;2871     return TIMx->CNT;
;;;2872   }
000a18  4770              BX       lr
;;;2873   
                          ENDP

                  TIM_GetPrescaler PROC
;;;2880   *******************************************************************************/
;;;2881   u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
000a1a  8d00              LDRH     r0,[r0,#0x28]
;;;2882   {
;;;2883     /* Check the parameters */
;;;2884     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2885   
;;;2886     /* Get the Prescaler Register value */
;;;2887     return TIMx->PSC;
;;;2888   }
000a1c  4770              BX       lr
;;;2889   
                          ENDP

                  TIM_GetFlagStatus PROC
;;;2910   *******************************************************************************/
;;;2911   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
000a1e  4602              MOV      r2,r0
;;;2912   { 
;;;2913     ITStatus bitstatus = RESET;  
000a20  2000              MOVS     r0,#0
;;;2914   
;;;2915     /* Check the parameters */
;;;2916     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2917     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2918     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;2919     
;;;2920     if ((TIMx->SR & TIM_FLAG) != (u16)RESET)
000a22  8a12              LDRH     r2,[r2,#0x10]
000a24  420a              TST      r2,r1
000a26  d000              BEQ      |L1.2602|
;;;2921     {
;;;2922       bitstatus = SET;
000a28  2001              MOVS     r0,#1
                  |L1.2602|
;;;2923     }
;;;2924     else
;;;2925     {
;;;2926       bitstatus = RESET;
;;;2927     }
;;;2928     return bitstatus;
;;;2929   }
000a2a  4770              BX       lr
;;;2930   
                          ENDP

                  TIM_ClearFlag PROC
;;;2951   *******************************************************************************/
;;;2952   void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
000a2c  43c9              MVNS     r1,r1
;;;2953   {  
;;;2954     /* Check the parameters */
;;;2955     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2956     assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
;;;2957     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;2958      
;;;2959     /* Clear the flags */
;;;2960     TIMx->SR = (u16)~TIM_FLAG;
000a2e  8201              STRH     r1,[r0,#0x10]
;;;2961   }
000a30  4770              BX       lr
;;;2962   
                          ENDP

                  TIM_GetITStatus PROC
;;;2980   *******************************************************************************/
;;;2981   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
000a32  2200              MOVS     r2,#0
;;;2982   {
;;;2983     ITStatus bitstatus = RESET;  
;;;2984     u16 itstatus = 0x0, itenable = 0x0;
;;;2985   
;;;2986     /* Check the parameters */
;;;2987     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2988     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2989     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;2990      
;;;2991     itstatus = TIMx->SR & TIM_IT;
000a34  8a03              LDRH     r3,[r0,#0x10]
000a36  400b              ANDS     r3,r3,r1
;;;2992     
;;;2993     itenable = TIMx->DIER & TIM_IT;
000a38  8980              LDRH     r0,[r0,#0xc]
000a3a  4008              ANDS     r0,r0,r1
;;;2994   
;;;2995     if ((itstatus != (u16)RESET) && (itenable != (u16)RESET))
000a3c  2b00              CMP      r3,#0
000a3e  d001              BEQ      |L1.2628|
000a40  b100              CBZ      r0,|L1.2628|
;;;2996     {
;;;2997       bitstatus = SET;
000a42  2201              MOVS     r2,#1
                  |L1.2628|
;;;2998     }
;;;2999     else
;;;3000     {
;;;3001       bitstatus = RESET;
;;;3002     }
;;;3003     return bitstatus;
000a44  4610              MOV      r0,r2
;;;3004   }
000a46  4770              BX       lr
;;;3005   
                          ENDP

                  TIM_ClearITPendingBit PROC
;;;3023   *******************************************************************************/
;;;3024   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
000a48  43c9              MVNS     r1,r1
;;;3025   {
;;;3026     /* Check the parameters */
;;;3027     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;3028     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;3029   
;;;3030     /* Clear the IT pending Bit */
;;;3031     TIMx->SR = (u16)~TIM_IT;
000a4a  8201              STRH     r1,[r0,#0x10]
;;;3032   }
000a4c  4770              BX       lr
;;;3033   
                          ENDP

