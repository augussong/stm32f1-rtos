; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\rvmdk\os_core.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\os_core.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime --diag_suppress=9931 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I.\RTE\_Flash -I"C:\Program Files\0Software\Keil_v5\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"C:\Program Files\0Software\Keil_v5\ARM\CMSIS\Include" -I"C:\Program Files\0Software\Keil_v5\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0" -D__MICROLIB -D__UVISION_VERSION=528 -DSTM32F10X_MD --omf_browse=.\rvmdk\os_core.crf ..\..\..\..\..\uCOS-II\Source\os_core.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OS_StrCopy PROC
;;;1695   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1696   INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
000000  2200              MOVS     r2,#0
;;;1697   {
;;;1698       INT8U  len;
;;;1699   
;;;1700   
;;;1701       len = 0;
;;;1702       while (*psrc != OS_ASCII_NUL) {
000002  780b              LDRB     r3,[r1,#0]
000004  2b00              CMP      r3,#0
000006  d008              BEQ      |L1.26|
                  |L1.8|
;;;1703           *pdest++ = *psrc++;
000008  f8113b01          LDRB     r3,[r1],#1
00000c  f8003b01          STRB     r3,[r0],#1
;;;1704           len++;
000010  1c52              ADDS     r2,r2,#1
000012  b2d2              UXTB     r2,r2
000014  780b              LDRB     r3,[r1,#0]            ;1702
000016  2b00              CMP      r3,#0                 ;1702
000018  d1f6              BNE      |L1.8|
                  |L1.26|
;;;1705       }
;;;1706       *pdest = OS_ASCII_NUL;
00001a  2100              MOVS     r1,#0
00001c  7001              STRB     r1,[r0,#0]
;;;1707       return (len);
00001e  4610              MOV      r0,r2
;;;1708   }
000020  4770              BX       lr
;;;1709   #endif
                          ENDP

                  OSEventNameGet PROC
;;;108    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;109    INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
000022  e92d41f0          PUSH     {r4-r8,lr}
;;;110    {
000026  4605              MOV      r5,r0
000028  460e              MOV      r6,r1
00002a  4614              MOV      r4,r2
;;;111        INT8U      len;
;;;112    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;113        OS_CPU_SR  cpu_sr = 0;
;;;114    #endif
;;;115    
;;;116    
;;;117    
;;;118    #if OS_ARG_CHK_EN > 0
;;;119        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;120            return (0);
;;;121        }
;;;122        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;123            *perr = OS_ERR_PEVENT_NULL;
;;;124            return (0);
;;;125        }
;;;126        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;127            *perr = OS_ERR_PNAME_NULL;
;;;128            return (0);
;;;129        }
;;;130    #endif
;;;131        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
00002c  48fe              LDR      r0,|L1.1064|
00002e  7880              LDRB     r0,[r0,#2]  ; OSIntNesting
000030  2800              CMP      r0,#0
000032  d004              BEQ      |L1.62|
;;;132            *perr  = OS_ERR_NAME_GET_ISR;
000034  2011              MOVS     r0,#0x11
000036  7020              STRB     r0,[r4,#0]
;;;133            return (0);
000038  2000              MOVS     r0,#0
;;;134        }
;;;135        switch (pevent->OSEventType) {
;;;136            case OS_EVENT_TYPE_SEM:
;;;137            case OS_EVENT_TYPE_MUTEX:
;;;138            case OS_EVENT_TYPE_MBOX:
;;;139            case OS_EVENT_TYPE_Q:
;;;140                 break;
;;;141    
;;;142            default:
;;;143                 *perr = OS_ERR_EVENT_TYPE;
;;;144                 return (0);
;;;145        }
;;;146        OS_ENTER_CRITICAL();
;;;147        len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
;;;148        OS_EXIT_CRITICAL();
;;;149        *perr = OS_ERR_NONE;
;;;150        return (len);
;;;151    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.62|
00003e  7828              LDRB     r0,[r5,#0]            ;135
000040  2801              CMP      r0,#1                 ;135
000042  d00a              BEQ      |L1.90|
000044  2802              CMP      r0,#2                 ;135
000046  d008              BEQ      |L1.90|
000048  2803              CMP      r0,#3                 ;135
00004a  d006              BEQ      |L1.90|
00004c  2804              CMP      r0,#4                 ;135
00004e  d004              BEQ      |L1.90|
000050  2001              MOVS     r0,#1                 ;143
000052  7020              STRB     r0,[r4,#0]            ;143
000054  2000              MOVS     r0,#0                 ;144
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L1.90|
00005a  f7fffffe          BL       OS_CPU_SR_Save
00005e  4607              MOV      r7,r0                 ;146
000060  f105010f          ADD      r1,r5,#0xf            ;147
000064  4630              MOV      r0,r6                 ;147
000066  f7fffffe          BL       OS_StrCopy
00006a  4605              MOV      r5,r0                 ;147
00006c  4638              MOV      r0,r7                 ;148
00006e  f7fffffe          BL       OS_CPU_SR_Restore
000072  2000              MOVS     r0,#0                 ;149
000074  7020              STRB     r0,[r4,#0]            ;149
000076  4628              MOV      r0,r5                 ;150
000078  e8bd81f0          POP      {r4-r8,pc}
;;;152    #endif
                          ENDP

                  OS_StrLen PROC
;;;1727   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1728   INT8U  OS_StrLen (INT8U *psrc)
00007c  2100              MOVS     r1,#0
;;;1729   {
;;;1730       INT8U  len;
;;;1731   
;;;1732   
;;;1733       len = 0;
;;;1734       while (*psrc != OS_ASCII_NUL) {
00007e  7802              LDRB     r2,[r0,#0]
000080  2a00              CMP      r2,#0
000082  d005              BEQ      |L1.144|
                  |L1.132|
;;;1735           psrc++;
000084  1c40              ADDS     r0,r0,#1
;;;1736           len++;
000086  1c49              ADDS     r1,r1,#1
000088  b2c9              UXTB     r1,r1
00008a  7802              LDRB     r2,[r0,#0]            ;1734
00008c  2a00              CMP      r2,#0                 ;1734
00008e  d1f9              BNE      |L1.132|
                  |L1.144|
;;;1737       }
;;;1738       return (len);
000090  4608              MOV      r0,r1
;;;1739   }
000092  4770              BX       lr
;;;1740   #endif
                          ENDP

                  OSEventNameSet PROC
;;;182    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;183    void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
000094  e92d41f0          PUSH     {r4-r8,lr}
;;;184    {
000098  4605              MOV      r5,r0
00009a  460e              MOV      r6,r1
00009c  4614              MOV      r4,r2
;;;185        INT8U      len;
;;;186    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;187        OS_CPU_SR  cpu_sr = 0;
;;;188    #endif
;;;189    
;;;190    
;;;191    
;;;192    #if OS_ARG_CHK_EN > 0
;;;193        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
;;;194            return;
;;;195        }
;;;196        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;197            *perr = OS_ERR_PEVENT_NULL;
;;;198            return;
;;;199        }
;;;200        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;201            *perr = OS_ERR_PNAME_NULL;
;;;202            return;
;;;203        }
;;;204    #endif
;;;205        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
00009e  48e2              LDR      r0,|L1.1064|
0000a0  7880              LDRB     r0,[r0,#2]  ; OSIntNesting
0000a2  2800              CMP      r0,#0
0000a4  d003              BEQ      |L1.174|
;;;206            *perr = OS_ERR_NAME_SET_ISR;
0000a6  2012              MOVS     r0,#0x12
0000a8  7020              STRB     r0,[r4,#0]
;;;207            return;
;;;208        }
;;;209        switch (pevent->OSEventType) {
;;;210            case OS_EVENT_TYPE_SEM:
;;;211            case OS_EVENT_TYPE_MUTEX:
;;;212            case OS_EVENT_TYPE_MBOX:
;;;213            case OS_EVENT_TYPE_Q:
;;;214                 break;
;;;215    
;;;216            default:
;;;217                 *perr = OS_ERR_EVENT_TYPE;
;;;218                 return;
;;;219        }
;;;220        OS_ENTER_CRITICAL();
;;;221        len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
;;;222        if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
;;;223            OS_EXIT_CRITICAL();
;;;224            *perr = OS_ERR_EVENT_NAME_TOO_LONG;
;;;225            return;
;;;226        }
;;;227        (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
;;;228        OS_EXIT_CRITICAL();
;;;229        *perr = OS_ERR_NONE;
;;;230    }
0000aa  e8bd81f0          POP      {r4-r8,pc}
                  |L1.174|
0000ae  7828              LDRB     r0,[r5,#0]            ;209
0000b0  2801              CMP      r0,#1                 ;209
0000b2  d009              BEQ      |L1.200|
0000b4  2802              CMP      r0,#2                 ;209
0000b6  d007              BEQ      |L1.200|
0000b8  2803              CMP      r0,#3                 ;209
0000ba  d005              BEQ      |L1.200|
0000bc  2804              CMP      r0,#4                 ;209
0000be  d003              BEQ      |L1.200|
0000c0  2001              MOVS     r0,#1                 ;217
0000c2  7020              STRB     r0,[r4,#0]            ;217
0000c4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.200|
0000c8  f7fffffe          BL       OS_CPU_SR_Save
0000cc  4607              MOV      r7,r0                 ;220
0000ce  4630              MOV      r0,r6                 ;221
0000d0  f7fffffe          BL       OS_StrLen
0000d4  280f              CMP      r0,#0xf               ;222
0000d6  d906              BLS      |L1.230|
0000d8  4638              MOV      r0,r7                 ;223
0000da  f7fffffe          BL       OS_CPU_SR_Restore
0000de  200b              MOVS     r0,#0xb               ;224
0000e0  7020              STRB     r0,[r4,#0]            ;224
0000e2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.230|
0000e6  4631              MOV      r1,r6                 ;227
0000e8  f105000f          ADD      r0,r5,#0xf            ;227
0000ec  f7fffffe          BL       OS_StrCopy
0000f0  4638              MOV      r0,r7                 ;228
0000f2  f7fffffe          BL       OS_CPU_SR_Restore
0000f6  2000              MOVS     r0,#0                 ;229
0000f8  7020              STRB     r0,[r4,#0]            ;229
0000fa  e8bd81f0          POP      {r4-r8,pc}
;;;231    #endif
                          ENDP

                  OS_EventTaskRemoveMulti PROC
;;;1163   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;1164   void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
0000fe  b430              PUSH     {r4,r5}
;;;1165                                  OS_EVENT **pevents_multi)
;;;1166   {
;;;1167       OS_EVENT **pevents;
;;;1168       OS_EVENT  *pevent;
;;;1169       INT8U      y;
;;;1170   #if (OS_LOWEST_PRIO <= 63)
;;;1171       INT8U      bity;
;;;1172       INT8U      bitx;
;;;1173   #else
;;;1174       INT16U     bity;
;;;1175       INT16U     bitx;
;;;1176   #endif
;;;1177   
;;;1178   
;;;1179       y       =  ptcb->OSTCBY;
000100  f890c034          LDRB     r12,[r0,#0x34]
;;;1180       bity    =  ptcb->OSTCBBitY;
000104  f8904036          LDRB     r4,[r0,#0x36]
;;;1181       bitx    =  ptcb->OSTCBBitX;
000108  f8905035          LDRB     r5,[r0,#0x35]
;;;1182       pevents =  pevents_multi;
;;;1183       pevent  = *pevents;
00010c  6808              LDR      r0,[r1,#0]
;;;1184       while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
00010e  2800              CMP      r0,#0
000110  d00c              BEQ      |L1.300|
                  |L1.274|
;;;1185           pevent->OSEventTbl[y]  &= ~bitx;
000112  eb00030c          ADD      r3,r0,r12
000116  7ada              LDRB     r2,[r3,#0xb]
000118  43aa              BICS     r2,r2,r5
00011a  72da              STRB     r2,[r3,#0xb]
;;;1186           if (pevent->OSEventTbl[y] == 0) {
00011c  b912              CBNZ     r2,|L1.292|
;;;1187               pevent->OSEventGrp &= ~bity;
00011e  7a82              LDRB     r2,[r0,#0xa]
000120  43a2              BICS     r2,r2,r4
000122  7282              STRB     r2,[r0,#0xa]
                  |L1.292|
;;;1188           }
;;;1189           pevents++;
000124  1d09              ADDS     r1,r1,#4
;;;1190           pevent = *pevents;
000126  6808              LDR      r0,[r1,#0]
000128  2800              CMP      r0,#0                 ;1184
00012a  d1f2              BNE      |L1.274|
                  |L1.300|
;;;1191       }
;;;1192   }
00012c  bc30              POP      {r4,r5}
00012e  4770              BX       lr
;;;1193   #endif
                          ENDP

                  OS_SchedNew PROC
;;;1647   
;;;1648   static  void  OS_SchedNew (void)
000130  49bd              LDR      r1,|L1.1064|
;;;1649   {
;;;1650   #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
;;;1651       INT8U   y;
;;;1652   
;;;1653   
;;;1654       y             = OSUnMapTbl[OSRdyGrp];
000132  4abe              LDR      r2,|L1.1068|
000134  7988              LDRB     r0,[r1,#6]  ; OSRdyGrp
000136  5c10              LDRB     r0,[r2,r0]
;;;1655       OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
000138  f101031c          ADD      r3,r1,#0x1c
00013c  5c1b              LDRB     r3,[r3,r0]
00013e  5cd2              LDRB     r2,[r2,r3]
000140  eb0200c0          ADD      r0,r2,r0,LSL #3
000144  7148              STRB     r0,[r1,#5]
;;;1656   #else                                            /* We support up to 256 tasks                         */
;;;1657       INT8U   y;
;;;1658       INT16U *ptbl;
;;;1659   
;;;1660   
;;;1661       if ((OSRdyGrp & 0xFF) != 0) {
;;;1662           y = OSUnMapTbl[OSRdyGrp & 0xFF];
;;;1663       } else {
;;;1664           y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
;;;1665       }
;;;1666       ptbl = &OSRdyTbl[y];
;;;1667       if ((*ptbl & 0xFF) != 0) {
;;;1668           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
;;;1669       } else {
;;;1670           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
;;;1671       }
;;;1672   #endif
;;;1673   }
000146  4770              BX       lr
;;;1674   
                          ENDP

                  OS_Sched PROC
;;;1605   
;;;1606   void  OS_Sched (void)
000148  b570              PUSH     {r4-r6,lr}
;;;1607   {
;;;1608   #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
;;;1609       OS_CPU_SR  cpu_sr = 0;
;;;1610   #endif
;;;1611   
;;;1612   
;;;1613   
;;;1614       OS_ENTER_CRITICAL();
00014a  f7fffffe          BL       OS_CPU_SR_Save
00014e  4605              MOV      r5,r0
;;;1615       if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
000150  4cb5              LDR      r4,|L1.1064|
000152  78a0              LDRB     r0,[r4,#2]  ; OSIntNesting
000154  b998              CBNZ     r0,|L1.382|
;;;1616           if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
000156  78e0              LDRB     r0,[r4,#3]  ; OSLockNesting
000158  b988              CBNZ     r0,|L1.382|
;;;1617               OS_SchedNew();
00015a  f7fffffe          BL       OS_SchedNew
;;;1618               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
00015e  7961              LDRB     r1,[r4,#5]  ; OSPrioHighRdy
000160  7920              LDRB     r0,[r4,#4]  ; OSPrioCur
000162  4281              CMP      r1,r0
000164  d00b              BEQ      |L1.382|
;;;1619                   OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000166  48b2              LDR      r0,|L1.1072|
000168  f8501021          LDR      r1,[r0,r1,LSL #2]
00016c  62e1              STR      r1,[r4,#0x2c]  ; OSTCBHighRdy
;;;1620   #if OS_TASK_PROFILE_EN > 0
;;;1621                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
00016e  6b88              LDR      r0,[r1,#0x38]
000170  1c40              ADDS     r0,r0,#1
000172  6388              STR      r0,[r1,#0x38]
;;;1622   #endif
;;;1623                   OSCtxSwCtr++;                          /* Increment context switch counter             */
000174  68e0              LDR      r0,[r4,#0xc]  ; OSCtxSwCtr
000176  1c40              ADDS     r0,r0,#1
000178  60e0              STR      r0,[r4,#0xc]  ; OSCtxSwCtr
;;;1624                   OS_TASK_SW();                          /* Perform a context switch                     */
00017a  f7fffffe          BL       OSCtxSw
                  |L1.382|
;;;1625               }
;;;1626           }
;;;1627       }
;;;1628       OS_EXIT_CRITICAL();
00017e  4628              MOV      r0,r5
000180  e8bd4070          POP      {r4-r6,lr}
000184  f7ffbffe          B.W      OS_CPU_SR_Restore
;;;1629   }
;;;1630   
                          ENDP

                  OS_EventTaskWaitMulti PROC
;;;1090   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;1091   void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
000188  b430              PUSH     {r4,r5}
;;;1092   {
;;;1093       OS_EVENT **pevents;
;;;1094       OS_EVENT  *pevent;
;;;1095       INT8U      y;
;;;1096   
;;;1097   
;;;1098       OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
00018a  4ca7              LDR      r4,|L1.1064|
00018c  2200              MOVS     r2,#0
00018e  6a61              LDR      r1,[r4,#0x24]  ; OSTCBCur
000190  61ca              STR      r2,[r1,#0x1c]
;;;1099       OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
000192  6208              STR      r0,[r1,#0x20]
;;;1100   
;;;1101       pevents =  pevents_wait;
;;;1102       pevent  = *pevents;
000194  6801              LDR      r1,[r0,#0]
;;;1103       while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
000196  2900              CMP      r1,#0
000198  d015              BEQ      |L1.454|
                  |L1.410|
;;;1104           pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
00019a  6a63              LDR      r3,[r4,#0x24]  ; OSTCBCur
00019c  f1010c0b          ADD      r12,r1,#0xb
0001a0  f8932034          LDRB     r2,[r3,#0x34]
0001a4  f8933035          LDRB     r3,[r3,#0x35]
0001a8  f812500c          LDRB     r5,[r2,r12]
0001ac  432b              ORRS     r3,r3,r5
0001ae  f802300c          STRB     r3,[r2,r12]
;;;1105           pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
0001b2  6a63              LDR      r3,[r4,#0x24]  ; OSTCBCur
0001b4  7a8a              LDRB     r2,[r1,#0xa]
0001b6  f8933036          LDRB     r3,[r3,#0x36]
0001ba  431a              ORRS     r2,r2,r3
0001bc  728a              STRB     r2,[r1,#0xa]
;;;1106           pevents++;
0001be  1d00              ADDS     r0,r0,#4
;;;1107           pevent = *pevents;
0001c0  6801              LDR      r1,[r0,#0]
0001c2  2900              CMP      r1,#0                 ;1103
0001c4  d1e9              BNE      |L1.410|
                  |L1.454|
;;;1108       }
;;;1109   
;;;1110       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
0001c6  6a60              LDR      r0,[r4,#0x24]  ; OSTCBCur
0001c8  f8901034          LDRB     r1,[r0,#0x34]
;;;1111       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
0001cc  4b99              LDR      r3,|L1.1076|
0001ce  f890c035          LDRB     r12,[r0,#0x35]
0001d2  5c5a              LDRB     r2,[r3,r1]
0001d4  ea22020c          BIC      r2,r2,r12
0001d8  545a              STRB     r2,[r3,r1]
;;;1112       if (OSRdyTbl[y] == 0) {
0001da  2a00              CMP      r2,#0
0001dc  d105              BNE      |L1.490|
;;;1113           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
0001de  f8900036          LDRB     r0,[r0,#0x36]
0001e2  79a1              LDRB     r1,[r4,#6]  ; OSRdyGrp
0001e4  ea210000          BIC      r0,r1,r0
0001e8  71a0              STRB     r0,[r4,#6]
                  |L1.490|
;;;1114       }
;;;1115   }
0001ea  bc30              POP      {r4,r5}
0001ec  4770              BX       lr
;;;1116   #endif
                          ENDP

                  OSEventPendMulti PROC
;;;305    #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;306    INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
0001ee  e92d4fff          PUSH     {r0-r11,lr}
;;;307    {
0001f2  b081              SUB      sp,sp,#4
0001f4  4682              MOV      r10,r0
0001f6  f8dd8038          LDR      r8,[sp,#0x38]
0001fa  460d              MOV      r5,r1
0001fc  4616              MOV      r6,r2
;;;308        OS_EVENT  **pevents;
;;;309        OS_EVENT   *pevent;
;;;310    #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;311        OS_Q       *pq;
;;;312    #endif
;;;313        BOOLEAN     events_rdy;
;;;314        INT16U      events_rdy_nbr;
;;;315        INT8U       events_stat;
;;;316    #if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
;;;317        OS_CPU_SR   cpu_sr = 0;
;;;318    #endif
;;;319    
;;;320    
;;;321    
;;;322    #if (OS_ARG_CHK_EN > 0)
;;;323        if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
;;;324            return (0);
;;;325        }
;;;326        if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
;;;327           *perr =  OS_ERR_PEVENT_NULL;
;;;328            return (0);
;;;329        }
;;;330        if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
;;;331           *perr =  OS_ERR_PEVENT_NULL;
;;;332            return (0);
;;;333        }
;;;334        if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
;;;335           *perr =  OS_ERR_PEVENT_NULL;
;;;336            return (0);
;;;337        }
;;;338    #endif
;;;339    
;;;340       *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
0001fe  f04f0900          MOV      r9,#0
000202  f8c59000          STR      r9,[r5,#0]
;;;341    
;;;342        pevents     =  pevents_pend;
000206  4650              MOV      r0,r10
;;;343        pevent      = *pevents;
000208  6801              LDR      r1,[r0,#0]
;;;344        while  (pevent != (OS_EVENT *)0) {
;;;345            switch (pevent->OSEventType) {                  /* Validate event block types                  */
00020a  f04f0b01          MOV      r11,#1
00020e  2900              CMP      r1,#0                 ;344
000210  d00e              BEQ      |L1.560|
                  |L1.530|
000212  7809              LDRB     r1,[r1,#0]
000214  2901              CMP      r1,#1
000216  d007              BEQ      |L1.552|
000218  2903              CMP      r1,#3
00021a  d005              BEQ      |L1.552|
;;;346    #if (OS_SEM_EN  > 0)
;;;347                case OS_EVENT_TYPE_SEM:
;;;348                     break;
;;;349    #endif
;;;350    #if (OS_MBOX_EN > 0)
;;;351                case OS_EVENT_TYPE_MBOX:
;;;352                     break;
;;;353    #endif
;;;354    #if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
;;;355                case OS_EVENT_TYPE_Q:
;;;356                     break;
;;;357    #endif
;;;358    
;;;359                case OS_EVENT_TYPE_MUTEX:                                            
;;;360                case OS_EVENT_TYPE_FLAG:
;;;361                default:           
;;;362                    *perr = OS_ERR_EVENT_TYPE;
00021c  f888b000          STRB     r11,[r8,#0]
;;;363                     return (0);
;;;364            }
;;;365            pevents++;
;;;366            pevent = *pevents;
;;;367        }
;;;368    
;;;369        if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
;;;370           *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
;;;371            return (0);
;;;372        }
;;;373        if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
;;;374           *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
;;;375            return (0);
;;;376        }
;;;377    
;;;378    /*$PAGE*/
;;;379        OS_ENTER_CRITICAL();
;;;380        events_rdy     =  OS_FALSE;
;;;381        events_rdy_nbr =  0;
;;;382        events_stat    =  OS_STAT_RDY;
;;;383        pevents        =  pevents_pend;
;;;384        pevent         = *pevents;
;;;385        while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
;;;386            switch (pevent->OSEventType) {
;;;387    #if (OS_SEM_EN > 0)
;;;388                case OS_EVENT_TYPE_SEM:
;;;389                     if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
;;;390                         pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
;;;391                        *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
;;;392                          events_rdy   =  OS_TRUE;
;;;393                        *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
;;;394                          events_rdy_nbr++;
;;;395    
;;;396                     } else {
;;;397                          events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
;;;398                     }
;;;399                     break;
;;;400    #endif
;;;401    
;;;402    #if (OS_MBOX_EN > 0)
;;;403                case OS_EVENT_TYPE_MBOX:
;;;404                     if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
;;;405                                                            /* ... return available message,           ... */
;;;406                        *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
;;;407                         pevent->OSEventPtr  = (void *)0;
;;;408                        *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
;;;409                          events_rdy         =  OS_TRUE;
;;;410                          events_rdy_nbr++;
;;;411    
;;;412                     } else {
;;;413                          events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
;;;414                     }
;;;415                     break;
;;;416    #endif
;;;417    
;;;418    #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;419                case OS_EVENT_TYPE_Q:
;;;420                     pq = (OS_Q *)pevent->OSEventPtr;
;;;421                     if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
;;;422                                                            /* ... return available message,           ... */
;;;423                        *pmsgs_rdy++ = (void *)*pq->OSQOut++;
;;;424                         if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
;;;425                             pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
;;;426                         }
;;;427                         pq->OSQEntries--;                  /* Update number of queue entries              */
;;;428                        *pevents_rdy++ = pevent;            /* ... and return available queue event        */
;;;429                          events_rdy   = OS_TRUE;
;;;430                          events_rdy_nbr++;
;;;431    
;;;432                     } else {
;;;433                          events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
;;;434                     }
;;;435                     break;
;;;436    #endif
;;;437    
;;;438                case OS_EVENT_TYPE_MUTEX:                                            
;;;439                case OS_EVENT_TYPE_FLAG:
;;;440                default:           
;;;441                     OS_EXIT_CRITICAL();
;;;442                    *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
;;;443                    *perr        =  OS_ERR_EVENT_TYPE;
;;;444                     return (events_rdy_nbr);
;;;445            }
;;;446            pevents++;
;;;447            pevent = *pevents;
;;;448        }
;;;449    
;;;450        if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
;;;451           *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
;;;452            OS_EXIT_CRITICAL();
;;;453           *perr        =  OS_ERR_NONE;
;;;454            return (events_rdy_nbr);
;;;455        }
;;;456    /*$PAGE*/
;;;457                                                            /* Otherwise, must wait until any event occurs */
;;;458        OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
;;;459                                   OS_STAT_MULTI;           /* ... pend on multiple events                 */
;;;460        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;461        OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
;;;462        OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
;;;463    
;;;464        OS_EXIT_CRITICAL();
;;;465        OS_Sched();                                         /* Find next highest priority task ready       */
;;;466        OS_ENTER_CRITICAL();
;;;467    
;;;468        switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
;;;469            case OS_STAT_PEND_OK:
;;;470            case OS_STAT_PEND_ABORT:
;;;471                 pevent = OSTCBCur->OSTCBEventPtr;
;;;472                 if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
;;;473                    *pevents_rdy++ =  pevent;               /* ... return available event ...              */
;;;474                    *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
;;;475                      events_rdy_nbr++;
;;;476    
;;;477                 } else {                                   /* Else NO event available, handle as timeout  */
;;;478                     OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
;;;479                     OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;480                 }
;;;481    			 break;
;;;482    
;;;483            case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
;;;484            default:                                        /* ... remove task from events' wait lists     */
;;;485                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;486                 break;
;;;487        }
;;;488    
;;;489        switch (OSTCBCur->OSTCBStatPend) {
;;;490            case OS_STAT_PEND_OK:
;;;491                 switch (pevent->OSEventType) {             /* Return event's message                      */
;;;492    #if (OS_SEM_EN > 0)
;;;493                     case OS_EVENT_TYPE_SEM:
;;;494                         *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
;;;495                          break;
;;;496    #endif
;;;497    
;;;498    #if ((OS_MBOX_EN > 0) ||                 \
;;;499        ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
;;;500                     case OS_EVENT_TYPE_MBOX:
;;;501                     case OS_EVENT_TYPE_Q:
;;;502                         *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
;;;503                          break;
;;;504    #endif
;;;505    
;;;506                     case OS_EVENT_TYPE_MUTEX:                                       
;;;507                     case OS_EVENT_TYPE_FLAG:
;;;508                     default:           
;;;509                          OS_EXIT_CRITICAL();
;;;510                         *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
;;;511                         *perr        =  OS_ERR_EVENT_TYPE;
;;;512                          return (events_rdy_nbr);
;;;513                 }
;;;514                *perr = OS_ERR_NONE;
;;;515                 break;
;;;516    
;;;517            case OS_STAT_PEND_ABORT:
;;;518                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
;;;519                *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
;;;520                 break;
;;;521                                                            
;;;522            case OS_STAT_PEND_TO:                                                
;;;523            default:        
;;;524                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
;;;525                *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
;;;526                 break;
;;;527        }
;;;528    
;;;529        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
;;;530        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
;;;531        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
;;;532        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;533        OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
;;;534        OS_EXIT_CRITICAL();
;;;535    
;;;536        return (events_rdy_nbr);
;;;537    }
000220  b005              ADD      sp,sp,#0x14
000222  2000              MOVS     r0,#0                 ;363
000224  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.552|
000228  1d00              ADDS     r0,r0,#4              ;365
00022a  6801              LDR      r1,[r0,#0]            ;366
00022c  2900              CMP      r1,#0                 ;348
00022e  d1f0              BNE      |L1.530|
                  |L1.560|
000230  487d              LDR      r0,|L1.1064|
000232  7881              LDRB     r1,[r0,#2]            ;369  ; OSIntNesting
000234  b131              CBZ      r1,|L1.580|
000236  2002              MOVS     r0,#2                 ;370
000238  f8880000          STRB     r0,[r8,#0]            ;370
00023c  b005              ADD      sp,sp,#0x14
00023e  2000              MOVS     r0,#0                 ;371
000240  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.580|
000244  4878              LDR      r0,|L1.1064|
000246  78c0              LDRB     r0,[r0,#3]            ;373  ; OSLockNesting
000248  b130              CBZ      r0,|L1.600|
00024a  200d              MOVS     r0,#0xd               ;374
00024c  f8880000          STRB     r0,[r8,#0]            ;374
000250  b005              ADD      sp,sp,#0x14
000252  2000              MOVS     r0,#0                 ;375
000254  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.600|
000258  f7fffffe          BL       OS_CPU_SR_Save
00025c  9000              STR      r0,[sp,#0]            ;379
00025e  2300              MOVS     r3,#0                 ;380
000260  2700              MOVS     r7,#0                 ;381
000262  2000              MOVS     r0,#0                 ;382
000264  4651              MOV      r1,r10                ;383
000266  680c              LDR      r4,[r1,#0]            ;384
000268  b384              CBZ      r4,|L1.716|
                  |L1.618|
00026a  7822              LDRB     r2,[r4,#0]            ;386
00026c  2a01              CMP      r2,#1                 ;386
00026e  d01b              BEQ      |L1.680|
000270  2a03              CMP      r2,#3                 ;386
000272  d00a              BEQ      |L1.650|
000274  9800              LDR      r0,[sp,#0]            ;441
000276  f7fffffe          BL       OS_CPU_SR_Restore
00027a  f8c59000          STR      r9,[r5,#0]            ;442
00027e  f888b000          STRB     r11,[r8,#0]           ;443
000282  b005              ADD      sp,sp,#0x14
000284  4638              MOV      r0,r7                 ;444
000286  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.650|
00028a  8922              LDRH     r2,[r4,#8]            ;389
00028c  b14a              CBZ      r2,|L1.674|
00028e  1e52              SUBS     r2,r2,#1              ;390
000290  8122              STRH     r2,[r4,#8]            ;390
000292  f8454b04          STR      r4,[r5],#4            ;391
000296  2301              MOVS     r3,#1                 ;392
000298  f8469b04          STR      r9,[r6],#4            ;393
00029c  1c7a              ADDS     r2,r7,#1              ;394
00029e  b297              UXTH     r7,r2                 ;394
0002a0  e010              B        |L1.708|
                  |L1.674|
0002a2  f0400001          ORR      r0,r0,#1              ;397
0002a6  e00d              B        |L1.708|
                  |L1.680|
0002a8  6862              LDR      r2,[r4,#4]            ;404
0002aa  b14a              CBZ      r2,|L1.704|
0002ac  f8462b04          STR      r2,[r6],#4            ;406
0002b0  f8c49004          STR      r9,[r4,#4]            ;407
0002b4  f8454b04          STR      r4,[r5],#4            ;408
0002b8  2301              MOVS     r3,#1                 ;409
0002ba  1c7a              ADDS     r2,r7,#1              ;410
0002bc  b297              UXTH     r7,r2                 ;410
0002be  e001              B        |L1.708|
                  |L1.704|
0002c0  f0400002          ORR      r0,r0,#2              ;413
                  |L1.708|
0002c4  1d09              ADDS     r1,r1,#4              ;446
0002c6  680c              LDR      r4,[r1,#0]            ;447
0002c8  2c00              CMP      r4,#0                 ;399
0002ca  d1ce              BNE      |L1.618|
                  |L1.716|
0002cc  2b01              CMP      r3,#1                 ;450
0002ce  d03f              BEQ      |L1.848|
0002d0  4955              LDR      r1,|L1.1064|
0002d2  f0400080          ORR      r0,r0,#0x80           ;458
0002d6  6a49              LDR      r1,[r1,#0x24]         ;458  ; OSTCBCur
0002d8  f8912030          LDRB     r2,[r1,#0x30]         ;458
0002dc  4310              ORRS     r0,r0,r2              ;458
0002de  f8810030          STRB     r0,[r1,#0x30]         ;458
0002e2  f8819031          STRB     r9,[r1,#0x31]         ;460
0002e6  9804              LDR      r0,[sp,#0x10]         ;461
0002e8  85c8              STRH     r0,[r1,#0x2e]         ;461
0002ea  4650              MOV      r0,r10                ;462
0002ec  f7fffffe          BL       OS_EventTaskWaitMulti
0002f0  9800              LDR      r0,[sp,#0]            ;464
0002f2  f7fffffe          BL       OS_CPU_SR_Restore
0002f6  f7fffffe          BL       OS_Sched
0002fa  f7fffffe          BL       OS_CPU_SR_Save
0002fe  9000              STR      r0,[sp,#0]            ;466
000300  4849              LDR      r0,|L1.1064|
000302  6a40              LDR      r0,[r0,#0x24]         ;468  ; OSTCBCur
000304  f8901031          LDRB     r1,[r0,#0x31]         ;468
000308  b369              CBZ      r1,|L1.870|
00030a  2902              CMP      r1,#2                 ;468
00030c  d02b              BEQ      |L1.870|
00030e  4651              MOV      r1,r10                ;485
000310  f7fffffe          BL       OS_EventTaskRemoveMulti
                  |L1.788|
000314  4a44              LDR      r2,|L1.1064|
000316  6a51              LDR      r1,[r2,#0x24]         ;489  ; OSTCBCur
000318  f8910031          LDRB     r0,[r1,#0x31]         ;489
00031c  b388              CBZ      r0,|L1.898|
00031e  2802              CMP      r0,#2                 ;489
000320  d04a              BEQ      |L1.952|
000322  f8c69000          STR      r9,[r6,#0]            ;524
000326  200a              MOVS     r0,#0xa               ;525
000328  f8880000          STRB     r0,[r8,#0]            ;525
                  |L1.812|
00032c  6a50              LDR      r0,[r2,#0x24]         ;529  ; OSTCBCur
00032e  f8809030          STRB     r9,[r0,#0x30]         ;529
000332  f8809031          STRB     r9,[r0,#0x31]         ;530
000336  f8c0901c          STR      r9,[r0,#0x1c]         ;531
00033a  f8c09020          STR      r9,[r0,#0x20]         ;532
00033e  f8c09024          STR      r9,[r0,#0x24]         ;533
000342  9800              LDR      r0,[sp,#0]            ;534
000344  f7fffffe          BL       OS_CPU_SR_Restore
000348  b005              ADD      sp,sp,#0x14
00034a  4638              MOV      r0,r7                 ;536
00034c  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.848|
000350  f8c59000          STR      r9,[r5,#0]            ;451
000354  9800              LDR      r0,[sp,#0]            ;452
000356  f7fffffe          BL       OS_CPU_SR_Restore
00035a  f8889000          STRB     r9,[r8,#0]            ;453
00035e  b005              ADD      sp,sp,#0x14
000360  4638              MOV      r0,r7                 ;454
000362  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.870|
000366  69c4              LDR      r4,[r0,#0x1c]         ;471
000368  b12c              CBZ      r4,|L1.886|
00036a  602c              STR      r4,[r5,#0]            ;473
00036c  f8459f04          STR      r9,[r5,#4]!           ;474
000370  1c78              ADDS     r0,r7,#1              ;475
000372  b287              UXTH     r7,r0                 ;475
000374  e7ce              B        |L1.788|
                  |L1.886|
000376  f880b031          STRB     r11,[r0,#0x31]        ;478
00037a  4651              MOV      r1,r10                ;479
00037c  f7fffffe          BL       OS_EventTaskRemoveMulti
000380  e7c8              B        |L1.788|
                  |L1.898|
000382  e7ff              B        |L1.900|
                  |L1.900|
000384  7820              LDRB     r0,[r4,#0]            ;491
000386  2801              CMP      r0,#1                 ;491
000388  d011              BEQ      |L1.942|
00038a  2802              CMP      r0,#2                 ;491
00038c  d00f              BEQ      |L1.942|
00038e  2803              CMP      r0,#3                 ;491
000390  d00a              BEQ      |L1.936|
000392  9800              LDR      r0,[sp,#0]            ;509
000394  f7fffffe          BL       OS_CPU_SR_Restore
000398  f8c59000          STR      r9,[r5,#0]            ;510
00039c  f888b000          STRB     r11,[r8,#0]           ;511
0003a0  b005              ADD      sp,sp,#0x14
0003a2  4638              MOV      r0,r7                 ;512
0003a4  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.936|
0003a8  f8c69000          STR      r9,[r6,#0]            ;494
0003ac  e001              B        |L1.946|
                  |L1.942|
0003ae  6a48              LDR      r0,[r1,#0x24]         ;502
0003b0  6030              STR      r0,[r6,#0]            ;502
                  |L1.946|
0003b2  f8889000          STRB     r9,[r8,#0]            ;514
0003b6  e7b9              B        |L1.812|
                  |L1.952|
0003b8  f8c69000          STR      r9,[r6,#0]            ;518
0003bc  200e              MOVS     r0,#0xe               ;519
0003be  f8880000          STRB     r0,[r8,#0]            ;519
0003c2  e7b3              B        |L1.812|
;;;538    #endif
                          ENDP

                  OS_TaskStatStkChk PROC
;;;1849   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1850   void  OS_TaskStatStkChk (void)
0003c4  b530              PUSH     {r4,r5,lr}
;;;1851   {
0003c6  b083              SUB      sp,sp,#0xc
;;;1852       OS_TCB      *ptcb;
;;;1853       OS_STK_DATA  stk_data;
;;;1854       INT8U        err;
;;;1855       INT8U        prio;
;;;1856   
;;;1857   
;;;1858       for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
0003c8  2400              MOVS     r4,#0
;;;1859           err = OSTaskStkChk(prio, &stk_data);
;;;1860           if (err == OS_ERR_NONE) {
;;;1861               ptcb = OSTCBPrioTbl[prio];
0003ca  4d19              LDR      r5,|L1.1072|
                  |L1.972|
0003cc  4669              MOV      r1,sp                 ;1859
0003ce  4620              MOV      r0,r4                 ;1859
0003d0  f7fffffe          BL       OSTaskStkChk
0003d4  b958              CBNZ     r0,|L1.1006|
0003d6  f8551024          LDR      r1,[r5,r4,LSL #2]
;;;1862               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
0003da  b141              CBZ      r1,|L1.1006|
;;;1863                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
0003dc  2901              CMP      r1,#1
0003de  d006              BEQ      |L1.1006|
;;;1864   #if OS_TASK_PROFILE_EN > 0
;;;1865                       #if OS_STK_GROWTH == 1
;;;1866                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
0003e0  68ca              LDR      r2,[r1,#0xc]
0003e2  6888              LDR      r0,[r1,#8]
0003e4  eb000082          ADD      r0,r0,r2,LSL #2
0003e8  6448              STR      r0,[r1,#0x44]
;;;1867                       #else
;;;1868                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1869                       #endif
;;;1870                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
0003ea  9801              LDR      r0,[sp,#4]
0003ec  6488              STR      r0,[r1,#0x48]
                  |L1.1006|
0003ee  1c60              ADDS     r0,r4,#1              ;1858
0003f0  b2c4              UXTB     r4,r0                 ;1858
0003f2  2c1f              CMP      r4,#0x1f              ;1858
0003f4  d9ea              BLS      |L1.972|
;;;1871   #endif
;;;1872                   }
;;;1873               }
;;;1874           }
;;;1875       }
;;;1876   }
0003f6  b003              ADD      sp,sp,#0xc
0003f8  bd30              POP      {r4,r5,pc}
;;;1877   #endif
                          ENDP

                  OS_TaskStat PROC
;;;1804   #if OS_TASK_STAT_EN > 0
;;;1805   void  OS_TaskStat (void *p_arg)
0003fa  4c0b              LDR      r4,|L1.1064|
;;;1806   {
;;;1807   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1808       OS_CPU_SR  cpu_sr = 0;
;;;1809   #endif
;;;1810   
;;;1811   
;;;1812   
;;;1813       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1814       while (OSStatRdy == OS_FALSE) {
0003fc  7860              LDRB     r0,[r4,#1]  ; OSStatRdy
0003fe  2800              CMP      r0,#0
000400  d105              BNE      |L1.1038|
                  |L1.1026|
;;;1815           OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
000402  20c8              MOVS     r0,#0xc8
000404  f7fffffe          BL       OSTimeDly
000408  7860              LDRB     r0,[r4,#1]            ;1814  ; OSStatRdy
00040a  2800              CMP      r0,#0                 ;1814
00040c  d0f9              BEQ      |L1.1026|
                  |L1.1038|
;;;1816       }
;;;1817       OSIdleCtrMax /= 100L;
00040e  490a              LDR      r1,|L1.1080|
000410  6960              LDR      r0,[r4,#0x14]  ; OSIdleCtrMax
000412  fba11000          UMULL    r1,r0,r1,r0
000416  0940              LSRS     r0,r0,#5
000418  6160              STR      r0,[r4,#0x14]  ; OSIdleCtrMax
;;;1818       if (OSIdleCtrMax == 0L) {
00041a  2500              MOVS     r5,#0
00041c  b918              CBNZ     r0,|L1.1062|
;;;1819           OSCPUUsage = 0;
00041e  7025              STRB     r5,[r4,#0]
;;;1820           (void)OSTaskSuspend(OS_PRIO_SELF);
000420  20ff              MOVS     r0,#0xff
000422  f7fffffe          BL       OSTaskSuspend
                  |L1.1062|
;;;1821       }
;;;1822       for (;;) {
;;;1823           OS_ENTER_CRITICAL();
000426  e009              B        |L1.1084|
                  |L1.1064|
                          DCD      ||.data||
                  |L1.1068|
                          DCD      ||.constdata||
                  |L1.1072|
                          DCD      ||.bss||+0x540
                  |L1.1076|
                          DCD      ||.data||+0x1c
                  |L1.1080|
                          DCD      0x51eb851f
                  |L1.1084|
00043c  f7fffffe          BL       OS_CPU_SR_Save
;;;1824           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
000440  6a21              LDR      r1,[r4,#0x20]  ; OSIdleCtr
000442  61a1              STR      r1,[r4,#0x18]  ; OSIdleCtrRun
;;;1825           OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
000444  6225              STR      r5,[r4,#0x20]  ; OSIdleCtr
;;;1826           OS_EXIT_CRITICAL();
000446  f7fffffe          BL       OS_CPU_SR_Restore
;;;1827           OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
00044a  6961              LDR      r1,[r4,#0x14]  ; OSIdleCtrMax
00044c  69a0              LDR      r0,[r4,#0x18]  ; OSIdleCtrRun
00044e  fbb0f0f1          UDIV     r0,r0,r1
000452  f1c00064          RSB      r0,r0,#0x64
000456  7020              STRB     r0,[r4,#0]
;;;1828           OSTaskStatHook();                        /* Invoke user definable hook                         */
000458  f7fffffe          BL       OSTaskStatHook
;;;1829   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1830           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
00045c  f7fffffe          BL       OS_TaskStatStkChk
;;;1831   #endif
;;;1832           OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
000460  2064              MOVS     r0,#0x64
000462  f7fffffe          BL       OSTimeDly
000466  e7de              B        |L1.1062|
;;;1833       }
;;;1834   }
;;;1835   #endif
                          ENDP

                  OS_InitTaskStat PROC
;;;1433   #if OS_TASK_STAT_EN > 0
;;;1434   static  void  OS_InitTaskStat (void)
000468  b500              PUSH     {lr}
;;;1435   {
00046a  b087              SUB      sp,sp,#0x1c
;;;1436   #if OS_TASK_NAME_SIZE > 7
;;;1437       INT8U  err;
;;;1438   #endif
;;;1439   
;;;1440   
;;;1441   #if OS_TASK_CREATE_EXT_EN > 0
;;;1442       #if OS_STK_GROWTH == 1
;;;1443       (void)OSTaskCreateExt(OS_TaskStat,
00046c  2103              MOVS     r1,#3
00046e  2200              MOVS     r2,#0
000470  2380              MOVS     r3,#0x80
000472  9104              STR      r1,[sp,#0x10]
000474  48fd              LDR      r0,|L1.2156|
000476  9302              STR      r3,[sp,#8]
000478  f64f71fe          MOV      r1,#0xfffe
00047c  9203              STR      r2,[sp,#0xc]
00047e  231e              MOVS     r3,#0x1e
000480  9100              STR      r1,[sp,#0]
000482  9001              STR      r0,[sp,#4]
000484  f50072fe          ADD      r2,r0,#0x1fc
000488  2100              MOVS     r1,#0
00048a  f2af0091          ADR      r0,OS_TaskStat + 1
00048e  f7fffffe          BL       OSTaskCreateExt
;;;1444                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1445                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
;;;1446                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1447                             OS_TASK_STAT_ID,
;;;1448                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1449                             OS_TASK_STAT_STK_SIZE,
;;;1450                             (void *)0,                                   /* No TCB extension               */
;;;1451                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1452       #else
;;;1453       (void)OSTaskCreateExt(OS_TaskStat,
;;;1454                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1455                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1456                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1457                             OS_TASK_STAT_ID,
;;;1458                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
;;;1459                             OS_TASK_STAT_STK_SIZE,
;;;1460                             (void *)0,                                   /* No TCB extension               */
;;;1461                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1462       #endif
;;;1463   #else
;;;1464       #if OS_STK_GROWTH == 1
;;;1465       (void)OSTaskCreate(OS_TaskStat,
;;;1466                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1467                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
;;;1468                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1469       #else
;;;1470       (void)OSTaskCreate(OS_TaskStat,
;;;1471                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1472                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1473                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1474       #endif
;;;1475   #endif
;;;1476   
;;;1477   #if OS_TASK_NAME_SIZE > 14
;;;1478       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
000492  aa06              ADD      r2,sp,#0x18
000494  a1f6              ADR      r1,|L1.2160|
000496  201e              MOVS     r0,#0x1e
000498  f7fffffe          BL       OSTaskNameSet
;;;1479   #else
;;;1480   #if OS_TASK_NAME_SIZE > 7
;;;1481       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
;;;1482   #endif
;;;1483   #endif
;;;1484   }
00049c  b007              ADD      sp,sp,#0x1c
00049e  bd00              POP      {pc}
;;;1485   #endif
                          ENDP

                  OS_TaskIdle PROC
;;;1762   
;;;1763   void  OS_TaskIdle (void *p_arg)
0004a0  4cf7              LDR      r4,|L1.2176|
                  |L1.1186|
;;;1764   {
;;;1765   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1766       OS_CPU_SR  cpu_sr = 0;
;;;1767   #endif
;;;1768   
;;;1769   
;;;1770   
;;;1771       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1772       for (;;) {
;;;1773           OS_ENTER_CRITICAL();
0004a2  f7fffffe          BL       OS_CPU_SR_Save
;;;1774           OSIdleCtr++;
0004a6  6a21              LDR      r1,[r4,#0x20]  ; OSIdleCtr
0004a8  1c49              ADDS     r1,r1,#1
0004aa  6221              STR      r1,[r4,#0x20]  ; OSIdleCtr
;;;1775           OS_EXIT_CRITICAL();
0004ac  f7fffffe          BL       OS_CPU_SR_Restore
;;;1776           OSTaskIdleHook();                        /* Call user definable HOOK                           */
0004b0  f7fffffe          BL       OSTaskIdleHook
0004b4  e7f5              B        |L1.1186|
;;;1777       }
;;;1778   }
;;;1779   /*$PAGE*/
                          ENDP

                  OS_InitTaskIdle PROC
;;;1367   
;;;1368   static  void  OS_InitTaskIdle (void)
0004b6  b500              PUSH     {lr}
;;;1369   {
0004b8  b087              SUB      sp,sp,#0x1c
;;;1370   #if OS_TASK_NAME_SIZE > 7
;;;1371       INT8U  err;
;;;1372   #endif
;;;1373   
;;;1374   
;;;1375   #if OS_TASK_CREATE_EXT_EN > 0
;;;1376       #if OS_STK_GROWTH == 1
;;;1377       (void)OSTaskCreateExt(OS_TaskIdle,
0004ba  2103              MOVS     r1,#3
0004bc  2200              MOVS     r2,#0
0004be  2380              MOVS     r3,#0x80
0004c0  9104              STR      r1,[sp,#0x10]
0004c2  48f0              LDR      r0,|L1.2180|
0004c4  9302              STR      r3,[sp,#8]
0004c6  f64f71ff          MOV      r1,#0xffff
0004ca  9203              STR      r2,[sp,#0xc]
0004cc  231f              MOVS     r3,#0x1f
0004ce  9100              STR      r1,[sp,#0]
0004d0  9001              STR      r0,[sp,#4]
0004d2  f50072fe          ADD      r2,r0,#0x1fc
0004d6  2100              MOVS     r1,#0
0004d8  f2af003b          ADR      r0,OS_TaskIdle + 1
0004dc  f7fffffe          BL       OSTaskCreateExt
;;;1378                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1379                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
;;;1380                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1381                             OS_TASK_IDLE_ID,
;;;1382                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1383                             OS_TASK_IDLE_STK_SIZE,
;;;1384                             (void *)0,                                 /* No TCB extension                     */
;;;1385                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1386       #else
;;;1387       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1388                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1389                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1390                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1391                             OS_TASK_IDLE_ID,
;;;1392                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
;;;1393                             OS_TASK_IDLE_STK_SIZE,
;;;1394                             (void *)0,                                 /* No TCB extension                     */
;;;1395                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1396       #endif
;;;1397   #else
;;;1398       #if OS_STK_GROWTH == 1
;;;1399       (void)OSTaskCreate(OS_TaskIdle,
;;;1400                          (void *)0,
;;;1401                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
;;;1402                          OS_TASK_IDLE_PRIO);
;;;1403       #else
;;;1404       (void)OSTaskCreate(OS_TaskIdle,
;;;1405                          (void *)0,
;;;1406                          &OSTaskIdleStk[0],
;;;1407                          OS_TASK_IDLE_PRIO);
;;;1408       #endif
;;;1409   #endif
;;;1410   
;;;1411   #if OS_TASK_NAME_SIZE > 14
;;;1412       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
0004e0  aa06              ADD      r2,sp,#0x18
0004e2  a1e9              ADR      r1,|L1.2184|
0004e4  201f              MOVS     r0,#0x1f
0004e6  f7fffffe          BL       OSTaskNameSet
;;;1413   #else
;;;1414   #if OS_TASK_NAME_SIZE > 7
;;;1415       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
;;;1416   #endif
;;;1417   #endif
;;;1418   }
0004ea  b007              ADD      sp,sp,#0x1c
0004ec  bd00              POP      {pc}
;;;1419   /*$PAGE*/
                          ENDP

                  OS_MemClr PROC
;;;1548   
;;;1549   void  OS_MemClr (INT8U *pdest, INT16U size)
0004ee  2900              CMP      r1,#0
;;;1550   {
0004f0  d006              BEQ      |L1.1280|
0004f2  2200              MOVS     r2,#0
                  |L1.1268|
;;;1551       while (size > 0) {
;;;1552           *pdest++ = (INT8U)0;
0004f4  f8002b01          STRB     r2,[r0],#1
;;;1553           size--;
0004f8  1e49              SUBS     r1,r1,#1
0004fa  b289              UXTH     r1,r1
0004fc  2900              CMP      r1,#0                 ;1551
0004fe  d1f9              BNE      |L1.1268|
                  |L1.1280|
;;;1554       }
;;;1555   }
000500  4770              BX       lr
;;;1556   /*$PAGE*/
                          ENDP

                  OS_InitEventList PROC
;;;1240   
;;;1241   static  void  OS_InitEventList (void)
000502  b510              PUSH     {r4,lr}
;;;1242   {
;;;1243   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
;;;1244   #if (OS_MAX_EVENTS > 1)
;;;1245       INT16U     i;
;;;1246       OS_EVENT  *pevent1;
;;;1247       OS_EVENT  *pevent2;
;;;1248   
;;;1249   
;;;1250       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
000504  f44f71a0          MOV      r1,#0x140
000508  48e3              LDR      r0,|L1.2200|
00050a  f7fffffe          BL       OS_MemClr
;;;1251       pevent1 = &OSEventTbl[0];
00050e  48e2              LDR      r0,|L1.2200|
;;;1252       pevent2 = &OSEventTbl[1];
000510  4604              MOV      r4,r0
000512  f1040220          ADD      r2,r4,#0x20
;;;1253       for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
000516  2100              MOVS     r1,#0
000518  2300              MOVS     r3,#0
;;;1254           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1255           pevent1->OSEventPtr     = pevent2;
;;;1256   #if OS_EVENT_NAME_SIZE > 1
;;;1257           pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
00051a  f04f0c3f          MOV      r12,#0x3f
                  |L1.1310|
00051e  7003              STRB     r3,[r0,#0]            ;1254
000520  6042              STR      r2,[r0,#4]            ;1255
000522  f880c00f          STRB     r12,[r0,#0xf]
;;;1258           pevent1->OSEventName[1] = OS_ASCII_NUL;
000526  7403              STRB     r3,[r0,#0x10]
;;;1259   #endif
;;;1260           pevent1++;
000528  3020              ADDS     r0,r0,#0x20
;;;1261           pevent2++;
00052a  3220              ADDS     r2,r2,#0x20
00052c  1c49              ADDS     r1,r1,#1              ;1253
00052e  b289              UXTH     r1,r1                 ;1253
000530  2909              CMP      r1,#9                 ;1253
000532  d3f4              BCC      |L1.1310|
;;;1262       }
;;;1263       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
000534  7003              STRB     r3,[r0,#0]
;;;1264       pevent1->OSEventPtr             = (OS_EVENT *)0;
000536  6043              STR      r3,[r0,#4]
;;;1265   #if OS_EVENT_NAME_SIZE > 1
;;;1266       pevent1->OSEventName[0]         = '?';
000538  f880c00f          STRB     r12,[r0,#0xf]
;;;1267       pevent1->OSEventName[1]         = OS_ASCII_NUL;
00053c  7403              STRB     r3,[r0,#0x10]
;;;1268   #endif
;;;1269       OSEventFreeList                 = &OSEventTbl[0];
00053e  48d0              LDR      r0,|L1.2176|
000540  6104              STR      r4,[r0,#0x10]  ; OSEventFreeList
;;;1270   #else
;;;1271       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1272       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1273       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1274   #if OS_EVENT_NAME_SIZE > 1
;;;1275       OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
;;;1276       OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
;;;1277   #endif
;;;1278   #endif
;;;1279   #endif
;;;1280   }
000542  bd10              POP      {r4,pc}
;;;1281   /*$PAGE*/
                          ENDP

                  OS_InitTCBList PROC
;;;1499   
;;;1500   static  void  OS_InitTCBList (void)
000544  b510              PUSH     {r4,lr}
;;;1501   {
;;;1502       INT8U    i;
;;;1503       OS_TCB  *ptcb1;
;;;1504       OS_TCB  *ptcb2;
;;;1505   
;;;1506   
;;;1507       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000546  f44f61fd          MOV      r1,#0x7e8
00054a  48d4              LDR      r0,|L1.2204|
00054c  f7fffffe          BL       OS_MemClr
;;;1508       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
000550  2180              MOVS     r1,#0x80
000552  48d3              LDR      r0,|L1.2208|
000554  f7fffffe          BL       OS_MemClr
;;;1509       ptcb1 = &OSTCBTbl[0];
000558  48d0              LDR      r0,|L1.2204|
;;;1510       ptcb2 = &OSTCBTbl[1];
00055a  4604              MOV      r4,r0
00055c  f104025c          ADD      r2,r4,#0x5c
;;;1511       for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
000560  2100              MOVS     r1,#0
000562  2300              MOVS     r3,#0
;;;1512           ptcb1->OSTCBNext = ptcb2;
;;;1513   #if OS_TASK_NAME_SIZE > 1
;;;1514           ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
000564  f04f0c3f          MOV      r12,#0x3f
                  |L1.1384|
000568  6142              STR      r2,[r0,#0x14]         ;1512
00056a  f880c04c          STRB     r12,[r0,#0x4c]
;;;1515           ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
00056e  f880304d          STRB     r3,[r0,#0x4d]
;;;1516   #endif
;;;1517           ptcb1++;
000572  305c              ADDS     r0,r0,#0x5c
;;;1518           ptcb2++;
000574  325c              ADDS     r2,r2,#0x5c
000576  1c49              ADDS     r1,r1,#1              ;1511
000578  b2c9              UXTB     r1,r1                 ;1511
00057a  2915              CMP      r1,#0x15              ;1511
00057c  d3f4              BCC      |L1.1384|
;;;1519       }
;;;1520       ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
00057e  6143              STR      r3,[r0,#0x14]
;;;1521   #if OS_TASK_NAME_SIZE > 1
;;;1522       ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
000580  f880c04c          STRB     r12,[r0,#0x4c]
;;;1523       ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
000584  f880304d          STRB     r3,[r0,#0x4d]
;;;1524   #endif
;;;1525       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
000588  48bd              LDR      r0,|L1.2176|
00058a  6303              STR      r3,[r0,#0x30]  ; OSTCBList
;;;1526       OSTCBFreeList           = &OSTCBTbl[0];
00058c  6284              STR      r4,[r0,#0x28]  ; OSTCBFreeList
;;;1527   }
00058e  bd10              POP      {r4,pc}
;;;1528   /*$PAGE*/
                          ENDP

                  OS_InitRdyList PROC
;;;1330   
;;;1331   static  void  OS_InitRdyList (void)
000590  4bbb              LDR      r3,|L1.2176|
;;;1332   {
;;;1333       INT8U    i;
;;;1334   #if OS_LOWEST_PRIO <= 63
;;;1335       INT8U   *prdytbl;
;;;1336   #else
;;;1337       INT16U  *prdytbl;
;;;1338   #endif
;;;1339   
;;;1340   
;;;1341       OSRdyGrp      = 0;                                     /* Clear the ready list                     */
000592  2200              MOVS     r2,#0
000594  719a              STRB     r2,[r3,#6]
;;;1342       prdytbl       = &OSRdyTbl[0];
000596  f103011c          ADD      r1,r3,#0x1c
;;;1343       for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
00059a  2000              MOVS     r0,#0
                  |L1.1436|
;;;1344           *prdytbl++ = 0;
00059c  f8012b01          STRB     r2,[r1],#1
0005a0  1c40              ADDS     r0,r0,#1              ;1343
0005a2  b2c0              UXTB     r0,r0                 ;1343
0005a4  2804              CMP      r0,#4                 ;1343
0005a6  d3f9              BCC      |L1.1436|
;;;1345       }
;;;1346   
;;;1347       OSPrioCur     = 0;
0005a8  711a              STRB     r2,[r3,#4]
;;;1348       OSPrioHighRdy = 0;
0005aa  715a              STRB     r2,[r3,#5]
;;;1349   
;;;1350       OSTCBHighRdy  = (OS_TCB *)0;
0005ac  62da              STR      r2,[r3,#0x2c]  ; OSTCBHighRdy
;;;1351       OSTCBCur      = (OS_TCB *)0;
0005ae  625a              STR      r2,[r3,#0x24]  ; OSTCBCur
;;;1352   }
0005b0  4770              BX       lr
;;;1353   
                          ENDP

                  OS_InitMisc PROC
;;;1294   
;;;1295   static  void  OS_InitMisc (void)
0005b2  48b3              LDR      r0,|L1.2176|
;;;1296   {
;;;1297   #if OS_TIME_GET_SET_EN > 0
;;;1298       OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
0005b4  2100              MOVS     r1,#0
0005b6  6341              STR      r1,[r0,#0x34]  ; OSTime
;;;1299   #endif
;;;1300   
;;;1301       OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
0005b8  7081              STRB     r1,[r0,#2]
;;;1302       OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
0005ba  70c1              STRB     r1,[r0,#3]
;;;1303   
;;;1304       OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
0005bc  7201              STRB     r1,[r0,#8]
;;;1305   
;;;1306       OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
0005be  71c1              STRB     r1,[r0,#7]
;;;1307   
;;;1308       OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
0005c0  60c1              STR      r1,[r0,#0xc]  ; OSCtxSwCtr
;;;1309       OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
0005c2  6201              STR      r1,[r0,#0x20]  ; OSIdleCtr
;;;1310   
;;;1311   #if OS_TASK_STAT_EN > 0
;;;1312       OSIdleCtrRun  = 0L;
0005c4  6181              STR      r1,[r0,#0x18]  ; OSIdleCtrRun
;;;1313       OSIdleCtrMax  = 0L;
0005c6  6141              STR      r1,[r0,#0x14]  ; OSIdleCtrMax
;;;1314       OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
0005c8  7041              STRB     r1,[r0,#1]
;;;1315   #endif
;;;1316   }
0005ca  4770              BX       lr
;;;1317   /*$PAGE*/
                          ENDP

                  OSInit PROC
;;;553    
;;;554    void  OSInit (void)
0005cc  b510              PUSH     {r4,lr}
;;;555    {
;;;556        OSInitHookBegin();                                           /* Call port specific initialization code   */
0005ce  f7fffffe          BL       OSInitHookBegin
;;;557    
;;;558        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
0005d2  f7fffffe          BL       OS_InitMisc
;;;559    
;;;560        OS_InitRdyList();                                            /* Initialize the Ready List                */
0005d6  f7fffffe          BL       OS_InitRdyList
;;;561    
;;;562        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
0005da  f7fffffe          BL       OS_InitTCBList
;;;563    
;;;564        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
0005de  f7fffffe          BL       OS_InitEventList
;;;565    
;;;566    #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
;;;567        OS_FlagInit();                                               /* Initialize the event flag structures     */
0005e2  f7fffffe          BL       OS_FlagInit
;;;568    #endif
;;;569    
;;;570    #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
;;;571        OS_MemInit();                                                /* Initialize the memory manager            */
;;;572    #endif
;;;573    
;;;574    #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
;;;575        OS_QInit();                                                  /* Initialize the message queue structures  */
;;;576    #endif
;;;577    
;;;578        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
0005e6  f7fffffe          BL       OS_InitTaskIdle
;;;579    #if OS_TASK_STAT_EN > 0
;;;580        OS_InitTaskStat();                                           /* Create the Statistic Task                */
0005ea  f7fffffe          BL       OS_InitTaskStat
;;;581    #endif
;;;582    
;;;583    #if OS_TMR_EN > 0
;;;584        OSTmr_Init();                                                /* Initialize the Timer Manager             */
;;;585    #endif
;;;586    
;;;587        OSInitHookEnd();                                             /* Call port specific init. code            */
0005ee  f7fffffe          BL       OSInitHookEnd
;;;588    
;;;589    #if OS_DEBUG_EN > 0
;;;590        OSDebugInit();
0005f2  e8bd4010          POP      {r4,lr}
0005f6  f7ffbffe          B.W      OSDebugInit
;;;591    #endif
;;;592    }
;;;593    /*$PAGE*/
                          ENDP

                  OSIntEnter PROC
;;;618    
;;;619    void  OSIntEnter (void)
0005fa  49a1              LDR      r1,|L1.2176|
;;;620    {
;;;621        if (OSRunning == OS_TRUE) {
0005fc  79c8              LDRB     r0,[r1,#7]  ; OSRunning
0005fe  2801              CMP      r0,#1
000600  d104              BNE      |L1.1548|
;;;622            if (OSIntNesting < 255u) {
000602  7888              LDRB     r0,[r1,#2]  ; OSIntNesting
000604  28ff              CMP      r0,#0xff
000606  d201              BCS      |L1.1548|
;;;623                OSIntNesting++;                      /* Increment ISR nesting level                        */
000608  1c40              ADDS     r0,r0,#1
00060a  7088              STRB     r0,[r1,#2]
                  |L1.1548|
;;;624            }
;;;625        }
;;;626    }
00060c  4770              BX       lr
;;;627    /*$PAGE*/
                          ENDP

                  OSIntExit PROC
;;;646    
;;;647    void  OSIntExit (void)
00060e  b570              PUSH     {r4-r6,lr}
;;;648    {
;;;649    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;650        OS_CPU_SR  cpu_sr = 0;
;;;651    #endif
;;;652    
;;;653    
;;;654    
;;;655        if (OSRunning == OS_TRUE) {
000610  4c9b              LDR      r4,|L1.2176|
000612  79e0              LDRB     r0,[r4,#7]  ; OSRunning
000614  2801              CMP      r0,#1
000616  d121              BNE      |L1.1628|
;;;656            OS_ENTER_CRITICAL();
000618  f7fffffe          BL       OS_CPU_SR_Save
00061c  4605              MOV      r5,r0
;;;657            if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
00061e  78a1              LDRB     r1,[r4,#2]  ; OSIntNesting
000620  b109              CBZ      r1,|L1.1574|
;;;658                OSIntNesting--;
000622  1e48              SUBS     r0,r1,#1
000624  70a0              STRB     r0,[r4,#2]
                  |L1.1574|
;;;659            }
;;;660            if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
000626  78a0              LDRB     r0,[r4,#2]  ; OSIntNesting
000628  b998              CBNZ     r0,|L1.1618|
;;;661                if (OSLockNesting == 0) {                      /* ... and not locked.                      */
00062a  78e0              LDRB     r0,[r4,#3]  ; OSLockNesting
00062c  b988              CBNZ     r0,|L1.1618|
;;;662                    OS_SchedNew();
00062e  f7fffffe          BL       OS_SchedNew
;;;663                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
000632  7961              LDRB     r1,[r4,#5]  ; OSPrioHighRdy
000634  7920              LDRB     r0,[r4,#4]  ; OSPrioCur
000636  4281              CMP      r1,r0
000638  d00b              BEQ      |L1.1618|
;;;664                        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
00063a  4899              LDR      r0,|L1.2208|
00063c  f8501021          LDR      r1,[r0,r1,LSL #2]
000640  62e1              STR      r1,[r4,#0x2c]  ; OSTCBHighRdy
;;;665    #if OS_TASK_PROFILE_EN > 0
;;;666                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
000642  6b88              LDR      r0,[r1,#0x38]
000644  1c40              ADDS     r0,r0,#1
000646  6388              STR      r0,[r1,#0x38]
;;;667    #endif
;;;668                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
000648  68e0              LDR      r0,[r4,#0xc]  ; OSCtxSwCtr
00064a  1c40              ADDS     r0,r0,#1
00064c  60e0              STR      r0,[r4,#0xc]  ; OSCtxSwCtr
;;;669                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
00064e  f7fffffe          BL       OSIntCtxSw
                  |L1.1618|
;;;670                    }
;;;671                }
;;;672            }
;;;673            OS_EXIT_CRITICAL();
000652  4628              MOV      r0,r5
000654  e8bd4070          POP      {r4-r6,lr}
000658  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L1.1628|
;;;674        }
;;;675    }
00065c  bd70              POP      {r4-r6,pc}
;;;676    /*$PAGE*/
                          ENDP

                  OSSchedLock PROC
;;;693    #if OS_SCHED_LOCK_EN > 0
;;;694    void  OSSchedLock (void)
00065e  b510              PUSH     {r4,lr}
;;;695    {
;;;696    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;697        OS_CPU_SR  cpu_sr = 0;
;;;698    #endif
;;;699    
;;;700    
;;;701    
;;;702        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
000660  4c87              LDR      r4,|L1.2176|
000662  79e0              LDRB     r0,[r4,#7]  ; OSRunning
000664  2801              CMP      r0,#1
000666  d10c              BNE      |L1.1666|
;;;703            OS_ENTER_CRITICAL();
000668  f7fffffe          BL       OS_CPU_SR_Save
;;;704            if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
00066c  78a1              LDRB     r1,[r4,#2]  ; OSIntNesting
00066e  b921              CBNZ     r1,|L1.1658|
;;;705                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
000670  78e1              LDRB     r1,[r4,#3]  ; OSLockNesting
000672  29ff              CMP      r1,#0xff
000674  d201              BCS      |L1.1658|
;;;706                    OSLockNesting++;                 /* Increment lock nesting level                       */
000676  1c49              ADDS     r1,r1,#1
000678  70e1              STRB     r1,[r4,#3]
                  |L1.1658|
;;;707                }
;;;708            }
;;;709            OS_EXIT_CRITICAL();
00067a  e8bd4010          POP      {r4,lr}
00067e  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L1.1666|
;;;710        }
;;;711    }
000682  bd10              POP      {r4,pc}
;;;712    #endif
                          ENDP

                  OSSchedUnlock PROC
;;;730    #if OS_SCHED_LOCK_EN > 0
;;;731    void  OSSchedUnlock (void)
000684  b510              PUSH     {r4,lr}
;;;732    {
;;;733    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;734        OS_CPU_SR  cpu_sr = 0;
;;;735    #endif
;;;736    
;;;737    
;;;738    
;;;739        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000686  4c7e              LDR      r4,|L1.2176|
000688  79e0              LDRB     r0,[r4,#7]  ; OSRunning
00068a  2801              CMP      r0,#1
00068c  d11a              BNE      |L1.1732|
;;;740            OS_ENTER_CRITICAL();
00068e  f7fffffe          BL       OS_CPU_SR_Save
;;;741            if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
000692  78e1              LDRB     r1,[r4,#3]  ; OSLockNesting
000694  b191              CBZ      r1,|L1.1724|
;;;742                OSLockNesting--;                               /* Decrement lock nesting level             */
000696  1e49              SUBS     r1,r1,#1
000698  b2c9              UXTB     r1,r1
00069a  70e1              STRB     r1,[r4,#3]
;;;743                if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
00069c  b119              CBZ      r1,|L1.1702|
;;;744                    if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
;;;745                        OS_EXIT_CRITICAL();
;;;746                        OS_Sched();                            /* See if a HPT is ready                    */
;;;747                    } else {
;;;748                        OS_EXIT_CRITICAL();
;;;749                    }
;;;750                } else {
;;;751                    OS_EXIT_CRITICAL();
00069e  e8bd4010          POP      {r4,lr}
0006a2  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L1.1702|
0006a6  78a1              LDRB     r1,[r4,#2]            ;744  ; OSIntNesting
0006a8  b119              CBZ      r1,|L1.1714|
0006aa  e8bd4010          POP      {r4,lr}               ;748
0006ae  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L1.1714|
0006b2  f7fffffe          BL       OS_CPU_SR_Restore
0006b6  e8bd4010          POP      {r4,lr}               ;746
0006ba  e7fe              B        OS_Sched
                  |L1.1724|
;;;752                }
;;;753            } else {
;;;754                OS_EXIT_CRITICAL();
0006bc  e8bd4010          POP      {r4,lr}
0006c0  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L1.1732|
;;;755            }
;;;756        }
;;;757    }
0006c4  bd10              POP      {r4,pc}
;;;758    #endif
                          ENDP

                  OSStart PROC
;;;780    
;;;781    void  OSStart (void)
0006c6  b510              PUSH     {r4,lr}
;;;782    {
;;;783        if (OSRunning == OS_FALSE) {
0006c8  4c6d              LDR      r4,|L1.2176|
0006ca  79e0              LDRB     r0,[r4,#7]  ; OSRunning
0006cc  2800              CMP      r0,#0
0006ce  d10c              BNE      |L1.1770|
;;;784            OS_SchedNew();                               /* Find highest priority's task priority number   */
0006d0  f7fffffe          BL       OS_SchedNew
;;;785            OSPrioCur     = OSPrioHighRdy;
0006d4  7960              LDRB     r0,[r4,#5]  ; OSPrioHighRdy
0006d6  7120              STRB     r0,[r4,#4]
;;;786            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
0006d8  4971              LDR      r1,|L1.2208|
0006da  f8510020          LDR      r0,[r1,r0,LSL #2]
0006de  62e0              STR      r0,[r4,#0x2c]  ; OSTCBHighRdy
;;;787            OSTCBCur      = OSTCBHighRdy;
0006e0  6260              STR      r0,[r4,#0x24]  ; OSTCBCur
;;;788            OSStartHighRdy();                            /* Execute target specific code to start task     */
0006e2  e8bd4010          POP      {r4,lr}
0006e6  f7ffbffe          B.W      OSStartHighRdy
                  |L1.1770|
;;;789        }
;;;790    }
0006ea  bd10              POP      {r4,pc}
;;;791    /*$PAGE*/
                          ENDP

                  OSStatInit PROC
;;;812    #if OS_TASK_STAT_EN > 0
;;;813    void  OSStatInit (void)
0006ec  b510              PUSH     {r4,lr}
;;;814    {
;;;815    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;816        OS_CPU_SR  cpu_sr = 0;
;;;817    #endif
;;;818    
;;;819    
;;;820    
;;;821        OSTimeDly(2);                                /* Synchronize with clock tick                        */
0006ee  2002              MOVS     r0,#2
0006f0  f7fffffe          BL       OSTimeDly
;;;822        OS_ENTER_CRITICAL();
0006f4  f7fffffe          BL       OS_CPU_SR_Save
;;;823        OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
0006f8  4c61              LDR      r4,|L1.2176|
0006fa  2100              MOVS     r1,#0
0006fc  6221              STR      r1,[r4,#0x20]  ; OSIdleCtr
;;;824        OS_EXIT_CRITICAL();
0006fe  f7fffffe          BL       OS_CPU_SR_Restore
;;;825        OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
000702  2064              MOVS     r0,#0x64
000704  f7fffffe          BL       OSTimeDly
;;;826        OS_ENTER_CRITICAL();
000708  f7fffffe          BL       OS_CPU_SR_Save
;;;827        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
00070c  6a21              LDR      r1,[r4,#0x20]  ; OSIdleCtr
00070e  6161              STR      r1,[r4,#0x14]  ; OSIdleCtrMax
;;;828        OSStatRdy    = OS_TRUE;
000710  2101              MOVS     r1,#1
000712  7061              STRB     r1,[r4,#1]
;;;829        OS_EXIT_CRITICAL();
000714  e8bd4010          POP      {r4,lr}
000718  f7ffbffe          B.W      OS_CPU_SR_Restore
;;;830    }
;;;831    #endif
                          ENDP

                  OSTimeTick PROC
;;;846    
;;;847    void  OSTimeTick (void)
00071c  e92d41f0          PUSH     {r4-r8,lr}
;;;848    {
;;;849        OS_TCB    *ptcb;
;;;850    #if OS_TICK_STEP_EN > 0
;;;851        BOOLEAN    step;
;;;852    #endif
;;;853    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
;;;854        OS_CPU_SR  cpu_sr = 0;
;;;855    #endif
;;;856    
;;;857    
;;;858    
;;;859    #if OS_TIME_TICK_HOOK_EN > 0
;;;860        OSTimeTickHook();                                      /* Call user definable hook                     */
000720  f7fffffe          BL       OSTimeTickHook
;;;861    #endif
;;;862    #if OS_TIME_GET_SET_EN > 0
;;;863        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
000724  f7fffffe          BL       OS_CPU_SR_Save
;;;864        OSTime++;
000728  4d55              LDR      r5,|L1.2176|
00072a  6b69              LDR      r1,[r5,#0x34]  ; OSTime
00072c  1c49              ADDS     r1,r1,#1
00072e  6369              STR      r1,[r5,#0x34]  ; OSTime
;;;865        OS_EXIT_CRITICAL();
000730  f7fffffe          BL       OS_CPU_SR_Restore
;;;866    #endif
;;;867        if (OSRunning == OS_TRUE) {
000734  79e8              LDRB     r0,[r5,#7]  ; OSRunning
000736  2801              CMP      r0,#1
000738  d14b              BNE      |L1.2002|
;;;868    #if OS_TICK_STEP_EN > 0
;;;869            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
00073a  7a68              LDRB     r0,[r5,#9]  ; OSTickStepState
00073c  2601              MOVS     r6,#1                 ;867
00073e  2700              MOVS     r7,#0                 ;867
000740  b1c0              CBZ      r0,|L1.1908|
000742  2801              CMP      r0,#1
000744  d018              BEQ      |L1.1912|
000746  2802              CMP      r0,#2
000748  d018              BEQ      |L1.1916|
;;;870                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;871                     step = OS_TRUE;
;;;872                     break;
;;;873    
;;;874                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;875                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
;;;876                     break;
;;;877    
;;;878                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;879                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
;;;880                     OSTickStepState = OS_TICK_STEP_WAIT;
;;;881                     break;
;;;882    
;;;883                default:                                       /* Invalid case, correct situation              */
;;;884                     step            = OS_TRUE;
00074a  2001              MOVS     r0,#1
;;;885                     OSTickStepState = OS_TICK_STEP_DIS;
00074c  726f              STRB     r7,[r5,#9]
                  |L1.1870|
;;;886                     break;
;;;887            }
;;;888            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
00074e  2800              CMP      r0,#0
000750  d03f              BEQ      |L1.2002|
;;;889                return;
;;;890            }
;;;891    #endif
;;;892            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
000752  6b2c              LDR      r4,[r5,#0x30]  ; OSTCBList
;;;893            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
000754  f8940032          LDRB     r0,[r4,#0x32]
000758  281f              CMP      r0,#0x1f
00075a  d03a              BEQ      |L1.2002|
;;;894                OS_ENTER_CRITICAL();
;;;895                if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
;;;896                    if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
;;;897                                                               /* Check for timeout                            */
;;;898                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;899                            ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
;;;900                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
;;;901                        } else {
;;;902                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;903                        }
;;;904    
;;;905                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
;;;906                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
;;;907                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00075c  f8df8144          LDR      r8,|L1.2212|
                  |L1.1888|
000760  f7fffffe          BL       OS_CPU_SR_Save
000764  8de1              LDRH     r1,[r4,#0x2e]         ;895
000766  b369              CBZ      r1,|L1.1988|
000768  1e49              SUBS     r1,r1,#1              ;896
00076a  0409              LSLS     r1,r1,#16             ;896
00076c  0c09              LSRS     r1,r1,#16             ;896
00076e  85e1              STRH     r1,[r4,#0x2e]         ;896
000770  d007              BEQ      |L1.1922|
000772  e027              B        |L1.1988|
                  |L1.1908|
000774  2001              MOVS     r0,#1                 ;871
000776  e7ea              B        |L1.1870|
                  |L1.1912|
000778  2000              MOVS     r0,#0                 ;875
00077a  e7e8              B        |L1.1870|
                  |L1.1916|
00077c  2001              MOVS     r0,#1                 ;879
00077e  726e              STRB     r6,[r5,#9]            ;880
000780  e7e5              B        |L1.1870|
                  |L1.1922|
000782  f8941030          LDRB     r1,[r4,#0x30]         ;898
000786  f0110f37          TST      r1,#0x37              ;898
00078a  d006              BEQ      |L1.1946|
00078c  f0210137          BIC      r1,r1,#0x37           ;899
000790  f8841030          STRB     r1,[r4,#0x30]         ;899
000794  f8846031          STRB     r6,[r4,#0x31]         ;900
000798  e001              B        |L1.1950|
                  |L1.1946|
00079a  f8847031          STRB     r7,[r4,#0x31]         ;902
                  |L1.1950|
00079e  f8941030          LDRB     r1,[r4,#0x30]         ;905
0007a2  f0110f08          TST      r1,#8                 ;905
0007a6  d10d              BNE      |L1.1988|
0007a8  f8941036          LDRB     r1,[r4,#0x36]         ;906
0007ac  79aa              LDRB     r2,[r5,#6]            ;906  ; OSRdyGrp
0007ae  4311              ORRS     r1,r1,r2              ;906
0007b0  71a9              STRB     r1,[r5,#6]            ;906
0007b2  f8941034          LDRB     r1,[r4,#0x34]
0007b6  f8943035          LDRB     r3,[r4,#0x35]
0007ba  f8182001          LDRB     r2,[r8,r1]
0007be  431a              ORRS     r2,r2,r3
0007c0  f8082001          STRB     r2,[r8,r1]
                  |L1.1988|
;;;908                        }
;;;909                    }
;;;910                }
;;;911                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
0007c4  6964              LDR      r4,[r4,#0x14]
;;;912                OS_EXIT_CRITICAL();
0007c6  f7fffffe          BL       OS_CPU_SR_Restore
0007ca  f8940032          LDRB     r0,[r4,#0x32]         ;893
0007ce  281f              CMP      r0,#0x1f              ;893
0007d0  d1c6              BNE      |L1.1888|
                  |L1.2002|
;;;913            }
;;;914        }
;;;915    }
0007d2  e8bd81f0          POP      {r4-r8,pc}
;;;916    
                          ENDP

                  OSVersion PROC
;;;931    
;;;932    INT16U  OSVersion (void)
0007d6  f44f708f          MOV      r0,#0x11e
;;;933    {
;;;934        return (OS_VERSION);
;;;935    }
0007da  4770              BX       lr
;;;936    
                          ENDP

                  OS_Dummy PROC
;;;950    #if OS_TASK_DEL_EN > 0
;;;951    void  OS_Dummy (void)
0007dc  4770              BX       lr
;;;952    {
;;;953    }
;;;954    #endif
                          ENDP

                  OS_EventTaskRemove PROC
;;;1133   #if (OS_EVENT_EN)
;;;1134   void  OS_EventTaskRemove (OS_TCB   *ptcb,
0007de  f8902034          LDRB     r2,[r0,#0x34]
;;;1135                             OS_EVENT *pevent)
;;;1136   {
;;;1137       INT8U  y;
;;;1138   
;;;1139   
;;;1140       y                       =  ptcb->OSTCBY;
;;;1141       pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
0007e2  f890c035          LDRB     r12,[r0,#0x35]
0007e6  188b              ADDS     r3,r1,r2
0007e8  7ada              LDRB     r2,[r3,#0xb]
0007ea  ea22020c          BIC      r2,r2,r12
0007ee  72da              STRB     r2,[r3,#0xb]
;;;1142       if (pevent->OSEventTbl[y] == 0) {
0007f0  2a00              CMP      r2,#0
0007f2  d105              BNE      |L1.2048|
;;;1143           pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
0007f4  7a8a              LDRB     r2,[r1,#0xa]
0007f6  f8900036          LDRB     r0,[r0,#0x36]
0007fa  ea220000          BIC      r0,r2,r0
0007fe  7288              STRB     r0,[r1,#0xa]
                  |L1.2048|
;;;1144       }
;;;1145   }
000800  4770              BX       lr
;;;1146   #endif
                          ENDP

                  OS_EventTaskRdy PROC
;;;984    #if (OS_EVENT_EN)
;;;985    INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
000802  b570              PUSH     {r4-r6,lr}
;;;986    {
000804  4605              MOV      r5,r0
000806  468c              MOV      r12,r1
;;;987        OS_TCB  *ptcb;
;;;988        INT8U    y;
;;;989        INT8U    x;
;;;990        INT8U    prio;
;;;991    #if OS_LOWEST_PRIO > 63
;;;992        INT16U  *ptbl;
;;;993    #endif
;;;994    
;;;995    
;;;996    #if OS_LOWEST_PRIO <= 63
;;;997        y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
000808  7aa8              LDRB     r0,[r5,#0xa]
00080a  4927              LDR      r1,|L1.2216|
00080c  5c08              LDRB     r0,[r1,r0]
;;;998        x    = OSUnMapTbl[pevent->OSEventTbl[y]];
00080e  182c              ADDS     r4,r5,r0
000810  7ae4              LDRB     r4,[r4,#0xb]
000812  5d09              LDRB     r1,[r1,r4]
;;;999        prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
000814  eb0101c0          ADD      r1,r1,r0,LSL #3
000818  b2ce              UXTB     r6,r1
;;;1000   #else
;;;1001       if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
;;;1002           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
;;;1003       } else {
;;;1004           y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
;;;1005       }
;;;1006       ptbl = &pevent->OSEventTbl[y];
;;;1007       if ((*ptbl & 0xFF) != 0) {
;;;1008           x = OSUnMapTbl[*ptbl & 0xFF];
;;;1009       } else {
;;;1010           x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
;;;1011       }
;;;1012       prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
;;;1013   #endif
;;;1014   
;;;1015       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
00081a  4921              LDR      r1,|L1.2208|
00081c  f8514026          LDR      r4,[r1,r6,LSL #2]
;;;1016       ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
000820  2100              MOVS     r1,#0
000822  85e1              STRH     r1,[r4,#0x2e]
;;;1017   #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
;;;1018       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
000824  f8c4c024          STR      r12,[r4,#0x24]
;;;1019   #else
;;;1020       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1021   #endif
;;;1022       ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
000828  f8941030          LDRB     r1,[r4,#0x30]
00082c  4391              BICS     r1,r1,r2
00082e  f8841030          STRB     r1,[r4,#0x30]
;;;1023       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
000832  f8843031          STRB     r3,[r4,#0x31]
;;;1024                                                           /* See if task is ready (could be susp'd)      */
;;;1025       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
000836  f0110f08          TST      r1,#8
00083a  d10b              BNE      |L1.2132|
;;;1026           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
00083c  4910              LDR      r1,|L1.2176|
00083e  f8942036          LDRB     r2,[r4,#0x36]
000842  798b              LDRB     r3,[r1,#6]  ; OSRdyGrp
000844  431a              ORRS     r2,r2,r3
000846  718a              STRB     r2,[r1,#6]
;;;1027           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000848  311c              ADDS     r1,r1,#0x1c
00084a  f8943035          LDRB     r3,[r4,#0x35]
00084e  5c0a              LDRB     r2,[r1,r0]
000850  431a              ORRS     r2,r2,r3
000852  540a              STRB     r2,[r1,r0]
                  |L1.2132|
;;;1028       }
;;;1029   
;;;1030       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000854  4629              MOV      r1,r5
000856  4620              MOV      r0,r4
000858  f7fffffe          BL       OS_EventTaskRemove
;;;1031   #if (OS_EVENT_MULTI_EN > 0)
;;;1032       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
00085c  6a21              LDR      r1,[r4,#0x20]
00085e  b119              CBZ      r1,|L1.2152|
;;;1033           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
000860  4620              MOV      r0,r4
000862  f7fffffe          BL       OS_EventTaskRemoveMulti
;;;1034           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
000866  61e5              STR      r5,[r4,#0x1c]
                  |L1.2152|
;;;1035       }
;;;1036   #endif
;;;1037   
;;;1038       return (prio);
000868  4630              MOV      r0,r6
;;;1039   }
00086a  bd70              POP      {r4-r6,pc}
                  |L1.2156|
                          DCD      ||.bss||+0x140
                  |L1.2160|
000870  75432f4f          DCB      "uC/OS-II Stat",0
000874  532d4949
000878  20537461
00087c  7400    
00087e  00                DCB      0
00087f  00                DCB      0
                  |L1.2176|
                          DCD      ||.data||
                  |L1.2180|
                          DCD      ||.bss||+0x340
                  |L1.2184|
000888  75432f4f          DCB      "uC/OS-II Idle",0
00088c  532d4949
000890  2049646c
000894  6500    
000896  00                DCB      0
000897  00                DCB      0
                  |L1.2200|
                          DCD      ||.bss||
                  |L1.2204|
                          DCD      ||.bss||+0x5c0
                  |L1.2208|
                          DCD      ||.bss||+0x540
                  |L1.2212|
                          DCD      ||.data||+0x1c
                  |L1.2216|
                          DCD      ||.constdata||
                          ENDP

                  OS_EventTaskWait PROC
;;;1056   #if (OS_EVENT_EN)
;;;1057   void  OS_EventTaskWait (OS_EVENT *pevent)
0008ac  b410              PUSH     {r4}
;;;1058   {
;;;1059       INT8U  y;
;;;1060   
;;;1061   
;;;1062       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
0008ae  f8dfc17c          LDR      r12,|L1.2604|
0008b2  f8dc1024          LDR      r1,[r12,#0x24]  ; OSTCBCur
0008b6  61c8              STR      r0,[r1,#0x1c]
;;;1063   
;;;1064       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
0008b8  f8912034          LDRB     r2,[r1,#0x34]
0008bc  f100030b          ADD      r3,r0,#0xb
0008c0  f8911035          LDRB     r1,[r1,#0x35]
0008c4  5cd4              LDRB     r4,[r2,r3]
0008c6  4321              ORRS     r1,r1,r4
0008c8  54d1              STRB     r1,[r2,r3]
;;;1065       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
0008ca  f8dc1024          LDR      r1,[r12,#0x24]  ; OSTCBCur
0008ce  7a82              LDRB     r2,[r0,#0xa]
0008d0  f8913036          LDRB     r3,[r1,#0x36]
0008d4  431a              ORRS     r2,r2,r3
0008d6  7282              STRB     r2,[r0,#0xa]
;;;1066   
;;;1067       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
0008d8  f8910034          LDRB     r0,[r1,#0x34]
;;;1068       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
0008dc  f10c031c          ADD      r3,r12,#0x1c
0008e0  f8914035          LDRB     r4,[r1,#0x35]
0008e4  5c1a              LDRB     r2,[r3,r0]
0008e6  43a2              BICS     r2,r2,r4
0008e8  541a              STRB     r2,[r3,r0]
;;;1069       if (OSRdyTbl[y] == 0) {
0008ea  2a00              CMP      r2,#0
0008ec  d107              BNE      |L1.2302|
;;;1070           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
0008ee  f8910036          LDRB     r0,[r1,#0x36]
0008f2  f89c1006          LDRB     r1,[r12,#6]  ; OSRdyGrp
0008f6  ea210000          BIC      r0,r1,r0
0008fa  f88c0006          STRB     r0,[r12,#6]
                  |L1.2302|
;;;1071       }
;;;1072   }
0008fe  bc10              POP      {r4}
000900  4770              BX       lr
;;;1073   #endif
                          ENDP

                  OS_EventWaitListInit PROC
;;;1208   #if (OS_EVENT_EN)
;;;1209   void  OS_EventWaitListInit (OS_EVENT *pevent)
000902  2200              MOVS     r2,#0
;;;1210   {
;;;1211   #if OS_LOWEST_PRIO <= 63
;;;1212       INT8U  *ptbl;
;;;1213   #else
;;;1214       INT16U *ptbl;
;;;1215   #endif
;;;1216       INT8U   i;
;;;1217   
;;;1218   
;;;1219       pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
000904  7282              STRB     r2,[r0,#0xa]
;;;1220       ptbl               = &pevent->OSEventTbl[0];
000906  300b              ADDS     r0,r0,#0xb
;;;1221   
;;;1222       for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
000908  2100              MOVS     r1,#0
                  |L1.2314|
;;;1223           *ptbl++ = 0;
00090a  f8002b01          STRB     r2,[r0],#1
00090e  1c49              ADDS     r1,r1,#1              ;1222
000910  b2c9              UXTB     r1,r1                 ;1222
000912  2904              CMP      r1,#4                 ;1222
000914  d3f9              BCC      |L1.2314|
;;;1224       }
;;;1225   }
000916  4770              BX       lr
;;;1226   #endif
                          ENDP

                  OS_MemCopy PROC
;;;1580   
;;;1581   void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
000918  2a00              CMP      r2,#0
;;;1582   {
00091a  d007              BEQ      |L1.2348|
                  |L1.2332|
;;;1583       while (size > 0) {
;;;1584           *pdest++ = *psrc++;
00091c  f8113b01          LDRB     r3,[r1],#1
000920  f8003b01          STRB     r3,[r0],#1
;;;1585           size--;
000924  1e52              SUBS     r2,r2,#1
000926  b292              UXTH     r2,r2
000928  2a00              CMP      r2,#0                 ;1583
00092a  d1f7              BNE      |L1.2332|
                  |L1.2348|
;;;1586       }
;;;1587   }
00092c  4770              BX       lr
;;;1588   /*$PAGE*/
                          ENDP

                  OS_TCBInit PROC
;;;1921   
;;;1922   INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
00092e  e92d5fff          PUSH     {r0-r12,lr}
;;;1923   {
000932  4606              MOV      r6,r0
000934  460d              MOV      r5,r1
000936  4693              MOV      r11,r2
000938  f8dd9040          LDR      r9,[sp,#0x40]
00093c  f8dd803c          LDR      r8,[sp,#0x3c]
000940  9f0e              LDR      r7,[sp,#0x38]
;;;1924       OS_TCB    *ptcb;
;;;1925   #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;1926       OS_CPU_SR  cpu_sr = 0;
;;;1927   #endif
;;;1928   
;;;1929   
;;;1930   
;;;1931       OS_ENTER_CRITICAL();
000942  f7fffffe          BL       OS_CPU_SR_Save
;;;1932       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
000946  f8dfa0e4          LDR      r10,|L1.2604|
00094a  f8da4028          LDR      r4,[r10,#0x28]  ; OSTCBFreeList
;;;1933       if (ptcb != (OS_TCB *)0) {
00094e  2c00              CMP      r4,#0
000950  d066              BEQ      |L1.2592|
;;;1934           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
000952  6961              LDR      r1,[r4,#0x14]
000954  f8ca1028          STR      r1,[r10,#0x28]  ; OSTCBFreeList
;;;1935           OS_EXIT_CRITICAL();
000958  f7fffffe          BL       OS_CPU_SR_Restore
;;;1936           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
00095c  6025              STR      r5,[r4,#0]
;;;1937           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
00095e  f8846032          STRB     r6,[r4,#0x32]
;;;1938           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
000962  2500              MOVS     r5,#0
000964  f8845030          STRB     r5,[r4,#0x30]
;;;1939           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
000968  f8845031          STRB     r5,[r4,#0x31]
;;;1940           ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
00096c  85e5              STRH     r5,[r4,#0x2e]
;;;1941   
;;;1942   #if OS_TASK_CREATE_EXT_EN > 0
;;;1943           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
00096e  f8c48004          STR      r8,[r4,#4]
;;;1944           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
000972  60e7              STR      r7,[r4,#0xc]
;;;1945           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
000974  f8c4b008          STR      r11,[r4,#8]
;;;1946           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
000978  f8a49010          STRH     r9,[r4,#0x10]
;;;1947           ptcb->OSTCBId            = id;                     /* Store task ID                            */
00097c  9803              LDR      r0,[sp,#0xc]
00097e  8260              STRH     r0,[r4,#0x12]
;;;1948   #else
;;;1949           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1950           stk_size                 = stk_size;
;;;1951           pbos                     = pbos;
;;;1952           opt                      = opt;
;;;1953           id                       = id;
;;;1954   #endif
;;;1955   
;;;1956   #if OS_TASK_DEL_EN > 0
;;;1957           ptcb->OSTCBDelReq        = OS_ERR_NONE;
000980  f8845037          STRB     r5,[r4,#0x37]
;;;1958   #endif
;;;1959   
;;;1960   #if OS_LOWEST_PRIO <= 63
;;;1961           ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
000984  08f0              LSRS     r0,r6,#3
000986  f8840034          STRB     r0,[r4,#0x34]
;;;1962           ptcb->OSTCBX             = (INT8U)(prio & 0x07);
00098a  f0060107          AND      r1,r6,#7
00098e  f8841033          STRB     r1,[r4,#0x33]
;;;1963           ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
000992  2201              MOVS     r2,#1
000994  fa02f000          LSL      r0,r2,r0
000998  f8840036          STRB     r0,[r4,#0x36]
;;;1964           ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
00099c  fa02f001          LSL      r0,r2,r1
0009a0  f8840035          STRB     r0,[r4,#0x35]
;;;1965   #else
;;;1966           ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* Pre-compute X, Y, BitX and BitY     */
;;;1967           ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
;;;1968           ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
;;;1969           ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
;;;1970   #endif
;;;1971   
;;;1972   #if (OS_EVENT_EN)
;;;1973           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
0009a4  61e5              STR      r5,[r4,#0x1c]
;;;1974   #if (OS_EVENT_MULTI_EN > 0)
;;;1975           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
0009a6  6225              STR      r5,[r4,#0x20]
;;;1976   #endif
;;;1977   #endif
;;;1978   
;;;1979   #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
;;;1980           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
0009a8  62a5              STR      r5,[r4,#0x28]
;;;1981   #endif
;;;1982   
;;;1983   #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;1984           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
0009aa  6265              STR      r5,[r4,#0x24]
;;;1985   #endif
;;;1986   
;;;1987   #if OS_TASK_PROFILE_EN > 0
;;;1988           ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
0009ac  63a5              STR      r5,[r4,#0x38]
;;;1989           ptcb->OSTCBCyclesStart = 0L;
0009ae  6425              STR      r5,[r4,#0x40]
;;;1990           ptcb->OSTCBCyclesTot   = 0L;
0009b0  63e5              STR      r5,[r4,#0x3c]
;;;1991           ptcb->OSTCBStkBase     = (OS_STK *)0;
0009b2  6465              STR      r5,[r4,#0x44]
;;;1992           ptcb->OSTCBStkUsed     = 0L;
0009b4  64a5              STR      r5,[r4,#0x48]
;;;1993   #endif
;;;1994   
;;;1995   #if OS_TASK_NAME_SIZE > 1
;;;1996           ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
0009b6  203f              MOVS     r0,#0x3f
0009b8  f884004c          STRB     r0,[r4,#0x4c]
;;;1997           ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
0009bc  f884504d          STRB     r5,[r4,#0x4d]
;;;1998   #endif
;;;1999   
;;;2000           OSTCBInitHook(ptcb);
0009c0  4620              MOV      r0,r4
0009c2  f7fffffe          BL       OSTCBInitHook
;;;2001   
;;;2002           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
0009c6  4620              MOV      r0,r4
0009c8  f7fffffe          BL       OSTaskCreateHook
;;;2003   
;;;2004           OS_ENTER_CRITICAL();
0009cc  f7fffffe          BL       OS_CPU_SR_Save
0009d0  4602              MOV      r2,r0
;;;2005           OSTCBPrioTbl[prio] = ptcb;
0009d2  4817              LDR      r0,|L1.2608|
0009d4  f8404026          STR      r4,[r0,r6,LSL #2]
;;;2006           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
0009d8  f8da0030          LDR      r0,[r10,#0x30]  ; OSTCBList
0009dc  6160              STR      r0,[r4,#0x14]
;;;2007           ptcb->OSTCBPrev    = (OS_TCB *)0;
0009de  61a5              STR      r5,[r4,#0x18]
;;;2008           if (OSTCBList != (OS_TCB *)0) {
0009e0  b100              CBZ      r0,|L1.2532|
;;;2009               OSTCBList->OSTCBPrev = ptcb;
0009e2  6184              STR      r4,[r0,#0x18]
                  |L1.2532|
;;;2010           }
;;;2011           OSTCBList               = ptcb;
0009e4  f8ca4030          STR      r4,[r10,#0x30]  ; OSTCBList
;;;2012           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
0009e8  f8940036          LDRB     r0,[r4,#0x36]
0009ec  f89a1006          LDRB     r1,[r10,#6]  ; OSRdyGrp
0009f0  4308              ORRS     r0,r0,r1
0009f2  f88a0006          STRB     r0,[r10,#6]
;;;2013           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0009f6  f8940034          LDRB     r0,[r4,#0x34]
0009fa  490e              LDR      r1,|L1.2612|
0009fc  f894c035          LDRB     r12,[r4,#0x35]
000a00  5c0b              LDRB     r3,[r1,r0]
000a02  ea43030c          ORR      r3,r3,r12
000a06  540b              STRB     r3,[r1,r0]
;;;2014           OSTaskCtr++;                                       /* Increment the #tasks counter             */
000a08  f89a0008          LDRB     r0,[r10,#8]  ; OSTaskCtr
000a0c  1c40              ADDS     r0,r0,#1
000a0e  f88a0008          STRB     r0,[r10,#8]
;;;2015           OS_EXIT_CRITICAL();
000a12  4610              MOV      r0,r2
000a14  f7fffffe          BL       OS_CPU_SR_Restore
;;;2016           return (OS_ERR_NONE);
;;;2017       }
;;;2018       OS_EXIT_CRITICAL();
;;;2019       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2020   }
000a18  b004              ADD      sp,sp,#0x10
000a1a  2000              MOVS     r0,#0                 ;2016
000a1c  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.2592|
000a20  f7fffffe          BL       OS_CPU_SR_Restore
000a24  b004              ADD      sp,sp,#0x10
000a26  2042              MOVS     r0,#0x42              ;2019
000a28  e8bd9ff0          POP      {r4-r12,pc}
                          ENDP

                  |L1.2604|
                          DCD      ||.data||
                  |L1.2608|
                          DCD      ||.bss||+0x540
                  |L1.2612|
                          DCD      ||.data||+0x1c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        320
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        128
                  OSTCBTbl
                          %        2024

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.4||, ||.bss||
                  OSFlagTbl
                          %        140

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCPUUsage
000000  00                DCB      0x00
                  OSStatRdy
000001  00                DCB      0x00
                  OSIntNesting
000002  00                DCB      0x00
                  OSLockNesting
000003  00                DCB      0x00
                  OSPrioCur
000004  00                DCB      0x00
                  OSPrioHighRdy
000005  00                DCB      0x00
                  OSRdyGrp
000006  00                DCB      0x00
                  OSRunning
000007  00                DCB      0x00
                  OSTaskCtr
000008  00                DCB      0x00
                  OSTickStepState
000009  000000            DCB      0x00,0x00,0x00
                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSRdyTbl
                          DCD      0x00000000
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTime
                          DCD      0x00000000

                          AREA ||area_number.8||, DATA, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.data||
                  OSFlagFreeList
                          DCD      0x00000000
