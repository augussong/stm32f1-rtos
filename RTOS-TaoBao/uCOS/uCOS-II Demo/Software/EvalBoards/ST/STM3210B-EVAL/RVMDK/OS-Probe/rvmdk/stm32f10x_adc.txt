; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\rvmdk\stm32f10x_adc.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\stm32f10x_adc.d --cpu=Cortex-M3 --apcs=interwork -O1 -Otime --diag_suppress=9931 -I. -I..\BSP -I..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView -I..\..\..\..\..\uCOS-II\Source -I..\..\..\..\..\CPU\ST\STM32\inc -I..\..\..\..\..\uC-CPU -I..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView -I..\..\..\..\..\uC-LIB -I..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32 -I..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source -I.\RTE\_Flash -I"C:\Program Files\0Software\Keil_v5\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"C:\Program Files\0Software\Keil_v5\ARM\CMSIS\Include" -I"C:\Program Files\0Software\Keil_v5\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0" -D__MICROLIB -D__UVISION_VERSION=528 -DSTM32F10X_MD --omf_browse=.\rvmdk\stm32f10x_adc.crf ..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;131    *******************************************************************************/
;;;132    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;133    {
;;;134      /* Check the parameters */
;;;135      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;136    
;;;137      switch (*(u32*)&ADCx)
000002  f1a04080          SUB      r0,r0,#0x40000000
000006  f5b03092          SUBS     r0,r0,#0x12400
00000a  d010              BEQ      |L1.46|
00000c  f5b06f80          CMP      r0,#0x400
000010  d018              BEQ      |L1.68|
000012  f5b05fc0          CMP      r0,#0x1800
000016  d120              BNE      |L1.90|
;;;138      {
;;;139        case ADC1_BASE:
;;;140          /* Enable ADC1 reset state */
;;;141          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
;;;142          /* Release ADC1 from reset state */
;;;143          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
;;;144          break;
;;;145        
;;;146        case ADC2_BASE:
;;;147          /* Enable ADC2 reset state */
;;;148          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
;;;149          /* Release ADC2 from reset state */
;;;150          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
;;;151          break;
;;;152          
;;;153        case ADC3_BASE:
;;;154          /* Enable ADC3 reset state */
;;;155          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
000018  2101              MOVS     r1,#1
00001a  03c8              LSLS     r0,r1,#15
00001c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;156          /* Release ADC3 from reset state */
;;;157          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
000020  e8bd4010          POP      {r4,lr}
000024  2100              MOVS     r1,#0
000026  f44f4000          MOV      r0,#0x8000
00002a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.46|
00002e  2101              MOVS     r1,#1                 ;141
000030  0248              LSLS     r0,r1,#9              ;141
000032  f7fffffe          BL       RCC_APB2PeriphResetCmd
000036  e8bd4010          POP      {r4,lr}               ;143
00003a  2100              MOVS     r1,#0                 ;143
00003c  f44f7000          MOV      r0,#0x200             ;143
000040  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.68|
000044  2101              MOVS     r1,#1                 ;148
000046  0288              LSLS     r0,r1,#10             ;148
000048  f7fffffe          BL       RCC_APB2PeriphResetCmd
00004c  e8bd4010          POP      {r4,lr}               ;150
000050  2100              MOVS     r1,#0                 ;150
000052  f44f6080          MOV      r0,#0x400             ;150
000056  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L1.90|
;;;158          break; 
;;;159    
;;;160        default:
;;;161          break;
;;;162      }
;;;163    }
00005a  bd10              POP      {r4,pc}
;;;164    
                          ENDP

                  ADC_Init PROC
;;;175    ******************************************************************************/
;;;176    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
00005c  6842              LDR      r2,[r0,#4]
;;;177    {
;;;178      u32 tmpreg1 = 0;
;;;179      u8 tmpreg2 = 0;
;;;180    
;;;181      /* Check the parameters */
;;;182      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;183      assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
;;;184      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;185      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));  		    
;;;186      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
;;;187      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;188      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
;;;189    
;;;190      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;191      /* Get the ADCx CR1 value */
;;;192      tmpreg1 = ADCx->CR1;
;;;193      /* Clear DUALMOD and SCAN bits */
;;;194      tmpreg1 &= CR1_CLEAR_Mask;
00005e  f4227280          BIC      r2,r2,#0x100
000062  f4222270          BIC      r2,r2,#0xf0000
;;;195      /* Configure ADCx: Dual mode and scan conversion mode */
;;;196      /* Set DUALMOD bits according to ADC_Mode value */
;;;197      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;198      tmpreg1 |= (u32)(ADC_InitStruct->ADC_Mode | ((u32)ADC_InitStruct->ADC_ScanConvMode << 8));
000066  f891c004          LDRB     r12,[r1,#4]
00006a  680b              LDR      r3,[r1,#0]
00006c  ea42220c          ORR      r2,r2,r12,LSL #8
000070  431a              ORRS     r2,r2,r3
;;;199      /* Write to ADCx CR1 */
;;;200      ADCx->CR1 = tmpreg1;
000072  6042              STR      r2,[r0,#4]
;;;201    
;;;202      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;203      /* Get the ADCx CR2 value */
;;;204      tmpreg1 = ADCx->CR2;
000074  6882              LDR      r2,[r0,#8]
;;;205      /* Clear CONT, ALIGN and EXTSEL bits */
;;;206      tmpreg1 &= CR2_CLEAR_Mask;
000076  4bca              LDR      r3,|L1.928|
000078  401a              ANDS     r2,r2,r3
;;;207      /* Configure ADCx: external trigger event and continuous conversion mode */
;;;208      /* Set ALIGN bit according to ADC_DataAlign value */
;;;209      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;210      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;211      tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
00007a  f8d1c008          LDR      r12,[r1,#8]
00007e  68cb              LDR      r3,[r1,#0xc]
000080  ea43030c          ORR      r3,r3,r12
000084  f891c005          LDRB     r12,[r1,#5]
000088  ea42024c          ORR      r2,r2,r12,LSL #1
00008c  431a              ORRS     r2,r2,r3
;;;212                ((u32)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;213      /* Write to ADCx CR2 */
;;;214      ADCx->CR2 = tmpreg1;
00008e  6082              STR      r2,[r0,#8]
;;;215    
;;;216      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;217      /* Get the ADCx SQR1 value */
;;;218      tmpreg1 = ADCx->SQR1;
000090  6ac2              LDR      r2,[r0,#0x2c]
;;;219      /* Clear L bits */
;;;220      tmpreg1 &= SQR1_CLEAR_Mask;
000092  f4220270          BIC      r2,r2,#0xf00000
;;;221      /* Configure ADCx: regular channel sequence length */
;;;222      /* Set L bits according to ADC_NbrOfChannel value */
;;;223      tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
000096  7c09              LDRB     r1,[r1,#0x10]
000098  1e49              SUBS     r1,r1,#1
00009a  b2c9              UXTB     r1,r1
;;;224      tmpreg1 |= ((u32)tmpreg2 << 20);
00009c  ea425101          ORR      r1,r2,r1,LSL #20
;;;225      /* Write to ADCx SQR1 */
;;;226      ADCx->SQR1 = tmpreg1;
0000a0  62c1              STR      r1,[r0,#0x2c]
;;;227    }
0000a2  4770              BX       lr
;;;228    
                          ENDP

                  ADC_StructInit PROC
;;;236    *******************************************************************************/
;;;237    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
0000a4  2100              MOVS     r1,#0
;;;238    {
;;;239      /* Reset ADC init structure parameters values */
;;;240      /* Initialize the ADC_Mode member */
;;;241      ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
0000a6  6001              STR      r1,[r0,#0]
;;;242    
;;;243      /* initialize the ADC_ScanConvMode member */
;;;244      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
0000a8  7101              STRB     r1,[r0,#4]
;;;245    
;;;246      /* Initialize the ADC_ContinuousConvMode member */
;;;247      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
0000aa  7141              STRB     r1,[r0,#5]
;;;248    
;;;249      /* Initialize the ADC_ExternalTrigConv member */
;;;250      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
0000ac  6081              STR      r1,[r0,#8]
;;;251    
;;;252      /* Initialize the ADC_DataAlign member */
;;;253      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
0000ae  60c1              STR      r1,[r0,#0xc]
;;;254    
;;;255      /* Initialize the ADC_NbrOfChannel member */
;;;256      ADC_InitStruct->ADC_NbrOfChannel = 1;
0000b0  2101              MOVS     r1,#1
0000b2  7401              STRB     r1,[r0,#0x10]
;;;257    }
0000b4  4770              BX       lr
;;;258    
                          ENDP

                  ADC_Cmd PROC
;;;267    *******************************************************************************/
;;;268    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0000b6  2900              CMP      r1,#0
;;;269    {
0000b8  d004              BEQ      |L1.196|
;;;270      /* Check the parameters */
;;;271      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;272      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;273    
;;;274      if (NewState != DISABLE)
;;;275      {
;;;276        /* Set the ADON bit to wake up the ADC from power down mode */
;;;277        ADCx->CR2 |= CR2_ADON_Set;
0000ba  6881              LDR      r1,[r0,#8]
0000bc  f0410101          ORR      r1,r1,#1
0000c0  6081              STR      r1,[r0,#8]
;;;278      }
;;;279      else
;;;280      {
;;;281        /* Disable the selected ADC peripheral */
;;;282        ADCx->CR2 &= CR2_ADON_Reset;
;;;283      }
;;;284    }
0000c2  4770              BX       lr
                  |L1.196|
0000c4  6881              LDR      r1,[r0,#8]            ;282
0000c6  f0210101          BIC      r1,r1,#1              ;282
0000ca  6081              STR      r1,[r0,#8]            ;282
0000cc  4770              BX       lr
;;;285    
                          ENDP

                  ADC_DMACmd PROC
;;;295    *******************************************************************************/
;;;296    void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0000ce  2900              CMP      r1,#0
;;;297    {
0000d0  d004              BEQ      |L1.220|
;;;298      /* Check the parameters */
;;;299      assert_param(IS_ADC_DMA_PERIPH(ADCx));
;;;300      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;301    
;;;302      if (NewState != DISABLE)
;;;303      {
;;;304        /* Enable the selected ADC DMA request */
;;;305        ADCx->CR2 |= CR2_DMA_Set;
0000d2  6881              LDR      r1,[r0,#8]
0000d4  f4417180          ORR      r1,r1,#0x100
0000d8  6081              STR      r1,[r0,#8]
;;;306      }
;;;307      else
;;;308      {
;;;309        /* Disable the selected ADC DMA request */
;;;310        ADCx->CR2 &= CR2_DMA_Reset;
;;;311      }
;;;312    }
0000da  4770              BX       lr
                  |L1.220|
0000dc  6881              LDR      r1,[r0,#8]            ;310
0000de  f4217180          BIC      r1,r1,#0x100          ;310
0000e2  6081              STR      r1,[r0,#8]            ;310
0000e4  4770              BX       lr
;;;313    
                          ENDP

                  ADC_ITConfig PROC
;;;328    *******************************************************************************/
;;;329    void ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState)
0000e6  b2c9              UXTB     r1,r1
;;;330    {
;;;331      u8 itmask = 0;
;;;332    
;;;333      /* Check the parameters */
;;;334      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;335      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;336      assert_param(IS_ADC_IT(ADC_IT));
;;;337    
;;;338      /* Get the ADC IT index */
;;;339      itmask = (u8)ADC_IT;
;;;340    
;;;341      if (NewState != DISABLE)
0000e8  2a00              CMP      r2,#0
0000ea  d003              BEQ      |L1.244|
;;;342      {
;;;343        /* Enable the selected ADC interrupts */
;;;344        ADCx->CR1 |= itmask;
0000ec  6842              LDR      r2,[r0,#4]
0000ee  4311              ORRS     r1,r1,r2
0000f0  6041              STR      r1,[r0,#4]
;;;345      }
;;;346      else
;;;347      {
;;;348        /* Disable the selected ADC interrupts */
;;;349        ADCx->CR1 &= (~(u32)itmask);
;;;350      }
;;;351    }
0000f2  4770              BX       lr
                  |L1.244|
0000f4  6842              LDR      r2,[r0,#4]            ;349
0000f6  ea220101          BIC      r1,r2,r1              ;349
0000fa  6041              STR      r1,[r0,#4]            ;349
0000fc  4770              BX       lr
;;;352    
                          ENDP

                  ADC_ResetCalibration PROC
;;;359    *******************************************************************************/
;;;360    void ADC_ResetCalibration(ADC_TypeDef* ADCx)
0000fe  6881              LDR      r1,[r0,#8]
;;;361    {
;;;362      /* Check the parameters */
;;;363      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;364    
;;;365      /* Resets the selected ADC calibartion registers */  
;;;366      ADCx->CR2 |= CR2_RSTCAL_Set;
000100  f0410108          ORR      r1,r1,#8
000104  6081              STR      r1,[r0,#8]
;;;367    }
000106  4770              BX       lr
;;;368    
                          ENDP

                  ADC_GetResetCalibrationStatus PROC
;;;375    *******************************************************************************/
;;;376    FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
000108  4601              MOV      r1,r0
;;;377    {
;;;378      FlagStatus bitstatus = RESET;
00010a  2000              MOVS     r0,#0
;;;379    
;;;380      /* Check the parameters */
;;;381      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;382    
;;;383      /* Check the status of RSTCAL bit */
;;;384      if ((ADCx->CR2 & CR2_RSTCAL_Set) != (u32)RESET)
00010c  6889              LDR      r1,[r1,#8]
00010e  f0110f08          TST      r1,#8
000112  d000              BEQ      |L1.278|
;;;385      {
;;;386        /* RSTCAL bit is set */
;;;387        bitstatus = SET;
000114  2001              MOVS     r0,#1
                  |L1.278|
;;;388      }
;;;389      else
;;;390      {
;;;391        /* RSTCAL bit is reset */
;;;392        bitstatus = RESET;
;;;393      }
;;;394    
;;;395      /* Return the RSTCAL bit status */
;;;396      return  bitstatus;
;;;397    }
000116  4770              BX       lr
;;;398    
                          ENDP

                  ADC_StartCalibration PROC
;;;405    *******************************************************************************/
;;;406    void ADC_StartCalibration(ADC_TypeDef* ADCx)
000118  6881              LDR      r1,[r0,#8]
;;;407    {
;;;408      /* Check the parameters */
;;;409      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;410    
;;;411      /* Enable the selected ADC calibration process */  
;;;412      ADCx->CR2 |= CR2_CAL_Set;
00011a  f0410104          ORR      r1,r1,#4
00011e  6081              STR      r1,[r0,#8]
;;;413    }
000120  4770              BX       lr
;;;414    
                          ENDP

                  ADC_GetCalibrationStatus PROC
;;;421    *******************************************************************************/
;;;422    FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
000122  4601              MOV      r1,r0
;;;423    {
;;;424      FlagStatus bitstatus = RESET;
000124  2000              MOVS     r0,#0
;;;425    
;;;426      /* Check the parameters */
;;;427      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;428    
;;;429      /* Check the status of CAL bit */
;;;430      if ((ADCx->CR2 & CR2_CAL_Set) != (u32)RESET)
000126  6889              LDR      r1,[r1,#8]
000128  f0110f04          TST      r1,#4
00012c  d000              BEQ      |L1.304|
;;;431      {
;;;432        /* CAL bit is set: calibration on going */
;;;433        bitstatus = SET;
00012e  2001              MOVS     r0,#1
                  |L1.304|
;;;434      }
;;;435      else
;;;436      {
;;;437        /* CAL bit is reset: end of calibration */
;;;438        bitstatus = RESET;
;;;439      }
;;;440    
;;;441      /* Return the CAL bit status */
;;;442      return  bitstatus;
;;;443    }
000130  4770              BX       lr
;;;444    
                          ENDP

                  ADC_SoftwareStartConvCmd PROC
;;;453    *******************************************************************************/
;;;454    void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000132  2900              CMP      r1,#0
;;;455    {
000134  d004              BEQ      |L1.320|
;;;456      /* Check the parameters */
;;;457      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;458      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;459    
;;;460      if (NewState != DISABLE)
;;;461      {
;;;462        /* Enable the selected ADC conversion on external event and start the selected
;;;463           ADC conversion */
;;;464        ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
000136  6881              LDR      r1,[r0,#8]
000138  f44101a0          ORR      r1,r1,#0x500000
00013c  6081              STR      r1,[r0,#8]
;;;465      }
;;;466      else
;;;467      {
;;;468        /* Disable the selected ADC conversion on external event and stop the selected
;;;469           ADC conversion */
;;;470        ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
;;;471      }
;;;472    }
00013e  4770              BX       lr
                  |L1.320|
000140  6881              LDR      r1,[r0,#8]            ;470
000142  f42101a0          BIC      r1,r1,#0x500000       ;470
000146  6081              STR      r1,[r0,#8]            ;470
000148  4770              BX       lr
;;;473    
                          ENDP

                  ADC_GetSoftwareStartConvStatus PROC
;;;480    *******************************************************************************/
;;;481    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
00014a  4601              MOV      r1,r0
;;;482    {
;;;483      FlagStatus bitstatus = RESET;
00014c  2000              MOVS     r0,#0
;;;484    
;;;485      /* Check the parameters */
;;;486      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;487    
;;;488      /* Check the status of SWSTART bit */
;;;489      if ((ADCx->CR2 & CR2_SWSTART_Set) != (u32)RESET)
00014e  6889              LDR      r1,[r1,#8]
000150  f4110f80          TST      r1,#0x400000
000154  d000              BEQ      |L1.344|
;;;490      {
;;;491        /* SWSTART bit is set */
;;;492        bitstatus = SET;
000156  2001              MOVS     r0,#1
                  |L1.344|
;;;493      }
;;;494      else
;;;495      {
;;;496        /* SWSTART bit is reset */
;;;497        bitstatus = RESET;
;;;498      }
;;;499    
;;;500      /* Return the SWSTART bit status */
;;;501      return  bitstatus;
;;;502    }
000158  4770              BX       lr
;;;503    
                          ENDP

                  ADC_DiscModeChannelCountConfig PROC
;;;513    *******************************************************************************/
;;;514    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number)
00015a  6842              LDR      r2,[r0,#4]
;;;515    {
;;;516      u32 tmpreg1 = 0;
;;;517      u32 tmpreg2 = 0;
;;;518    
;;;519      /* Check the parameters */
;;;520      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;521      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;522    
;;;523      /* Get the old register value */
;;;524      tmpreg1 = ADCx->CR1;
;;;525      /* Clear the old discontinuous mode channel count */
;;;526      tmpreg1 &= CR1_DISCNUM_Reset;
00015c  f4224260          BIC      r2,r2,#0xe000
;;;527      /* Set the discontinuous mode channel count */
;;;528      tmpreg2 = Number - 1;
000160  1e49              SUBS     r1,r1,#1
;;;529      tmpreg1 |= tmpreg2 << 13;
000162  ea423141          ORR      r1,r2,r1,LSL #13
;;;530      /* Store the new register value */
;;;531      ADCx->CR1 = tmpreg1;
000166  6041              STR      r1,[r0,#4]
;;;532    }
000168  4770              BX       lr
;;;533    
                          ENDP

                  ADC_DiscModeCmd PROC
;;;544    *******************************************************************************/
;;;545    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00016a  2900              CMP      r1,#0
;;;546    {
00016c  d004              BEQ      |L1.376|
;;;547      /* Check the parameters */
;;;548      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;549      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;550    
;;;551      if (NewState != DISABLE)
;;;552      {
;;;553        /* Enable the selected ADC regular discontinuous mode */
;;;554        ADCx->CR1 |= CR1_DISCEN_Set;
00016e  6841              LDR      r1,[r0,#4]
000170  f4416100          ORR      r1,r1,#0x800
000174  6041              STR      r1,[r0,#4]
;;;555      }
;;;556      else
;;;557      {
;;;558        /* Disable the selected ADC regular discontinuous mode */
;;;559        ADCx->CR1 &= CR1_DISCEN_Reset;
;;;560      }
;;;561    }
000176  4770              BX       lr
                  |L1.376|
000178  6841              LDR      r1,[r0,#4]            ;559
00017a  f4216100          BIC      r1,r1,#0x800          ;559
00017e  6041              STR      r1,[r0,#4]            ;559
000180  4770              BX       lr
;;;562    
                          ENDP

                  ADC_RegularChannelConfig PROC
;;;603    *******************************************************************************/
;;;604    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
000182  b430              PUSH     {r4,r5}
;;;605    {
;;;606      u32 tmpreg1 = 0, tmpreg2 = 0;
;;;607    
;;;608      /* Check the parameters */
;;;609      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;610      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;611      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;612      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;613    
;;;614      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;615      if (ADC_Channel > ADC_Channel_9)
;;;616      {
;;;617        /* Get the old register value */
;;;618        tmpreg1 = ADCx->SMPR1;
;;;619        /* Calculate the mask to clear */
;;;620        tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
000184  2507              MOVS     r5,#7
000186  2909              CMP      r1,#9                 ;615
000188  d90c              BLS      |L1.420|
00018a  68c4              LDR      r4,[r0,#0xc]          ;618
00018c  f1a10c0a          SUB      r12,r1,#0xa
000190  eb0c0c4c          ADD      r12,r12,r12,LSL #1
000194  fa05f50c          LSL      r5,r5,r12
;;;621        /* Clear the old discontinuous mode channel count */
;;;622        tmpreg1 &= ~tmpreg2;
000198  43ac              BICS     r4,r4,r5
;;;623        /* Calculate the mask to set */
;;;624        tmpreg2 = (u32)ADC_SampleTime << (3 * (ADC_Channel - 10));
00019a  fa03f30c          LSL      r3,r3,r12
;;;625        /* Set the discontinuous mode channel count */
;;;626        tmpreg1 |= tmpreg2;
00019e  4323              ORRS     r3,r3,r4
;;;627        /* Store the new register value */
;;;628        ADCx->SMPR1 = tmpreg1;
0001a0  60c3              STR      r3,[r0,#0xc]
0001a2  e009              B        |L1.440|
                  |L1.420|
;;;629      }
;;;630      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;631      {
;;;632        /* Get the old register value */
;;;633        tmpreg1 = ADCx->SMPR2;
0001a4  6904              LDR      r4,[r0,#0x10]
;;;634        /* Calculate the mask to clear */
;;;635        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
0001a6  eb010c41          ADD      r12,r1,r1,LSL #1
0001aa  fa05f50c          LSL      r5,r5,r12
;;;636        /* Clear the old discontinuous mode channel count */
;;;637        tmpreg1 &= ~tmpreg2;
0001ae  43ac              BICS     r4,r4,r5
;;;638        /* Calculate the mask to set */
;;;639        tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
0001b0  fa03f30c          LSL      r3,r3,r12
;;;640        /* Set the discontinuous mode channel count */
;;;641        tmpreg1 |= tmpreg2;
0001b4  4323              ORRS     r3,r3,r4
;;;642        /* Store the new register value */
;;;643        ADCx->SMPR2 = tmpreg1;
0001b6  6103              STR      r3,[r0,#0x10]
                  |L1.440|
;;;644      }
;;;645      /* For Rank 1 to 6 */
;;;646      if (Rank < 7)
;;;647      {
;;;648        /* Get the old register value */
;;;649        tmpreg1 = ADCx->SQR3;
;;;650        /* Calculate the mask to clear */
;;;651        tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
0001b8  f04f0c1f          MOV      r12,#0x1f
0001bc  2a07              CMP      r2,#7                 ;646
0001be  d20c              BCS      |L1.474|
0001c0  6b43              LDR      r3,[r0,#0x34]         ;649
0001c2  1e52              SUBS     r2,r2,#1
0001c4  eb020282          ADD      r2,r2,r2,LSL #2
0001c8  fa0cfc02          LSL      r12,r12,r2
;;;652        /* Clear the old SQx bits for the selected rank */
;;;653        tmpreg1 &= ~tmpreg2;
0001cc  ea23030c          BIC      r3,r3,r12
;;;654        /* Calculate the mask to set */
;;;655        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 1));
0001d0  4091              LSLS     r1,r1,r2
;;;656        /* Set the SQx bits for the selected rank */
;;;657        tmpreg1 |= tmpreg2;
0001d2  4319              ORRS     r1,r1,r3
;;;658        /* Store the new register value */
;;;659        ADCx->SQR3 = tmpreg1;
0001d4  6341              STR      r1,[r0,#0x34]
;;;660      }
;;;661      /* For Rank 7 to 12 */
;;;662      else if (Rank < 13)
;;;663      {
;;;664        /* Get the old register value */
;;;665        tmpreg1 = ADCx->SQR2;
;;;666        /* Calculate the mask to clear */
;;;667        tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
;;;668        /* Clear the old SQx bits for the selected rank */
;;;669        tmpreg1 &= ~tmpreg2;
;;;670        /* Calculate the mask to set */
;;;671        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 7));
;;;672        /* Set the SQx bits for the selected rank */
;;;673        tmpreg1 |= tmpreg2;
;;;674        /* Store the new register value */
;;;675        ADCx->SQR2 = tmpreg1;
;;;676      }
;;;677      /* For Rank 13 to 16 */
;;;678      else
;;;679      {
;;;680        /* Get the old register value */
;;;681        tmpreg1 = ADCx->SQR1;
;;;682        /* Calculate the mask to clear */
;;;683        tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
;;;684        /* Clear the old SQx bits for the selected rank */
;;;685        tmpreg1 &= ~tmpreg2;
;;;686        /* Calculate the mask to set */
;;;687        tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 13));
;;;688        /* Set the SQx bits for the selected rank */
;;;689        tmpreg1 |= tmpreg2;
;;;690        /* Store the new register value */
;;;691        ADCx->SQR1 = tmpreg1;
;;;692      }
;;;693    }
0001d6  bc30              POP      {r4,r5}
0001d8  4770              BX       lr
                  |L1.474|
0001da  2a0d              CMP      r2,#0xd               ;662
0001dc  d20c              BCS      |L1.504|
0001de  6b03              LDR      r3,[r0,#0x30]         ;665
0001e0  1fd2              SUBS     r2,r2,#7              ;667
0001e2  eb020282          ADD      r2,r2,r2,LSL #2       ;667
0001e6  fa0cfc02          LSL      r12,r12,r2            ;667
0001ea  ea23030c          BIC      r3,r3,r12             ;669
0001ee  4091              LSLS     r1,r1,r2              ;671
0001f0  4319              ORRS     r1,r1,r3              ;673
0001f2  6301              STR      r1,[r0,#0x30]         ;675
0001f4  bc30              POP      {r4,r5}
0001f6  4770              BX       lr
                  |L1.504|
0001f8  6ac3              LDR      r3,[r0,#0x2c]         ;681
0001fa  3a0d              SUBS     r2,r2,#0xd            ;683
0001fc  eb020282          ADD      r2,r2,r2,LSL #2       ;683
000200  fa0cfc02          LSL      r12,r12,r2            ;683
000204  ea23030c          BIC      r3,r3,r12             ;685
000208  4091              LSLS     r1,r1,r2              ;687
00020a  4319              ORRS     r1,r1,r3              ;689
00020c  62c1              STR      r1,[r0,#0x2c]         ;691
00020e  bc30              POP      {r4,r5}
000210  4770              BX       lr
;;;694    
                          ENDP

                  ADC_ExternalTrigConvCmd PROC
;;;704    *******************************************************************************/
;;;705    void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000212  2900              CMP      r1,#0
;;;706    {
000214  d004              BEQ      |L1.544|
;;;707      /* Check the parameters */
;;;708      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;709      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;710    
;;;711      if (NewState != DISABLE)
;;;712      {
;;;713        /* Enable the selected ADC conversion on external event */
;;;714        ADCx->CR2 |= CR2_EXTTRIG_Set;
000216  6881              LDR      r1,[r0,#8]
000218  f4411180          ORR      r1,r1,#0x100000
00021c  6081              STR      r1,[r0,#8]
;;;715      }
;;;716      else
;;;717      {
;;;718        /* Disable the selected ADC conversion on external event */
;;;719        ADCx->CR2 &= CR2_EXTTRIG_Reset;
;;;720      }
;;;721    }
00021e  4770              BX       lr
                  |L1.544|
000220  6881              LDR      r1,[r0,#8]            ;719
000222  f4211180          BIC      r1,r1,#0x100000       ;719
000226  6081              STR      r1,[r0,#8]            ;719
000228  4770              BX       lr
;;;722    
                          ENDP

                  ADC_GetConversionValue PROC
;;;729    *******************************************************************************/
;;;730    u16 ADC_GetConversionValue(ADC_TypeDef* ADCx)
00022a  6cc0              LDR      r0,[r0,#0x4c]
;;;731    {
;;;732      /* Check the parameters */
;;;733      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;734    
;;;735      /* Return the selected ADC conversion value */
;;;736      return (u16) ADCx->DR;
00022c  b280              UXTH     r0,r0
;;;737    }
00022e  4770              BX       lr
;;;738    
                          ENDP

                  ADC_GetDualModeConversionValue PROC
;;;744    *******************************************************************************/
;;;745    u32 ADC_GetDualModeConversionValue(void)
000230  485c              LDR      r0,|L1.932|
;;;746    {
;;;747      /* Return the dual mode conversion value */
;;;748      return (*(vu32 *) DR_ADDRESS);
000232  6800              LDR      r0,[r0,#0]
;;;749    }
000234  4770              BX       lr
;;;750    
                          ENDP

                  ADC_AutoInjectedConvCmd PROC
;;;761    *******************************************************************************/
;;;762    void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000236  2900              CMP      r1,#0
;;;763    {
000238  d004              BEQ      |L1.580|
;;;764      /* Check the parameters */
;;;765      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;766      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;767    
;;;768      if (NewState != DISABLE)
;;;769      {
;;;770        /* Enable the selected ADC automatic injected group conversion */
;;;771        ADCx->CR1 |= CR1_JAUTO_Set;
00023a  6841              LDR      r1,[r0,#4]
00023c  f4416180          ORR      r1,r1,#0x400
000240  6041              STR      r1,[r0,#4]
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Disable the selected ADC automatic injected group conversion */
;;;776        ADCx->CR1 &= CR1_JAUTO_Reset;
;;;777      }
;;;778    }
000242  4770              BX       lr
                  |L1.580|
000244  6841              LDR      r1,[r0,#4]            ;776
000246  f4216180          BIC      r1,r1,#0x400          ;776
00024a  6041              STR      r1,[r0,#4]            ;776
00024c  4770              BX       lr
;;;779    
                          ENDP

                  ADC_InjectedDiscModeCmd PROC
;;;790    *******************************************************************************/
;;;791    void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00024e  2900              CMP      r1,#0
;;;792    {
000250  d004              BEQ      |L1.604|
;;;793      /* Check the parameters */
;;;794      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;795      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;796    
;;;797      if (NewState != DISABLE)
;;;798      {
;;;799        /* Enable the selected ADC injected discontinuous mode */
;;;800        ADCx->CR1 |= CR1_JDISCEN_Set;
000252  6841              LDR      r1,[r0,#4]
000254  f4415180          ORR      r1,r1,#0x1000
000258  6041              STR      r1,[r0,#4]
;;;801      }
;;;802      else
;;;803      {
;;;804        /* Disable the selected ADC injected discontinuous mode */
;;;805        ADCx->CR1 &= CR1_JDISCEN_Reset;
;;;806      }
;;;807    }
00025a  4770              BX       lr
                  |L1.604|
00025c  6841              LDR      r1,[r0,#4]            ;805
00025e  f4215180          BIC      r1,r1,#0x1000         ;805
000262  6041              STR      r1,[r0,#4]            ;805
000264  4770              BX       lr
;;;808    
                          ENDP

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;846    *******************************************************************************/
;;;847    void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv)
000266  6882              LDR      r2,[r0,#8]
;;;848    {
;;;849      u32 tmpreg = 0;
;;;850    
;;;851      /* Check the parameters */
;;;852      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;853      assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;854    
;;;855      /* Get the old register value */
;;;856      tmpreg = ADCx->CR2;
;;;857      /* Clear the old external event selection for injected group */
;;;858      tmpreg &= CR2_JEXTSEL_Reset;
000268  f42242e0          BIC      r2,r2,#0x7000
;;;859      /* Set the external event selection for injected group */
;;;860      tmpreg |= ADC_ExternalTrigInjecConv;
00026c  4311              ORRS     r1,r1,r2
;;;861      /* Store the new register value */
;;;862      ADCx->CR2 = tmpreg;
00026e  6081              STR      r1,[r0,#8]
;;;863    }
000270  4770              BX       lr
;;;864    
                          ENDP

                  ADC_ExternalTrigInjectedConvCmd PROC
;;;875    *******************************************************************************/
;;;876    void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000272  2900              CMP      r1,#0
;;;877    {
000274  d004              BEQ      |L1.640|
;;;878      /* Check the parameters */
;;;879      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;880      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;881    
;;;882      if (NewState != DISABLE)
;;;883      {
;;;884        /* Enable the selected ADC external event selection for injected group */
;;;885        ADCx->CR2 |= CR2_JEXTTRIG_Set;
000276  6881              LDR      r1,[r0,#8]
000278  f4414100          ORR      r1,r1,#0x8000
00027c  6081              STR      r1,[r0,#8]
;;;886      }
;;;887      else
;;;888      {
;;;889        /* Disable the selected ADC external event selection for injected group */
;;;890        ADCx->CR2 &= CR2_JEXTTRIG_Reset;
;;;891      }
;;;892    }
00027e  4770              BX       lr
                  |L1.640|
000280  6881              LDR      r1,[r0,#8]            ;890
000282  f4214100          BIC      r1,r1,#0x8000         ;890
000286  6081              STR      r1,[r0,#8]            ;890
000288  4770              BX       lr
;;;893    
                          ENDP

                  ADC_SoftwareStartInjectedConvCmd PROC
;;;904    *******************************************************************************/
;;;905    void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00028a  2900              CMP      r1,#0
;;;906    {
00028c  d004              BEQ      |L1.664|
;;;907      /* Check the parameters */
;;;908      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;909      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;910    
;;;911      if (NewState != DISABLE)
;;;912      {
;;;913        /* Enable the selected ADC conversion for injected group on external event and start the selected
;;;914           ADC injected conversion */
;;;915        ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
00028e  6881              LDR      r1,[r0,#8]
000290  f4411102          ORR      r1,r1,#0x208000
000294  6081              STR      r1,[r0,#8]
;;;916      }
;;;917      else
;;;918      {
;;;919        /* Disable the selected ADC conversion on external event for injected group and stop the selected
;;;920           ADC injected conversion */
;;;921        ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
;;;922      }
;;;923    }
000296  4770              BX       lr
                  |L1.664|
000298  6881              LDR      r1,[r0,#8]            ;921
00029a  f4211102          BIC      r1,r1,#0x208000       ;921
00029e  6081              STR      r1,[r0,#8]            ;921
0002a0  4770              BX       lr
;;;924    
                          ENDP

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;931    *******************************************************************************/
;;;932    FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
0002a2  4601              MOV      r1,r0
;;;933    {
;;;934      FlagStatus bitstatus = RESET;
0002a4  2000              MOVS     r0,#0
;;;935    
;;;936      /* Check the parameters */
;;;937      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;938    
;;;939      /* Check the status of JSWSTART bit */
;;;940      if ((ADCx->CR2 & CR2_JSWSTART_Set) != (u32)RESET)
0002a6  6889              LDR      r1,[r1,#8]
0002a8  f4111f00          TST      r1,#0x200000
0002ac  d000              BEQ      |L1.688|
;;;941      {
;;;942        /* JSWSTART bit is set */
;;;943        bitstatus = SET;
0002ae  2001              MOVS     r0,#1
                  |L1.688|
;;;944      }
;;;945      else
;;;946      {
;;;947        /* JSWSTART bit is reset */
;;;948        bitstatus = RESET;
;;;949      }
;;;950    
;;;951      /* Return the JSWSTART bit status */
;;;952      return  bitstatus;
;;;953    }
0002b0  4770              BX       lr
;;;954    
                          ENDP

                  ADC_InjectedChannelConfig PROC
;;;995    *******************************************************************************/
;;;996    void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
0002b2  b430              PUSH     {r4,r5}
;;;997    {
;;;998      u32 tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
;;;999    
;;;1000     /* Check the parameters */
;;;1001     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1002     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1003     assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;1004     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;1005   
;;;1006     /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;1007     if (ADC_Channel > ADC_Channel_9)
;;;1008     {
;;;1009       /* Get the old register value */
;;;1010       tmpreg1 = ADCx->SMPR1;
;;;1011       /* Calculate the mask to clear */
;;;1012       tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
0002b4  2507              MOVS     r5,#7
0002b6  2909              CMP      r1,#9                 ;1007
0002b8  d90c              BLS      |L1.724|
0002ba  68c4              LDR      r4,[r0,#0xc]          ;1010
0002bc  f1a10c0a          SUB      r12,r1,#0xa
0002c0  eb0c0c4c          ADD      r12,r12,r12,LSL #1
0002c4  fa05f50c          LSL      r5,r5,r12
;;;1013       /* Clear the old discontinuous mode channel count */
;;;1014       tmpreg1 &= ~tmpreg2;
0002c8  43ac              BICS     r4,r4,r5
;;;1015       /* Calculate the mask to set */
;;;1016       tmpreg2 = (u32)ADC_SampleTime << (3*(ADC_Channel - 10));
0002ca  fa03f30c          LSL      r3,r3,r12
;;;1017       /* Set the discontinuous mode channel count */
;;;1018       tmpreg1 |= tmpreg2;
0002ce  4323              ORRS     r3,r3,r4
;;;1019       /* Store the new register value */
;;;1020       ADCx->SMPR1 = tmpreg1;
0002d0  60c3              STR      r3,[r0,#0xc]
0002d2  e009              B        |L1.744|
                  |L1.724|
;;;1021     }
;;;1022     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1023     {
;;;1024       /* Get the old register value */
;;;1025       tmpreg1 = ADCx->SMPR2;
0002d4  6904              LDR      r4,[r0,#0x10]
;;;1026       /* Calculate the mask to clear */
;;;1027       tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
0002d6  eb010c41          ADD      r12,r1,r1,LSL #1
0002da  fa05f50c          LSL      r5,r5,r12
;;;1028       /* Clear the old discontinuous mode channel count */
;;;1029       tmpreg1 &= ~tmpreg2;
0002de  43ac              BICS     r4,r4,r5
;;;1030       /* Calculate the mask to set */
;;;1031       tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
0002e0  fa03f30c          LSL      r3,r3,r12
;;;1032       /* Set the discontinuous mode channel count */
;;;1033       tmpreg1 |= tmpreg2;
0002e4  4323              ORRS     r3,r3,r4
;;;1034       /* Store the new register value */
;;;1035       ADCx->SMPR2 = tmpreg1;
0002e6  6103              STR      r3,[r0,#0x10]
                  |L1.744|
;;;1036     }
;;;1037   
;;;1038     /* Rank configuration */
;;;1039     /* Get the old register value */
;;;1040     tmpreg1 = ADCx->JSQR;
0002e8  6b83              LDR      r3,[r0,#0x38]
;;;1041     /* Get JL value: Number = JL+1 */
;;;1042     tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
0002ea  f3c35c01          UBFX     r12,r3,#20,#2
;;;1043     /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;1044     tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
0002ee  eba2020c          SUB      r2,r2,r12
0002f2  1c92              ADDS     r2,r2,#2
0002f4  eb020282          ADD      r2,r2,r2,LSL #2
0002f8  f04f0c1f          MOV      r12,#0x1f
0002fc  fa0cfc02          LSL      r12,r12,r2
;;;1045     /* Clear the old JSQx bits for the selected rank */
;;;1046     tmpreg1 &= ~tmpreg2;
000300  ea23030c          BIC      r3,r3,r12
;;;1047     /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;1048     tmpreg2 = (u32)ADC_Channel << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
000304  4091              LSLS     r1,r1,r2
;;;1049     /* Set the JSQx bits for the selected rank */
;;;1050     tmpreg1 |= tmpreg2;
000306  4319              ORRS     r1,r1,r3
;;;1051     /* Store the new register value */
;;;1052     ADCx->JSQR = tmpreg1;
000308  6381              STR      r1,[r0,#0x38]
;;;1053   }
00030a  bc30              POP      {r4,r5}
00030c  4770              BX       lr
;;;1054   
                          ENDP

                  ADC_InjectedSequencerLengthConfig PROC
;;;1063   *******************************************************************************/
;;;1064   void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length)
00030e  6b82              LDR      r2,[r0,#0x38]
;;;1065   {
;;;1066     u32 tmpreg1 = 0;
;;;1067     u32 tmpreg2 = 0;
;;;1068   
;;;1069     /* Check the parameters */
;;;1070     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1071     assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;1072     
;;;1073     /* Get the old register value */
;;;1074     tmpreg1 = ADCx->JSQR;
;;;1075     /* Clear the old injected sequnence lenght JL bits */
;;;1076     tmpreg1 &= JSQR_JL_Reset;
000310  f4221240          BIC      r2,r2,#0x300000
;;;1077     /* Set the injected sequnence lenght JL bits */
;;;1078     tmpreg2 = Length - 1; 
000314  1e49              SUBS     r1,r1,#1
;;;1079     tmpreg1 |= tmpreg2 << 20;
000316  ea425101          ORR      r1,r2,r1,LSL #20
;;;1080     /* Store the new register value */
;;;1081     ADCx->JSQR = tmpreg1;
00031a  6381              STR      r1,[r0,#0x38]
;;;1082   }
00031c  4770              BX       lr
;;;1083   
                          ENDP

                  ADC_SetInjectedOffset PROC
;;;1099   *******************************************************************************/
;;;1100   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)
00031e  5042              STR      r2,[r0,r1]
;;;1101   {
;;;1102     /* Check the parameters */
;;;1103     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1104     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1105     assert_param(IS_ADC_OFFSET(Offset));  
;;;1106   
;;;1107     /* Set the selected injected channel data offset */
;;;1108     *((vu32 *)((*(u32*)&ADCx) + ADC_InjectedChannel)) = (u32)Offset;
;;;1109   }
000320  4770              BX       lr
;;;1110   
                          ENDP

                  ADC_GetInjectedConversionValue PROC
;;;1123   *******************************************************************************/
;;;1124   u16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel)
000322  4408              ADD      r0,r0,r1
;;;1125   {
;;;1126     /* Check the parameters */
;;;1127     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1128     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1129   
;;;1130     /* Returns the selected injected channel conversion data value */
;;;1131     return (u16) (*(vu32*) (((*(u32*)&ADCx) + ADC_InjectedChannel + JDR_Offset)));
000324  6a80              LDR      r0,[r0,#0x28]
000326  b280              UXTH     r0,r0
;;;1132   }
000328  4770              BX       lr
;;;1133   
                          ENDP

                  ADC_AnalogWatchdogCmd PROC
;;;1157   *******************************************************************************/
;;;1158   void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog)
00032a  6842              LDR      r2,[r0,#4]
;;;1159   {
;;;1160     u32 tmpreg = 0;
;;;1161   
;;;1162     /* Check the parameters */
;;;1163     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1164     assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;1165   
;;;1166     /* Get the old register value */
;;;1167     tmpreg = ADCx->CR1;
;;;1168     /* Clear AWDEN, AWDENJ and AWDSGL bits */
;;;1169     tmpreg &= CR1_AWDMode_Reset;
00032c  f4227200          BIC      r2,r2,#0x200
000330  f4220240          BIC      r2,r2,#0xc00000
;;;1170     /* Set the analog watchdog enable mode */
;;;1171     tmpreg |= ADC_AnalogWatchdog;
000334  4311              ORRS     r1,r1,r2
;;;1172     /* Store the new register value */
;;;1173     ADCx->CR1 = tmpreg;
000336  6041              STR      r1,[r0,#4]
;;;1174   }
000338  4770              BX       lr
;;;1175   
                          ENDP

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;1186   *******************************************************************************/
;;;1187   void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold,
00033a  6241              STR      r1,[r0,#0x24]
;;;1188                                           u16 LowThreshold)
;;;1189   {
;;;1190     /* Check the parameters */
;;;1191     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1192     assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;1193     assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;1194   
;;;1195     /* Set the ADCx high threshold */
;;;1196     ADCx->HTR = HighThreshold;
;;;1197     /* Set the ADCx low threshold */
;;;1198     ADCx->LTR = LowThreshold;
00033c  6282              STR      r2,[r0,#0x28]
;;;1199   }
00033e  4770              BX       lr
;;;1200   
                          ENDP

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;1228   *******************************************************************************/
;;;1229   void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel)
000340  6842              LDR      r2,[r0,#4]
;;;1230   {
;;;1231     u32 tmpreg = 0;
;;;1232   
;;;1233     /* Check the parameters */
;;;1234     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1235     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1236   
;;;1237     /* Get the old register value */
;;;1238     tmpreg = ADCx->CR1;
;;;1239     /* Clear the Analog watchdog channel select bits */
;;;1240     tmpreg &= CR1_AWDCH_Reset;
000342  f022021f          BIC      r2,r2,#0x1f
;;;1241     /* Set the Analog watchdog channel */
;;;1242     tmpreg |= ADC_Channel;
000346  4311              ORRS     r1,r1,r2
;;;1243     /* Store the new register value */
;;;1244     ADCx->CR1 = tmpreg;
000348  6041              STR      r1,[r0,#4]
;;;1245   }
00034a  4770              BX       lr
;;;1246   
                          ENDP

                  ADC_TempSensorVrefintCmd PROC
;;;1254   *******************************************************************************/
;;;1255   void ADC_TempSensorVrefintCmd(FunctionalState NewState)
00034c  4916              LDR      r1,|L1.936|
;;;1256   {
;;;1257     /* Check the parameters */
;;;1258     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1259   
;;;1260     if (NewState != DISABLE)
00034e  2800              CMP      r0,#0
000350  d004              BEQ      |L1.860|
;;;1261     {
;;;1262       /* Enable the temperature sensor and Vrefint channel*/
;;;1263       ADC1->CR2 |= CR2_TSVREFE_Set;
000352  6808              LDR      r0,[r1,#0]
000354  f4400000          ORR      r0,r0,#0x800000
000358  6008              STR      r0,[r1,#0]
;;;1264     }
;;;1265     else
;;;1266     {
;;;1267       /* Disable the temperature sensor and Vrefint channel*/
;;;1268       ADC1->CR2 &= CR2_TSVREFE_Reset;
;;;1269     }
;;;1270   }
00035a  4770              BX       lr
                  |L1.860|
00035c  6808              LDR      r0,[r1,#0]            ;1268
00035e  f4200000          BIC      r0,r0,#0x800000       ;1268
000362  6008              STR      r0,[r1,#0]            ;1268
000364  4770              BX       lr
;;;1271   
                          ENDP

                  ADC_GetFlagStatus PROC
;;;1285   *******************************************************************************/
;;;1286   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG)
000366  4602              MOV      r2,r0
;;;1287   {
;;;1288     FlagStatus bitstatus = RESET;
000368  2000              MOVS     r0,#0
;;;1289   
;;;1290     /* Check the parameters */
;;;1291     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1292     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1293   
;;;1294     /* Check the status of the specified ADC flag */
;;;1295     if ((ADCx->SR & ADC_FLAG) != (u8)RESET)
00036a  6812              LDR      r2,[r2,#0]
00036c  420a              TST      r2,r1
00036e  d000              BEQ      |L1.882|
;;;1296     {
;;;1297       /* ADC_FLAG is set */
;;;1298       bitstatus = SET;
000370  2001              MOVS     r0,#1
                  |L1.882|
;;;1299     }
;;;1300     else
;;;1301     {
;;;1302       /* ADC_FLAG is reset */
;;;1303       bitstatus = RESET;
;;;1304     }
;;;1305   
;;;1306     /* Return the ADC_FLAG status */
;;;1307     return  bitstatus;
;;;1308   }
000372  4770              BX       lr
;;;1309   
                          ENDP

                  ADC_ClearFlag PROC
;;;1323   *******************************************************************************/
;;;1324   void ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG)
000374  43c9              MVNS     r1,r1
;;;1325   {
;;;1326     /* Check the parameters */
;;;1327     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1328     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1329   
;;;1330     /* Clear the selected ADC flags */
;;;1331     ADCx->SR = ~(u32)ADC_FLAG;
000376  6001              STR      r1,[r0,#0]
;;;1332   }
000378  4770              BX       lr
;;;1333   
                          ENDP

                  ADC_GetITStatus PROC
;;;1345   *******************************************************************************/
;;;1346   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT)
00037a  2200              MOVS     r2,#0
;;;1347   {
;;;1348     ITStatus bitstatus = RESET;
;;;1349     u32 itmask = 0, enablestatus = 0;
;;;1350   
;;;1351     /* Check the parameters */
;;;1352     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1353     assert_param(IS_ADC_GET_IT(ADC_IT));
;;;1354   
;;;1355     /* Get the ADC IT index */
;;;1356     itmask = ADC_IT >> 8;
00037c  0a0b              LSRS     r3,r1,#8
;;;1357   
;;;1358     /* Get the ADC_IT enable bit status */
;;;1359     enablestatus = (ADCx->CR1 & (u8)ADC_IT) ;
00037e  f8d0c004          LDR      r12,[r0,#4]
000382  b2c9              UXTB     r1,r1
000384  ea0c0101          AND      r1,r12,r1
;;;1360   
;;;1361     /* Check the status of the specified ADC interrupt */
;;;1362     if (((ADCx->SR & itmask) != (u32)RESET) && enablestatus)
000388  6800              LDR      r0,[r0,#0]
00038a  4218              TST      r0,r3
00038c  d001              BEQ      |L1.914|
00038e  b101              CBZ      r1,|L1.914|
;;;1363     {
;;;1364       /* ADC_IT is set */
;;;1365       bitstatus = SET;
000390  2201              MOVS     r2,#1
                  |L1.914|
;;;1366     }
;;;1367     else
;;;1368     {
;;;1369       /* ADC_IT is reset */
;;;1370       bitstatus = RESET;
;;;1371     }
;;;1372   
;;;1373     /* Return the ADC_IT status */
;;;1374     return  bitstatus;
000392  4610              MOV      r0,r2
;;;1375   }
000394  4770              BX       lr
;;;1376   
                          ENDP

                  ADC_ClearITPendingBit PROC
;;;1388   *******************************************************************************/
;;;1389   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT)
000396  0a09              LSRS     r1,r1,#8
;;;1390   {
;;;1391     u8 itmask = 0;
;;;1392   
;;;1393     /* Check the parameters */
;;;1394     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1395     assert_param(IS_ADC_IT(ADC_IT));
;;;1396   
;;;1397     /* Get the ADC IT index */
;;;1398     itmask = (u8)(ADC_IT >> 8);
;;;1399   
;;;1400     /* Clear the selected ADC interrupt pending bits */
;;;1401     ADCx->SR = ~(u32)itmask;
000398  43c9              MVNS     r1,r1
00039a  6001              STR      r1,[r0,#0]
;;;1402   }
00039c  4770              BX       lr
;;;1403   
                          ENDP

00039e  0000              DCW      0x0000
                  |L1.928|
                          DCD      0xfff1f7fd
                  |L1.932|
                          DCD      0x4001244c
                  |L1.936|
                          DCD      0x40012408
